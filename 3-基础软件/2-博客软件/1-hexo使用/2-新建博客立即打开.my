<h1>在 hexo new 之后立即打开新建的 Markdown 文稿</h1>

<h2>本机实践：</h2>

<h3>cmd命令：</h3>

<p>win7环境下，命令行使用sublime 打开文件</p>

<blockquote>start &quot;/Applications/Sublime Text.app&quot; test.txt</blockquote>

<h3>hexo设置：</h3>

<p>到hexo安装目录下，新建scripts文件夹，新建随意名称的 js文件如 openFile.js 编辑如下</p>

<blockquote>
<p>var exec = require(&#39;child_process&#39;).exec;</p>

<p>// Hexo 2.x<br />
hexo.on(&#39;new&#39;, function(path){<br />
&nbsp; &nbsp; exec(&#39;start &quot;/Applications/Sublime Text.app&quot; &#39; + path.path);<br />
});</p>

<p><strong>注意，这里的path是一个有多个属性[path: &quot;...&quot; , content:&quot;...&quot;] 的对象，取路径的时候要 path.path。</strong></p>
</blockquote>

<h2>hexo添加监听事件</h2>

<h3>需求场景</h3>

<p>自己的博客是用 Hexo 搭建的。Hexo 是其时尚为大学生的台湾人&nbsp;<a href="https://github.com/tommy351" rel="external" target="_blank">Tommy</a>&nbsp;开发的轻量级静态博客生成器，具有简洁、快速、扩展性好等特点。</p>

<p>在 Hexo 中新建一篇博文非常简单，只需要在命令行中执行</p>

<pre>
<code>hexo new &quot;the title of your blog&quot;
</code></pre>

<p>即可。Hexo 会在后台自动帮你创建名为&nbsp;<code>yyyy-mm-dd-the-title-of-your-blog.md</code>&nbsp;的文件，供你撰写博文。不过，也有不方便的地方。通常你需要依次打开&nbsp;<code>hexo-home/source/_post</code>&nbsp;目录，然后在成堆的 Markdown 文件中找到刚才创建的文档。</p>

<p>简单搜索之后，我发现在 Hexo 的 GitHub 项目里，有人提出了类似的需求：</p>

<p><a href="https://github.com/hexojs/hexo/issues/1007" rel="external" target="_blank">https://github.com/hexojs/hexo/issues/1007</a></p>

<h3>网上解决方案</h3>

<p>Tommy 指出，可以在 Hexo 目录下的&nbsp;<code>scripts</code>&nbsp;目录（若没有，则新建一个）中创建一个 JavaScript 脚本，监听&nbsp;<code>hexo new</code>&nbsp;这个动作。并在检测到&nbsp;<code>hexo new</code>&nbsp;之后，执行编辑器打开的命令。</p>

<p>Tommy 给出的代码如下：</p>

<blockquote>
<p>var spawn = require(&#39;child_process&#39;).spawn;</p>

<p>// Hexo 2.x<br />
hexo.on(&#39;new&#39;, function(path){<br />
&nbsp; spawn(&#39;vi&#39;, [path]);<br />
});</p>

<p>// Hexo 3<br />
hexo.on(&#39;new&#39;, function(data){<br />
&nbsp; spawn(&#39;vi&#39;, [data.path]);<br />
});</p>
</blockquote>

<h3>网友自己的解决方案</h3>

<p>简单翻阅了一下 JavaScript 的语法规则，我尝试了下列 JavaScript 代码：我使用的 Hexo 是 2.5.4 版本，然而，测试过 Tommy 给出的代码之后并没有顺利地打开编辑器。不过精髓已经理解，需要的就只是细节的改变了。</p>

<blockquote>
<p>var exec = require(&#39;child_process&#39;).exec;</p>

<p>// Hexo 2.x<br />
hexo.on(&#39;new&#39;, function(path){<br />
&nbsp; &nbsp; exec(&#39;open -a &quot;/Applications/Sublime Text.app&quot; &#39; + path);<br />
});</p>
</blockquote>

<blockquote>
<p><strong>注意，我这里执行的系统命令，是 OS X 下的&nbsp;<code>open</code>。换到 Windows 中，可能需要改为&nbsp;<code>start</code>。</strong></p>
</blockquote>

<p>在命令行中敲下</p>

<pre>
<code>hexo new &quot;open editor after hexo new immediately&quot;
</code></pre>

<p>之后，Sublime Text 顺利打开了相应的 Markdown 文稿。接下来的事情，就是愉快地写作啦！</p>

<h2>相关知识：创建异步进程</h2>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_asynchronous_process_creation">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/asynchronous_process_creation.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/asynchronous_process_creation.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p><a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>、<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>、<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>&nbsp;方法都遵循与其他 Node.js API 一样的惯用的异步编程模式。</p>

<p>每个方法都返回一个&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process"><code>ChildProcess</code></a>&nbsp;实例。 这些对象实现了 Node.js&nbsp;<a href="http://nodejs.cn/api/events.html#events_class_eventemitter"><code>EventEmitter</code></a>&nbsp;的 API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。</p>

<p><a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>&nbsp;返回可以额外指定一个可选的&nbsp;<code>callback</code>&nbsp;函数，当子进程结束时会被调用。</p>

<h3>在 Windows 上衍生&nbsp;<code>.bat</code>&nbsp;和&nbsp;<code>.cmd</code>&nbsp;文件<a href="http://nodejs.cn/api/child_process.html#child_process_spawning_bat_and_cmd_files_on_windows" id="child_process_spawning_bat_and_cmd_files_on_windows">#</a></h3>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_spawning_bat_and_cmd_files_on_windows">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/spawning_bat_and_cmd_files_on_windows.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/spawning_bat_and_cmd_files_on_windows.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p><a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>&nbsp;之间的重大区别会根据平台的不同而不同。 在类 Unix 操作系统上（Unix、 Linux、 macOS），<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>&nbsp;效率更高，因为它不需要衍生一个 shell。 但是在 Windows 上，<code>.bat</code>&nbsp;和&nbsp;<code>.cmd</code>&nbsp;文件在没有终端的情况下是不可执行的，因此不能使用&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile()</code></a>&nbsp;启动。 当在 Windows 下运行时，要调用&nbsp;<code>.bat</code>&nbsp;和&nbsp;<code>.cmd</code>&nbsp;文件，可以通过使用设置了&nbsp;<code>shell</code>&nbsp;选项的&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>、或使用&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>、或衍生&nbsp;<code>cmd.exe</code>&nbsp;并将&nbsp;<code>.bat</code>&nbsp;或&nbsp;<code>.cmd</code>&nbsp;文件作为一个参数传入（也就是&nbsp;<code>shell</code>&nbsp;选项和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;所做的工作）。 在任何情况下，如果脚本文件名包含了空格，则需要用加上引号。</p>

<pre>
<code>// 仅限 Windows 系统
const { spawn } = require(&#39;child_process&#39;);
const bat = spawn(&#39;cmd.exe&#39;, [&#39;/c&#39;, &#39;my.bat&#39;]);

bat.stdout.on(&#39;data&#39;, (data) =&gt; {
  console.log(data.toString());
});

bat.stderr.on(&#39;data&#39;, (data) =&gt; {
  console.log(data.toString());
});

bat.on(&#39;exit&#39;, (code) =&gt; {
  console.log(`子进程退出码：${code}`);
});
</code></pre>

<pre>
<code>// 或
const { exec } = require(&#39;child_process&#39;);
exec(&#39;my.bat&#39;, (err, stdout, stderr) =&gt; {
  if (err) {
    console.error(err);
    return;
  }
  console.log(stdout);
});

// 文件名带有空格的脚本：
const bat = spawn(&#39;&quot;my script.cmd&quot;&#39;, [&#39;a&#39;, &#39;b&#39;], { shell: true });
// 或：
exec(&#39;&quot;my script.cmd&quot; a b&#39;, (err, stdout, stderr) =&gt; {
  // ...
});
</code></pre>

<h3>child_process.exec(command[, options][, callback])<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback" id="child_process_child_process_exec_command_options_callback">#</a></h3>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_exec_command_options_callback">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/child_process_exec_command_options_callback.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_exec_command_options_callback.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p>版本历史</p>

<ul>
	<li><code>command</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;要运行的命令，用空格分隔参数。</li>
	<li><code>options</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>
	<ul>
		<li><code>cwd</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;子进程的当前工作目录。</li>
		<li><code>env</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>&nbsp;环境变量键值对。</li>
		<li><code>encoding</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;默认为&nbsp;<code>&#39;utf8&#39;</code>。</li>
		<li><code>shell</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;用于执行命令的 shell。 在 UNIX 上默认为&nbsp;<code>&#39;/bin/sh&#39;</code>，在 Windows 上默认为&nbsp;<code>process.env.ComSpec</code>。 详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_shell_requirements">Shell Requirements</a>&nbsp;与&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_default_windows_shell">Default Windows Shell</a>。</li>
		<li><code>timeout</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;默认为&nbsp;<code>0</code>。</li>
		<li><a href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><code>maxBuffer</code></a>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;stdout 或 stderr 允许的最大字节数。 默认为&nbsp;<code>200*1024</code>。 如果超过限制，则子进程会被终止。 查看警告：&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><code>maxBuffer</code>&nbsp;and Unicode</a>。</li>
		<li><code>killSignal</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;|&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;integer&gt;</a>&nbsp;默认为&nbsp;<code>&#39;SIGTERM&#39;</code>。</li>
		<li><code>uid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的用户标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</a>）</li>
		<li><code>gid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的组标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</a>）</li>
		<li><code>windowsHide</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;Hide the subprocess console window that would normally be created on Windows systems.&nbsp;<strong>Default:</strong>&nbsp;<code>false</code>.</li>
	</ul>
	</li>
	<li><code>callback</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</a>&nbsp;当进程终止时调用，并带上输出。
	<ul>
		<li><code>error</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</a></li>
		<li><code>stdout</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;|&nbsp;<a href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</a></li>
		<li><code>stderr</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;|&nbsp;<a href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</a></li>
	</ul>
	</li>
	<li>返回:&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</a></li>
</ul>

<p>衍生一个 shell，然后在 shell 中执行&nbsp;<code>command</code>，且缓冲任何产生的输出。传入 exec 函数的&nbsp;<code>command</code>&nbsp;字符串会被 shell 直接处理，特殊字符（因&nbsp;<a href="https://en.wikipedia.org/wiki/List_of_command-line_interpreters">shell</a>&nbsp;而异）需要相应处理：</p>

<pre>
<code>exec(&#39;&quot;/path/to/test file/test.sh&quot; arg1 arg2&#39;);
// 使用双引号这样路径中的空格就不会被解释为多个参数

exec(&#39;echo &quot;The \\$HOME variable is $HOME&quot;&#39;);
// 第一个 $HOME 被转义了，但第二个没有
</code></pre>

<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>

<pre>
<code>const { exec } = require(&#39;child_process&#39;);
exec(&#39;cat *.js bad_file | wc -l&#39;, (error, stdout, stderr) =&gt; {
  if (error) {
    console.error(`exec error: ${error}`);
    return;
  }
  console.log(`stdout: ${stdout}`);
  console.log(`stderr: ${stderr}`);
});
</code></pre>

<p>如果提供了一个&nbsp;<code>callback</code>&nbsp;函数，则它被调用时会带上参数&nbsp;<code>(error, stdout, stderr)</code>。 当成功时，<code>error</code>&nbsp;会是&nbsp;<code>null</code>。 当失败时，<code>error</code>&nbsp;会是一个&nbsp;<a href="http://nodejs.cn/api/errors.html#errors_class_error"><code>Error</code></a>&nbsp;实例。<code>error.code</code>&nbsp;属性会是子进程的退出码，<code>error.signal</code>&nbsp;会被设为终止进程的信号。 除&nbsp;<code>0</code>&nbsp;以外的任何退出码都被认为是一个错误。</p>

<p>传给回调的&nbsp;<code>stdout</code>&nbsp;和&nbsp;<code>stderr</code>&nbsp;参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。&nbsp;<code>encoding</code>&nbsp;选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果&nbsp;<code>encoding</code>&nbsp;是&nbsp;<code>&#39;buffer&#39;</code>、或一个无法识别的字符编码，则传入&nbsp;<code>Buffer</code>&nbsp;对象到回调函数。</p>

<p><code>options</code>&nbsp;参数可以作为第二个参数传入，用于自定义如何衍生进程。 默认的选项是：</p>

<pre>
<code>const defaults = {
  encoding: &#39;utf8&#39;,
  timeout: 0,
  maxBuffer: 200 * 1024,
  killSignal: &#39;SIGTERM&#39;,
  cwd: null,
  env: null
};
</code></pre>

<p>如果&nbsp;<code>timeout</code>&nbsp;大于&nbsp;<code>0</code>，当子进程运行超过&nbsp;<code>timeout</code>&nbsp;毫秒时，父进程就会发送由&nbsp;<code>killSignal</code>&nbsp;属性标识的信号（默认为&nbsp;<code>&#39;SIGTERM&#39;</code>）。</p>

<p>注意：不像 POSIX 系统调用中的&nbsp;<a href="http://man7.org/linux/man-pages/man3/exec.3.html">exec(3)</a>，<code>child_process.exec()</code>&nbsp;不会替换现有的进程，且使用一个 shell 来执行命令。</p>

<p>如果调用该方法的&nbsp;<a href="http://nodejs.cn/api/util.html#util_util_promisify_original"><code>util.promisify()</code></a>&nbsp;版本，将会返回一个包含&nbsp;<code>stdout</code>&nbsp;和&nbsp;<code>stderr</code>&nbsp;的 Promise 对象。在出现错误的情况洗，将返回 rejected 状态的 promise，拥有与回调函数一样的&nbsp;<code>error</code>&nbsp;对象，但附加了&nbsp;<code>stdout</code>&nbsp;和&nbsp;<code>stderr</code>&nbsp;属性。</p>

<p>例子:</p>

<pre>
<code>const util = require(&#39;util&#39;);
const exec = util.promisify(require(&#39;child_process&#39;).exec);

async function lsExample() {
  const { stdout, stderr } = await exec(&#39;ls&#39;);
  console.log(&#39;stdout:&#39;, stdout);
  console.log(&#39;stderr:&#39;, stderr);
}
lsExample();
</code></pre>

<h3>child_process.execFile(file[, args][, options][, callback])<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback" id="child_process_child_process_execfile_file_args_options_callback">#</a></h3>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_execfile_file_args_options_callback">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/child_process_execfile_file_args_options_callback.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_execfile_file_args_options_callback.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p>版本历史</p>

<ul>
	<li><code>file</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;要运行的可执行文件的名称或路径。</li>
	<li><code>args</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string[]&gt;</a>&nbsp;字符串参数列表。</li>
	<li><code>options</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>
	<ul>
		<li><code>cwd</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;子进程的当前工作目录。</li>
		<li><code>env</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>&nbsp;环境变量键值对。</li>
		<li><code>encoding</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;默认为&nbsp;<code>&#39;utf8&#39;</code>。</li>
		<li><code>timeout</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;默认为&nbsp;<code>0</code>。</li>
		<li><a href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><code>maxBuffer</code></a>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;stdout 或 stderr 允许的最大字节数。 默认为&nbsp;<code>200*1024</code>。 如果超过限制，则子进程会被终止。 See caveat at&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><code>maxBuffer</code>&nbsp;and Unicode</a>.</li>
		<li><code>killSignal</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;|&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;integer&gt;</a>&nbsp;默认为&nbsp;<code>&#39;SIGTERM&#39;</code>。</li>
		<li><code>uid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的用户标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</a>）</li>
		<li><code>gid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的组标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</a>）</li>
		<li><code>windowsHide</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;Hide the subprocess console window that would normally be created on Windows systems.&nbsp;<strong>Default:</strong>&nbsp;<code>false</code>.</li>
		<li><code>windowsVerbatimArguments</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;No quoting or escaping of arguments is done on Windows. Ignored on Unix.&nbsp;<strong>Default:</strong>&nbsp;<code>false</code>.</li>
	</ul>
	</li>
	<li><code>callback</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</a>&nbsp;当进程终止时调用，并带上输出。
	<ul>
		<li><code>error</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</a></li>
		<li><code>stdout</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;|&nbsp;<a href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</a></li>
		<li><code>stderr</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;|&nbsp;<a href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</a></li>
	</ul>
	</li>
	<li>返回:&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</a></li>
</ul>

<p><code>child_process.execFile()</code>&nbsp;函数类似&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>，除了不衍生一个 shell。 而是，指定的可执行的&nbsp;<code>file</code>&nbsp;被直接衍生为一个新进程，这使得它比&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;更高效。</p>

<p>它支持和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。</p>

<pre>
<code>const { execFile } = require(&#39;child_process&#39;);
const child = execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) =&gt; {
  if (error) {
    throw error;
  }
  console.log(stdout);
});
</code></pre>

<p>传给回调的&nbsp;<code>stdout</code>&nbsp;和&nbsp;<code>stderr</code>&nbsp;参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。&nbsp;<code>encoding</code>&nbsp;选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果&nbsp;<code>encoding</code>&nbsp;是&nbsp;<code>&#39;buffer&#39;</code>、或一个无法识别的字符编码，则传入&nbsp;<code>Buffer</code>&nbsp;对象到回调函数。</p>

<p>如果调用该方法的&nbsp;<a href="http://nodejs.cn/api/util.html#util_util_promisify_original"><code>util.promisify()</code></a>&nbsp;版本， 它会返回一个拥有&nbsp;<code>stdout</code>&nbsp;和&nbsp;<code>stderr</code>&nbsp;属性的 Promise 对象. 在发生错误的情况下, 返回一个 rejected 状态的 promise, 拥有与回调 函数一样的&nbsp;<code>error</code>&nbsp;对象, 但是附加了&nbsp;<code>stdout</code>&nbsp;和&nbsp;<code>stderr</code>&nbsp;这两个属性.</p>

<pre>
<code>const util = require(&#39;util&#39;);
const execFile = util.promisify(require(&#39;child_process&#39;).execFile);
async function getVersion() {
  const { stdout } = await execFile(&#39;node&#39;, [&#39;--version&#39;]);
  console.log(stdout);
}
getVersion();
</code></pre>

<h3>child_process.fork(modulePath[, args][, options])<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options" id="child_process_child_process_fork_modulepath_args_options">#</a></h3>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_fork_modulepath_args_options">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/child_process_fork_modulepath_args_options.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_fork_modulepath_args_options.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p>版本历史</p>

<ul>
	<li><code>modulePath</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;要在子进程中运行的模块。</li>
	<li><code>args</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</a>&nbsp;字符串参数列表。</li>
	<li><code>options</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>
	<ul>
		<li><code>cwd</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;子进程的当前工作目录。</li>
		<li><code>env</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>&nbsp;环境变量键值对。</li>
		<li><code>execPath</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;用来创建子进程的执行路径。</li>
		<li><code>execArgv</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</a>&nbsp;要传给执行路径的字符串参数列表。默认为&nbsp;<code>process.execArgv</code>。</li>
		<li><code>silent</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;如果为&nbsp;<code>true</code>，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>&nbsp;的&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><code>stdio</code></a>中的&nbsp;<code>&#39;pipe&#39;</code>&nbsp;和&nbsp;<code>&#39;inherit&#39;</code>&nbsp;选项。 默认:&nbsp;<code>false</code>。</li>
		<li><code>stdio</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</a>&nbsp;|&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>&nbsp;的&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><code>stdio</code></a>。 当提供了该选项，则它会覆盖&nbsp;<code>silent</code>。 如果使用了数组变量，则该数组必须包含一个值为&nbsp;<code>&#39;ipc&#39;</code>&nbsp;的子项，否则会抛出错误。 例如&nbsp;<code>[0, 1, 2, &#39;ipc&#39;]</code>。</li>
		<li><code>windowsVerbatimArguments</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;No quoting or escaping of arguments is done on Windows. Ignored on Unix.&nbsp;<strong>Default:</strong>&nbsp;<code>false</code>.</li>
		<li><code>uid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的用户标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</a>）</li>
		<li><code>gid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的组标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</a>）</li>
	</ul>
	</li>
	<li>返回:&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</a></li>
</ul>

<p><code>child_process.fork()</code>&nbsp;方法是&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>&nbsp;的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>&nbsp;一样返回一个&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process"><code>ChildProcess</code></a>&nbsp;对象。 返回的&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process"><code>ChildProcess</code></a>&nbsp;会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_send_message_sendhandle_options_callback"><code>subprocess.send()</code></a>。</p>

<p>衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。</p>

<p>默认情况下，<code>child_process.fork()</code>&nbsp;会使用父进程中的&nbsp;<a href="http://nodejs.cn/api/process.html#process_process_execpath"><code>process.execPath</code></a>&nbsp;衍生新的 Node.js 实例。&nbsp;<code>options</code>&nbsp;对象中的&nbsp;<code>execPath</code>&nbsp;属性可以替换要使用的执行路径。</p>

<p>使用自定义的&nbsp;<code>execPath</code>&nbsp;启动的 Node.js 进程，会使用子进程的环境变量&nbsp;<code>NODE_CHANNEL_FD</code>&nbsp;中指定的文件描述符（fd）与父进程通信。 fd 上的输入和输出期望被分割成一行一行的 JSON 对象。</p>

<p>注意，不像 POSIX 系统回调中的&nbsp;<a href="http://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</a>，<code>child_process.fork()</code>&nbsp;不会克隆当前进程。</p>

<p><em>Note</em>: The&nbsp;<code>shell</code>&nbsp;option available in&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><code>child_process.spawn()</code></a>&nbsp;is not supported by&nbsp;<code>child_process.fork()</code>&nbsp;and will be ignored if set.</p>

<h3>child_process.spawn(command[, args][, options])<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options" id="child_process_child_process_spawn_command_args_options">#</a></h3>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_spawn_command_args_options">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/child_process_spawn_command_args_options.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_spawn_command_args_options.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p>版本历史</p>

<ul>
	<li><code>command</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;要运行的命令。</li>
	<li><code>args</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</a>&nbsp;字符串参数列表。</li>
	<li><code>options</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>
	<ul>
		<li><code>cwd</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;子进程的当前工作目录。</li>
		<li><code>env</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</a>&nbsp;环境变量键值对。</li>
		<li><code>argv0</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;显式地设置要发给子进程的&nbsp;<code>argv[0]</code>&nbsp;的值。 如果未指定，则设为&nbsp;<code>command</code>。</li>
		<li><code>stdio</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</a>&nbsp;|&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;子进程的 stdio 配置。 （详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><code>options.stdio</code></a>）</li>
		<li><code>detached</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;准备将子进程独立于父进程运行。 具体行为取决于平台。（详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_options_detached"><code>options.detached</code></a>）</li>
		<li><code>uid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的用户标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</a>）</li>
		<li><code>gid</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;number&gt;</a>&nbsp;设置该进程的组标识。（详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</a>）</li>
		<li><code>shell</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;|&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;string&gt;</a>&nbsp;如果为&nbsp;<code>true</code>，则在一个 shell 中运行&nbsp;<code>command</code>。 在 UNIX 上使用&nbsp;<code>&#39;/bin/sh&#39;</code>，在 Windows 上使用&nbsp;<code>process.env.ComSpec</code>。 一个不同的 shell 可以被指定为字符串。 See&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_shell_requirements">Shell Requirements</a>&nbsp;and&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_default_windows_shell">Default Windows Shell</a>. 默认为&nbsp;<code>false</code>（没有 shell）。</li>
		<li><code>windowsVerbatimArguments</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;No quoting or escaping of arguments is done on Windows. Ignored on Unix. This is set to&nbsp;<code>true</code>&nbsp;automatically when&nbsp;<code>shell</code>&nbsp;is specified.&nbsp;<strong>Default:</strong>&nbsp;<code>false</code>.</li>
		<li><code>windowsHide</code>&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;boolean&gt;</a>&nbsp;Hide the subprocess console window that would normally be created on Windows systems.&nbsp;<strong>Default:</strong>&nbsp;<code>false</code>.</li>
	</ul>
	</li>
	<li>返回:&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</a></li>
</ul>

<p><code>child_process.spawn()</code>&nbsp;方法使用给定的&nbsp;<code>command</code>&nbsp;和&nbsp;<code>args</code>&nbsp;中的命令行参数来衍生一个新进程。 如果省略&nbsp;<code>args</code>，则默认为一个空数组。</p>

<p>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</p>

<p>第三个参数可以用来指定额外的选项，默认如下：</p>

<pre>
<code>const defaults = {
  cwd: undefined,
  env: process.env
};
</code></pre>

<p>使用&nbsp;<code>cwd</code>&nbsp;来指定衍生的进程的工作目录。 如果没有给出，则默认继承当前的工作目录。</p>

<p>使用&nbsp;<code>env</code>&nbsp;来指定环境变量，这会在新进程中可见，默认为&nbsp;<a href="http://nodejs.cn/api/process.html#process_process_env"><code>process.env</code></a>。</p>

<p>例子，运行&nbsp;<code>ls -lh /usr</code>，捕获&nbsp;<code>stdout</code>、<code>stderr</code>、以及退出码：</p>

<pre>
<code>const { spawn } = require(&#39;child_process&#39;);
const ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);

ls.stdout.on(&#39;data&#39;, (data) =&gt; {
  console.log(`stdout: ${data}`);
});

ls.stderr.on(&#39;data&#39;, (data) =&gt; {
  console.log(`stderr: ${data}`);
});

ls.on(&#39;close&#39;, (code) =&gt; {
  console.log(`子进程退出码：${code}`);
});
</code></pre>

<p>例子，一种执行&nbsp;<code>&#39;ps ax | grep ssh&#39;</code>&nbsp;的方法：</p>

<pre>
<code>const { spawn } = require(&#39;child_process&#39;);
const ps = spawn(&#39;ps&#39;, [&#39;ax&#39;]);
const grep = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);

ps.stdout.on(&#39;data&#39;, (data) =&gt; {
  grep.stdin.write(data);
});

ps.stderr.on(&#39;data&#39;, (data) =&gt; {
  console.log(`ps stderr: ${data}`);
});

ps.on(&#39;close&#39;, (code) =&gt; {
  if (code !== 0) {
    console.log(`ps 进程退出码：${code}`);
  }
  grep.stdin.end();
});

grep.stdout.on(&#39;data&#39;, (data) =&gt; {
  console.log(data.toString());
});

grep.stderr.on(&#39;data&#39;, (data) =&gt; {
  console.log(`grep stderr: ${data}`);
});

grep.on(&#39;close&#39;, (code) =&gt; {
  if (code !== 0) {
    console.log(`grep 进程退出码：${code}`);
  }
});
</code></pre>

<p>例子，检测失败的&nbsp;<code>spawn</code>：</p>

<pre>
<code>const { spawn } = require(&#39;child_process&#39;);
const subprocess = spawn(&#39;bad_command&#39;);

subprocess.on(&#39;error&#39;, (err) =&gt; {
  console.log(&#39;启动子进程失败。&#39;);
});
</code></pre>

<p>注意：某些平台（macOS, Linux）会使用&nbsp;<code>argv[0]</code>&nbsp;的值作为进程的标题，而其他平台（Windows, SunOS）则使用&nbsp;<code>command</code>。</p>

<p>注意，Node.js 一般会在启动时用&nbsp;<code>process.execPath</code>&nbsp;重写&nbsp;<code>argv[0]</code>，所以 Node.js 子进程中的&nbsp;<code>process.argv[0]</code>&nbsp;不会匹配从父进程传给&nbsp;<code>spawn</code>&nbsp;的&nbsp;<code>argv0</code>&nbsp;参数，可以使用&nbsp;<code>process.argv0</code>&nbsp;属性获取它。</p>

<h4>options.detached<a href="http://nodejs.cn/api/child_process.html#child_process_options_detached" id="child_process_options_detached">#</a></h4>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_options_detached">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/options_detached.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/options_detached.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p>新增于: v0.7.10</p>

<p>在 Windows 上，设置&nbsp;<code>options.detached</code>&nbsp;为&nbsp;<code>true</code>&nbsp;可以使子进程在父进程退出后继续运行。 子进程有自己的控制台窗口。 一旦启用一个子进程，它将不能被禁用。</p>

<p>在非 Windows 平台上，如果将&nbsp;<code>options.detached</code>&nbsp;设为&nbsp;<code>true</code>，则子进程会成为新的进程组和会话的领导者。 注意，子进程在父进程退出后可以继续运行，不管它们是否被分离。 详见&nbsp;<a href="http://man7.org/linux/man-pages/man2/setsid.2.html">setsid(2)</a>。</p>

<p>默认情况下，父进程会等待被分离的子进程退出。 为了防止父进程等待给定的&nbsp;<code>subprocess</code>，可以使用&nbsp;<code>subprocess.unref()</code>&nbsp;方法。 这样做会导致父进程的事件循环不包含子进程的引用计数，使得父进程独立于子进程退出，除非子进程和父进程之间建立了一个 IPC 信道。</p>

<p>当使用&nbsp;<code>detached</code>&nbsp;选项来启动一个长期运行的进程时，该进程不会在父进程退出后保持在后台运行，除非提供了一个不连接到父进程的&nbsp;<code>stdio</code>&nbsp;配置。 如果父进程的&nbsp;<code>stdio</code>&nbsp;是继承的，则子进程会保持连接到控制终端。</p>

<p>例子，一个长期运行的进程，为了忽视父进程的终止，通过分离且忽视其父进程的&nbsp;<code>stdio</code>&nbsp;文件描述符来实现：</p>

<pre>
<code>const { spawn } = require(&#39;child_process&#39;);

const subprocess = spawn(process.argv[0], [&#39;child_program.js&#39;], {
  detached: true,
  stdio: &#39;ignore&#39;
});

subprocess.unref();
</code></pre>

<p>也可以将子进程的输出重定向到文件：</p>

<pre>
<code>const fs = require(&#39;fs&#39;);
const { spawn } = require(&#39;child_process&#39;);
const out = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);
const err = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);

const subprocess = spawn(&#39;prg&#39;, [], {
  detached: true,
  stdio: [ &#39;ignore&#39;, out, err ]
});

subprocess.unref();
</code></pre>

<h4>options.stdio<a href="http://nodejs.cn/api/child_process.html#child_process_options_stdio" id="child_process_options_stdio">#</a></h4>

<p><a href="http://nodejs.cn/api/en/child_process.html#child_process_options_stdio">查看英文版</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-en/edit/master/child_process/options_stdio.md" rel="nofollow" target="_blank">查看英文md文件</a>&nbsp;/&nbsp;<a href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/options_stdio.md" rel="nofollow" target="_blank">编辑中文md文件</a></p>

<p>版本历史</p>

<p><code>options.stdio</code>&nbsp;选项用于配置子进程与父进程之间建立的管道。 默认情况下，子进程的 stdin、 stdout 和 stderr 会重定向到&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process"><code>ChildProcess</code></a>&nbsp;对象上相应的&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_stdin"><code>subprocess.stdin</code></a>、&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_stdout"><code>subprocess.stdout</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_stderr"><code>subprocess.stderr</code></a>&nbsp;流。 这等同于将&nbsp;<code>options.stdio</code>&nbsp;设为&nbsp;<code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>。</p>

<p>为了方便起见，<code>options.stdio</code>&nbsp;可以是以下字符串之一：</p>

<ul>
	<li><code>&#39;pipe&#39;</code>&nbsp;- 等同于&nbsp;<code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code>&nbsp;（默认）</li>
	<li><code>&#39;ignore&#39;</code>&nbsp;- 等同于&nbsp;<code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>
	<li><code>&#39;inherit&#39;</code>&nbsp;- 等同于&nbsp;<code>[process.stdin, process.stdout, process.stderr]</code>&nbsp;或&nbsp;<code>[0,1,2]</code></li>
</ul>

<p>另外，<code>option.stdio</code>&nbsp;的值是一个每个索引都对应一个子进程 fd 的数组。 fd 的 0、1 和 2 分别对应 stdin、stdout 和 stderr。 额外的 fd 可以被指定来创建父进程和子进程之间的额外管道。 该值是以下之一：</p>

<ol>
	<li><code>&#39;pipe&#39;</code>&nbsp;- 创建一个子进程和父进程之间的管道。 在管道的父端以&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><code>subprocess.stdio[fd]</code></a>&nbsp;的形式作为&nbsp;<code>child_process</code>&nbsp;对象的一个属性暴露给父进程。 为 fd 创建的管道 0 - 2 也可分别作为&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_stdin"><code>subprocess.stdin</code></a>、<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_stdout"><code>subprocess.stdout</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_stderr"><code>subprocess.stderr</code></a>。</li>
	<li><code>&#39;ipc&#39;</code>&nbsp;- 创建一个用于父进程和子进程之间传递消息或文件描述符的 IPC 通道符。 一个&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process"><code>ChildProcess</code></a>&nbsp;最多只能有一个 IPC stdio 文件描述符。 设置该选项可启用&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_subprocess_send_message_sendhandle_options_callback"><code>subprocess.send()</code></a>&nbsp;方法。 如果子进程把 JSON 消息写入到该文件描述符，则 [<code>subprocess.on(&#39;message&#39;)</code>] 事件句柄会被父进程触发。 如果子进程是一个 Node.js 进程，则一个已存在的 IPC 通道会在子进程中启用&nbsp;<a href="http://nodejs.cn/api/process.html#process_process_send_message_sendhandle_options_callback"><code>process.send()</code></a>、<a href="http://nodejs.cn/api/process.html#process_process_disconnect"><code>process.disconnect()</code></a>、<a href="http://nodejs.cn/api/process.html#process_event_disconnect"><code>process.on(&#39;disconnect&#39;)</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/process.html#process_event_message"><code>process.on(&#39;message&#39;)</code></a>。</li>
	<li><code>&#39;ignore&#39;</code>&nbsp;- 指示 Node.js 在子进程中忽略 fd。 由于 Node.js 总是会为它衍生的进程打开 fd 0 - 2，所以设置 fd 为&nbsp;<code>&#39;ignore&#39;</code>&nbsp;可以使 Node.js 打开&nbsp;<code>/dev/null</code>&nbsp;并将它附加到子进程的 fd 上。</li>
	<li><a href="http://nodejs.cn/api/stream.html#stream_stream">&lt;Stream&gt;</a>&nbsp;对象 - 共享一个指向子进程的 tty、文件、socket 或管道的可读或可写流。 流的底层文件描述符在子进程中是重复对应该&nbsp;<code>stdio</code>&nbsp;数组的索引的 fd。 注意，该流必须有一个底层描述符（文件流直到&nbsp;<code>&#39;open&#39;</code>&nbsp;事件发生才需要）。</li>
	<li>正整数 - 整数值被解析为一个正在父进程中打开的文件描述符。 它和子进程共享，类似于&nbsp;<a href="http://nodejs.cn/api/stream.html#stream_stream">&lt;Stream&gt;</a>&nbsp;是如何被共享的。</li>
	<li><code>null</code>,&nbsp;<code>undefined</code>&nbsp;- 使用默认值。 对于 stdio fd 0、1 和 2（换言之，stdin、stdout 和 stderr）而言是创建了一个管道。 对于 fd 3 及以上而言，默认值为&nbsp;<code>&#39;ignore&#39;</code>。</li>
</ol>

<p>例子：</p>

<pre>
<code>const { spawn } = require(&#39;child_process&#39;);

// 子进程使用父进程的 stdios
spawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });

// 衍生的子进程只共享 stderr
spawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });

// 打开一个额外的 fd=4，用于与程序交互
spawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] });
</code></pre>

<p>当在父进程和子进程之间建立了一个 IPC 通道，且子进程是一个 Node.js 进程，则子进程会带着未引用的 IPC 通道（使用&nbsp;<code>unref()</code>）启动，直到子进程为&nbsp;<a href="http://nodejs.cn/api/process.html#process_event_disconnect"><code>process.on(&#39;disconnect&#39;)</code></a>&nbsp;事件或&nbsp;<a href="http://nodejs.cn/api/process.html#process_event_message"><code>process.on(&#39;message&#39;)</code></a>&nbsp;事件注册了一个事件句柄。 这使得子进程可以在进程没有通过打开的 IPC 通道保持打开的情况下正常退出。</p>

<p>详见&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>&nbsp;和&nbsp;<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><code>child_process.fork()</code></a>。</p>
