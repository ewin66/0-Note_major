<h1>第三部分 虚拟机执行子系统</h1>

<p>第6章 类文件结构<br />
第7章 虚拟机类加载机制<br />
第8章 虚拟机字节码执行引擎<br />
第9章 类加载及执行子系统的案例与实战</p>

<p>第6章 类文件结构<br />
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言<br />
发展的一大步。<br />
6.1 概述<br />
记得在第一节计算机程序课上我的老师就讲过：“计算机只认识0和1，所以我们写的程<br />
序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行”。 10多年时间过去了，<br />
今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机以及大量建立在虚拟机之上的程<br />
序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native<br />
Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、<br />
平台中立的格式作为程序编译后的存储格式。<br />
6.2 无关性的基石<br />
如果计算机的CPU指令集只有x86一种，操作系统也只有Windows一种，那也许Java语言<br />
就不会出现。 Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处<br />
运行（Write Once,Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴<br />
求。 在无时无刻不充满竞争的IT领域，不可能只有Wintel[1]存在，我们也不希望只有Wintel存<br />
在，各种不同的硬件体系结构和不同的操作系统肯定会长期并存发展。 “与平台无关”的理想<br />
最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各<br />
种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现<br />
了程序的“一次编写，到处运行”。<br />
各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）<br />
是构成平台无关性的基石，但本节标题中刻意省略了“平台”二字，那是因为笔者注意到虚拟<br />
机的另外一种中立特性——语言无关性正越来越被开发者所重视。 到目前为止，或许大部分<br />
程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。 但在Java发展<br />
之初，设计者就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发<br />
布规范文档的时候，也刻意把Java的规范拆分成了Java语言规范《 The Java Language<br />
Specification》 及Java虚拟机规范《 The Java Virtual Machine Specification》 。 并且在1997年发<br />
布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions<br />
to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java<br />
虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上），当Java虚拟机发展到<br />
JDK 1.7～1.8的时候，JVM设计者通过JSR-292基本兑现了这个承诺。<br />
时至今日，商业机构和开源机构已经在Java语言之外发展出一大批在Java虚拟机之上运<br />
行的语言，如Clojure、 Groovy、 JRuby、 Jython、 Scala等。 使用过这些语言的开发者可能还不<br />
是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后Java虚拟机在语<br />
言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？<br />
实现语言无关性的基础仍然是虚拟机和字节码存储格式。 Java虚拟机不和包括Java在内<br />
的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含<br />
了Java虚拟机指令集和符号表以及若干其他辅助信息。 基于安全方面的考虑，Java虚拟机规<br />
范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示<br />
为一个能被Java虚拟机所接受的有效的Class文件。 作为一个通用的、 机器无关的执行平台，<br />
任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。 例如，使用Java编译<br />
器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以<br />
把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如图6-1所示。<br />
图 6-1 Java虚拟机提供的语言无关性<br />
Java语言中的各种变量、 关键字和运算符号的语义最终都是由多条字节码命令组合而成<br />
的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。 因此，有一<br />
些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言<br />
实现一些有别于Java的语言特性提供了基础。<br />
[1]Wintel：微软公司的Windows与Intel公司的芯片相结合，曾经是业界最强大的联盟。<br />
6.3 Class类文件的结构<br />
解析Class文件的数据结构是本章的最主要内容。 笔者曾经在前言中阐述过本书的写作风<br />
格：力求在保证逻辑准确的前提下，用尽量通俗的语言和案例去讲述虚拟机中与开发关系最<br />
为密切的内容。 但是，对数据结构方面的讲解不可避免地会比较枯燥，而这部分内容又是了<br />
解虚拟机的重要基础之一。 如果想比较深入地了解虚拟机，那么这部分是不能不接触的。<br />
在本章关于Class文件结构的讲解中，我们将以《 Java虚拟机规范（第2版）》 （1999年<br />
发布，对应于JDK 1.4时代的Java虚拟机）中的定义为主线，这部分内容虽然古老，但它所包<br />
含的指令、 属性是Class文件中最重要和最基础的。 同时，我们也会以后续JDK 1.5～JDK 1.7<br />
中添加的内容为支线进行较为简略的、 介绍性的讲解，如果读者对这部分内容特别感兴趣，<br />
建议参考笔者所翻译的《 Java虚拟机规范（Java SE 7）》 中文版，可以在笔者的网站<br />
（http://icyfenix.iteye.com/）上下载到这本书的全文PDF。<br />
注意 任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接<br />
口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。 本章中，笔<br />
者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它<br />
并不一定以磁盘文件的形式存在。<br />
Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地<br />
排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎<br />
全部是程序运行的必要数据，没有空隙存在。 当遇到需要占用8位字节以上空间的数据项<br />
时，则会按照高位在前[1]的方式分割成若干个8位字节进行存储。<br />
根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存<br />
储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类<br />
型为基础，所以这里要先介绍这两个概念。<br />
无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个<br />
字节和8个字节的无符号数，无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8<br />
编码构成字符串值。<br />
表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地<br />
以“_info”结尾。 表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张<br />
表，它由表6-1所示的数据项构成。<br />
无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一<br />
个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据<br />
为某一类型的集合。<br />
本节结束之前，笔者需要再重复讲一下，Class的结构不像XML等描述语言，由于它没<br />
有任何分隔符号，所以在表6-1中的数据项，无论是顺序还是数量，甚至于数据存储的字节<br />
序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个<br />
字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。 接下来我们将一起看看这<br />
个表中各个数据项的具体含义。<br />
6.3.1 魔数与Class文件的版本<br />
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件<br />
是否为一个能被虚拟机接受的Class文件。 很多文件存储标准中都使用魔数来进行身份识别，<br />
譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。 使用魔数而不是扩展名来进行识别<br />
主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。 文件格式的制定者可以自由<br />
地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。 Class文件的<br />
魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在Java还称<br />
做“Oak”语言的时候（大约是1991年前后）就已经确定下来了。 它还有一段很有趣的历史，<br />
据Java开发小组最初的关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的、 容易记<br />
忆的东西，选择0xCAFEBABE是因为它象征着著名咖啡品牌Peet’s Coffee中深受欢迎的<br />
Baristas咖啡”，这个魔数似乎也预示着日后“Java”这个商标名称的出现。<br />
紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor<br />
Version），第7和第8个字节是主版本号（Major Version）。 Java的版本号是从45开始<br />
的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的<br />
版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文<br />
件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。<br />
例如，JDK 1.1能支持版本号为45.0～45.65535的Class文件，无法执行版本号为46.0以上<br />
的Class文件，而JDK 1.2则能支持45.0～46.65535的Class文件。 现在，最新的JDK版本为<br />
1.7，可生成的Class文件主版本号最大值为51.0。<br />
为了讲解方便，笔者准备了一段最简单的Java代码（见代码清单6-1），本章后面的内容<br />
都将以这段小程序使用JDK 1.6编译输出的Class文件为基础来进行讲解。<br />
代码清单6-1 简单的Java代码<br />
package org.fenixsoft.clazz；<br />
public class TestClass{<br />
private int m；<br />
public int inc（）{<br />
return m+1；<br />
}} 图<br />
6-2显示的是使用十六进制编辑器WinHex打开这个Class文件的结果，可以清楚地看见<br />
开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为<br />
0x0000，而主版本号的值为0x0032，也即是十进制的50，该版本号说明这个文件是可以被<br />
JDK 1.6或以上版本虚拟机执行的Class文件。<br />
图 6-2 Java Class文件的结构<br />
表6-2列出了从JDK 1.1到JDK 1.7，主流JDK版本编译器输出的默认和可支持的Class文件<br />
版本号。<br />
[1]这种顺序称为“Big-Endian”，具体是指最高位字节在地址最低位、 最低位字节在地址最高<br />
位的顺序来存储数据，它是SPARC、 PowerPC等处理器的默认多字节存储顺序，而x86等处<br />
理器则是使用了相反的“Little-Endian”顺序来存储数据。<br />
6.3.2 常量池<br />
紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，<br />
它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据<br />
项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。<br />
由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数<br />
据，代表常量池容量计数值（constant_pool_count）。 与Java中语言习惯不一样的是，这个容<br />
量计数是从1而不是0开始的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六<br />
进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。 在<br />
Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在<br />
于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池<br />
项目”的含义，这种情况就可以把索引值置为0来表示。 Class文件结构中只有常量池的容量计<br />
数是从1开始，对于其他集合类型，包括接口索引集合、 字段表集合、 方法表集合等的容量<br />
计数都与一般习惯相同，是从0开始的。<br />
图 6-3 常量池结构<br />
常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。<br />
字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。 而符<br />
号引用则属于编译原理方面的概念，包括了下面三类常量：<br />
类和接口的全限定名（Fully Qualified Name）<br />
字段的名称和描述符（Descriptor）<br />
方法的名称和描述符<br />
Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟<br />
机加载Class文件的时候进行动态连接。 也就是说，在Class文件中不会保存各个方法、 字段<br />
的最终内存布局信息，因此这些字段、 方法的符号引用不经过运行期转换的话无法得到真正<br />
的内存入口地址，也就无法直接被虚拟机使用。 当虚拟机运行时，需要从常量池获得对应的<br />
符号引用，再在类创建时或运行时解析、 翻译到具体的内存地址之中。 关于类的创建和动态<br />
连接的内容，在下一章介绍虚拟机类加载过程时再进行详细讲解。<br />
常量池中每一项常量都是一个表，在JDK 1.7之前共有11种结构各不相同的表结构数<br />
据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种<br />
（CONSTANT_MethodHandle_info、 CONSTANT_MethodType_info和<br />
CONSTANT_InvokeDynamic_info，本章不会涉及这3种新增的类型，在第8章介绍字节码执行<br />
和方法调用时，将会详细讲解）。<br />
这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag，取值<br />
见表6-3中标志列），代表当前这个常量属于哪种常量类型。 这14种常量类型所代表的具体<br />
含义见表6-3。<br />
之所以说常量池是最烦琐的数据，是因为这14种常量类型各自均有自己的结构。 回头看<br />
看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的<br />
标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的<br />
符号引用。 CONSTANT_Class_info的结构比较简单，见表6-4。<br />
tag是标志位，上面已经讲过了，它用于区分常量类型；name_index是一个索引值，它指<br />
向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限<br />
定名，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第<br />
二项常量。 继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查<br />
表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。 CONSTANT_Utf8_info类型的结构<br />
见表6-5。<br />
length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length<br />
字节的连续数据是一个使用UTF-8缩略编码表示的字符串。 UTF-8缩略编码与普通UTF-8编码<br />
的区别是：从'\u0001'到'\u007f'之间的字符（相当于1～127的ASCII码）的缩略编码使用一个<br />
字节表示，从'\u0080'到'\u07ff'之间的所有字符的缩略编码用两个字节表示，<br />
从'\u0800'到'\uffff'之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。<br />
顺便提一下，由于Class文件中方法、 字段等都需要引用CONSTANT_Utf8_info型常量来<br />
描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、 字段名的最大<br />
长度。 而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。 所以Java程<br />
序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。<br />
本例中这个字符串的length值（偏移地址：0x0000000E）为0x001D，也就是长29字节，<br />
往后29字节正好都在1～127的ASCII码范围以内，内容为“org/fenixsoft/clazz/TestClass”，有兴<br />
趣的读者可以自己逐个字节换算一下，换算结果如图6-4选中的部分所示。<br />
图 6-4 常量池UTF-8字符串结构<br />
到此为止，我们分析了TestClass.class常量池中21个常量中的两个，其余的19个常量都可<br />
以通过类似的方法计算出来。 为了避免计算过程占用过多的版面，后续的19个常量的计算过<br />
程可以借助计算机来帮我们完成。 在JDK的bin目录中，Oracle公司已经为我们准备好一个专<br />
门用于分析Class文件字节码的工具：javap，代码清单6-2中列出了使用javap工具的-verbose<br />
参数输出的TestClass.class文件字节码内容（此清单中省略了常量池以外的信息）。 前面我们<br />
曾经提到过，Class文件中还有很多数据项都要引用常量池中的常量，所以代码清单6-2中的<br />
内容在后续的讲解过程中还要经常使用到。<br />
代码清单6-2 使用Javap命令输出常量表<br />
C：\＞javap-verbose TestClass<br />
Compiled from"TestClass.java"<br />
public class org.fenixsoft.clazz.TestClass extends java.lang.Object<br />
SourceFile："TestClass.java"<br />
minor version：0<br />
major version：50<br />
Constant pool：<br />
const#1=class#2；//org/fenixsoft/clazz/TestClass<br />
const#2=Asciz org/fenixsoft/clazz/TestClass；<br />
const#3=class#4；//java/lang/Object<br />
const#4=Asciz java/lang/Object；<br />
const#5=Asciz m；<br />
const#6=Asciz I；<br />
const#7=Asciz＜init＞；<br />
const#8=Asciz（）V；<br />
const#9=Asciz Code；<br />
const#10=Method#3.#11；//java/lang/Object."＜init＞"：（）V<br />
const#11=NameAndType#7：#8；//"＜init＞"：（）V<br />
const#12=Asciz LineNumberTable；<br />
const#13=Asciz LocalVariableTable；<br />
const#14=Asciz this；<br />
const#15=Asciz Lorg/fenixsoft/clazz/TestClass；<br />
const#16=Asciz inc；<br />
const#17=Asciz（）I；<br />
const#18=Field#1.#19；//org/fenixsoft/clazz/TestClass.m：I<br />
const#19=NameAndType#5：#6；//m：I<br />
const#20=Asciz SourceFile；<br />
const#21=Asciz TestClass.java；<br />
从代码清单6-2中可以看出，计算机已经帮我们把整个常量池的21项常量都计算了出<br />
来，并且第1、 2项常量的计算结果与我们手工计算的结果一致。 仔细看一下会发现，其中有<br />
一些常量似乎从来没有在代码中出现过，如“I”、 “V”、 “＜init＞”、 “LineNumberTable”、<br />
“LocalVariableTable”等，这些看起来在代码任何一处都没有出现过的常量是哪里来的呢？<br />
这部分自动生成的常量的确没有在Java代码里面直接出现过，但它们会被后面即将讲到<br />
的字段表（field_info）、 方法表（method_info）、 属性表（attribute_info）引用到，它们会用<br />
来描述一些不方便使用“固定字节”进行表达的内容。 譬如描述方法的返回值是什么？有几个<br />
参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字<br />
节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号<br />
引用进行表达。 这部分内容将在后面进一步阐述。 最后，笔者将这14种常量项的结构定义总<br />
结为表6-6以供读者参考。</p>

<p><br />
6.3.3 访问标志<br />
在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识<br />
别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类<br />
型；是否定义为abstract类型；如果是类的话，是否被声明为final等。 具体的标志位以及标志<br />
的含义见表6-7。<br />
access_flags中一共有16个标志位可以使用，当前只定义了其中8个[1]，没有使用到的标志<br />
位要求一律为0。 以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、 枚<br />
举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后<br />
的编译器进行编译，因此它的ACC_PUBLIC、 ACC_SUPER标志应当为真，而ACC_FINAL、<br />
ACC_INTERFACE、 ACC_ABSTRACT、 ACC_SYNTHETIC、 ACC_ANNOTATION、<br />
ACC_ENUM这6个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。<br />
从图6-5中可以看出，access_flags标志（偏移地址：0x000000EF）的确为0x0021。<br />
图 6-5 access_flags标志<br />
[1]在Java虚拟机规范中，只定义了开头5种标志。 JDK 1.5中增加了后面3种。 这些标志为在<br />
JSR-202规范中声明，是对《 Java虚拟机规范（第2版）》 的补充。 本书介绍的访问标志以<br />
JSR-202规范为准。<br />
6.3.4 类索引、 父类索引与接口索引集合<br />
类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集<br />
合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承<br />
关系。 类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 由<br />
于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java<br />
类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。 接口索引集合就<br />
用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身<br />
是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。<br />
类索引、 父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用<br />
两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常<br />
量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在<br />
CONSTANT_Utf8_info类型的常量中的全限定名字符串。 图6-6演示了代码清单6-1的代码的类<br />
索引查找过程。<br />
对于接口索引集合，入口的第一项——u2类型的数据为接口计数器<br />
（interfaces_count），表示索引表的容量。 如果该类没有实现任何接口，则该计数器值为0，<br />
后面接口的索引表不再占用任何字节。 代码清单6-1中的代码的类索引、 父类索引与接口表<br />
索引的内容如图6-7所示。<br />
图 6-6 类索引查找全限定名的过程<br />
图 6-7 类索引、 父类索引、 接口索引集合<br />
从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、 0x0003、 0x0000，也就是<br />
类索引为1，父类索引为3，接口索引集合大小为0，查询前面代码清单6-2中javap命令计算出<br />
来的常量池，找出对应的类和父类的常量，结果如代码清单6-3所示。<br />
代码清单6-3 部分常量池内容<br />
const#1=class#2；//org/fenixsoft/clazz/TestClass<br />
const#2=Asciz org/fenixsoft/clazz/TestClass；<br />
const#3=class#4；//java/lang/Object<br />
const#4=Asciz java/lang/Object；<br />
6.3.5 字段表集合<br />
字段表（field_info）用于描述接口或者类中声明的变量。 字段（field）包括类级变量以<br />
及实例级变量，但不包括在方法内部声明的局部变量。 我们可以想一想在Java中描述一个字<br />
段可以包含什么信息？可以包括的信息有：字段的作用域（public、 private、 protected修饰<br />
符）、 是实例变量还是类变量（static修饰符）、 可变性（final）、 并发可见性（volatile修饰<br />
符，是否强制从主内存读写）、 可否被序列化（transient修饰符）、 字段数据类型（基本类<br />
型、 对象、 数组）、 字段名称。 上述这些信息中，各个修饰符都是布尔值，要么有某个修饰<br />
符，要么没有，很适合使用标志位来表示。 而字段叫什么名字、 字段被定义为什么数据类<br />
型，这些都是无法固定的，只能引用常量池中的常量来描述。 表6-8中列出了字段表的最终<br />
格式。<br />
字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一<br />
个u2的数据类型，其中可以设置的标志位和含义见表6-9。<br />
很明显，在实际情况中，ACC_PUBLIC、 ACC_PRIVATE、 ACC_PROTECTED三个标志<br />
最多只能选择其一，ACC_FINAL、 ACC_VOLATILE不能同时选择。 接口之中的字段必须有<br />
ACC_PUBLIC、 ACC_STATIC、 ACC_FINAL标志，这些都是由Java本身的语言规则所决定<br />
的。<br />
跟随access_flags标志的是两项索引值：name_index和descriptor_index。 它们都是对常量<br />
池的引用，分别代表着字段的简单名称以及字段和方法的描述符。 现在需要解释一下“简单<br />
名称”、 “描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念。<br />
全限定名和简单名称很好理解，以代码清单6-1中的代码为<br />
例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成<br />
了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一<br />
个“；”表示全限定名结束。 简单名称是指没有类型和参数修饰的方法或者字段名称，这个类<br />
中的inc（）方法和m字段的简单名称分别是“inc”和“m”。<br />
相对于全限定名和简单名称来说，方法和字段的描述符就要复杂一些。 描述符的作用是<br />
用来描述字段的数据类型、 方法的参数列表（包括数量、 类型以及顺序）和返回值。 根据描<br />
述符规则，基本数据类型（byte、 char、 double、 float、 int、 long、 short、 boolean）以及代表<br />
无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来<br />
表示，详见表6-10。<br />
[1]<br />
对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义<br />
为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String；”，一个整型数<br />
组“int[]”将被记录为“[I”。<br />
用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的<br />
严格顺序放在一组小括号“（）”之内。 如方法void inc（）的描述符为“（）V”，方法<br />
java.lang.String toString（）的描述符为“（）Ljava/lang/String；”，方法int<br />
indexOf（char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int<br />
targetCount,int fromIndex）的描述符为“（[CII[CIII）I”。<br />
对于代码清单6-1中的TestClass.class文件来说，字段表集合从地址0x000000F8开始，第<br />
一个u2类型的数据为容量计数器fields_count，如图6-8所示，其值为0x0001，说明这个类只有<br />
一个字段表数据。 接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private<br />
修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为<br />
假。 代表字段名称的name_index的值为0x0005，从代码清单6-2列出的常量表中可查得第5项<br />
常量是一个CONSTANT_Utf8_info类型的字符串，其值为“m”，代表字段描述符的<br />
descriptor_index的值为0x0006，指向常量池的字符串“I”，根据这些信息，我们可以推断出原<br />
代码定义的字段为：“private int m；”。<br />
字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index<br />
之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项<br />
的额外信息。 对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信<br />
息，但是，如果将字段m的声明改为“final static int m=123；”，那就可能会存在一项名称为<br />
ConstantValue的属性，其值指向常量123。 关于attribute_info的其他内容，将在6.3.7节介绍属<br />
性表的数据项目时再进一步讲解。<br />
图 6-8 字段表结构实例<br />
字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代<br />
码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类<br />
实例的字段。 另外，在Java语言中字段是无法重载的，两个字段的数据类型、 修饰符不管是<br />
否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，<br />
那字段重名就是合法的。<br />
[1]void类型在虚拟机规范之中单独列出为“VoidDescriptor”，笔者为了结构统一，将其列在基<br />
本数据类型中一起描述。<br />
6.3.6 方法表集合<br />
如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。 Class<br />
文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如<br />
同字段表一样，依次包括了访问标志（access_flags）、 名称索引（name_index）、 描述符索<br />
引（descriptor_index）、 属性表集合（attributes）几项，见表6-11。 这些数据项目的含义也非<br />
常类似，仅在访问标志和属性表集合的可选项中有所区别。<br />
因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了<br />
ACC_VOLATILE标志和ACC_TRANSIENT标志。 与之相对的，synchronized、 native、 strictfp<br />
和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、<br />
ACC_NATIVE、 ACC_STRICTFP和ACC_ABSTRACT标志。 对于方法表，所有标志位及其取<br />
值可参见表6-12。<br />
行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志、 名称索引、 描述<br />
符索引表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过编译器编译成字节<br />
码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式<br />
中最具扩展性的一种数据项目，将在6.3.7节中详细讲解。<br />
我们继续以代码清单6-1中的Class文件为例对方法表集合进行分析，如图6-9所示，方法<br />
表集合的入口地址为：0x00000101，第一个u2类型的数据（即是计数器容量）的值为<br />
0x0002，代表集合中有两个方法（这两个方法为编译器添加的实例构造器＜init＞和源码中<br />
的方法inc（））。 第一个方法的访问标志值为0x001，也就是只有ACC_PUBLIC标志为真，<br />
名称索引值为0x0007，查代码清单6-2的常量池得方法名为“＜init＞”，描述符索引值为<br />
0x0008，对应常量为“（）V”，属性表计数器attributes_count的值为0x0001就表示此方法的属<br />
性表集合有一项属性，属性名称索引为0x0009，对应常量为“Code”，说明此属性是方法的字<br />
节码描述。<br />
图 6-9 方法表结构实例<br />
与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合<br />
中就不会出现来自父类的方法信息。 但同样的，有可能会出现由编译器自动添加的方法，最<br />
典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”[1]方法。<br />
在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之<br />
外，还要求必须拥有一个与原方法不同的特征签名[2]，特征签名就是一个方法中各个参数在<br />
常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言<br />
里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。 但是在Class文件格式中，<br />
特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。 也就是说，如<br />
果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class<br />
文件中的。<br />
[1]＜init＞和＜clinit＞的详细内容见本书的第10章。<br />
[2]在《 Java虚拟机规范（第2版）》 的“§4.4.4 Signatures”章节及《 Java语言规范（第3版）》<br />
的“§8.4.2 Method Signature”章节中都分别定义了字节码层面的方法特征签名以及Java代码层<br />
面的方法特征签名，Java代码的方法特征签名只包括了方法名称、 参数顺序及参数类型，而<br />
字节码的特征签名还包括方法返回值以及受查异常表，请读者根据上下文语境注意区分。<br />
6.3.7 属性表集合<br />
属性表（attribute_info）在前面的讲解之中已经出现过数次，在Class文件、 字段表、 方<br />
法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。<br />
与Class文件中其他的数据项目要求严格的顺序、 长度和内容不同，属性表集合的限制稍<br />
微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人<br />
实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不<br />
认识的属性。 为了能正确解析Class文件，《 Java虚拟机规范（第2版）》 中预定义了9项虚拟<br />
机实现应当能识别的属性，而在最新的《 Java虚拟机规范（Java SE 7）》 版中，预定义属性<br />
已经增加到21项，具体内容见表6-13。 下文中将对其中一些属性中的关键常用的部分进行讲<br />
解。</p>

<p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来<br />
表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占<br />
用的位数即可。 一个符合规则的属性表应该满足表6-14中所定义的结构。<br />
1.Code属性<br />
Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性<br />
内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬<br />
如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构<br />
将如表6-15所示。<br />
attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定<br />
为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称<br />
索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。<br />
max_stack代表了操作数栈（Operand Stacks）深度的最大值。 在方法执行的任意时刻，<br />
操作数栈都不会超过这个深度。 虚拟机运行的时候需要根据这个值来分配栈帧（Stack<br />
Frame）中的操作栈深度。<br />
max_locals代表了局部变量表所需的存储空间。 在这里，max_locals的单位是Slot,Slot是<br />
虚拟机为局部变量分配内存所使用的最小单位。 对于byte、 char、 float、 int、 short、 boolean<br />
和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这<br />
两种64位的数据类型则需要两个Slot来存放。 方法参数（包括实例方法中的隐藏参<br />
数“this”）、 显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch<br />
块所定义的异常）、 方法体中定义的局部变量都需要使用局部变量表来存放。 另外，并不是<br />
在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因<br />
是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量<br />
所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个<br />
变量使用，然后计算出max_locals的大小。<br />
code_length和code用来存储Java源程序编译后生成的字节码指令。 code_length代表字节码<br />
长度，code是用于存储字节码指令的一系列字节流。 既然叫字节码指令，那么每个指令就是<br />
一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码<br />
代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理<br />
解。 我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共<br />
可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含<br />
义，编码与指令之间的对应关系可查阅本书的附录B“虚拟机字节码指令表”。<br />
关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大<br />
值可以达到232-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，<br />
即它实际只使用了u2的长度，如果超过这个限制，Javac编译器也会拒绝编译。 一般来讲，编<br />
写Java代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大<br />
值的限制。 但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把<br />
JSP内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而<br />
导致编译失败。<br />
Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码<br />
（Code，方法体里面的Java代码）和元数据（Metadata，包括类、 字段、 方法定义及其他信<br />
息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用<br />
于描述元数据。 了解Code属性是学习后面关于字节码执行引擎内容的必要基础，能直接阅读<br />
字节码也是工作中分析Java代码语义问题的必要工具和基本技能，因此笔者准备了一个比较<br />
详细的实例来讲解虚拟机是如何使用这个属性的。<br />
继续以代码清单6-1的TestClass.class文件为例，如图6-10所示，这是上一节分析过的实<br />
例构造器“＜init＞”方法的Code属性。 它的操作数栈的最大深度和本地变量表的容量都为<br />
0x0001，字节码区域所占空间的长度为0x0005。 虚拟机读取到字节码区域的长度后，按照顺<br />
序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。 翻译“2A B7<br />
00 0A B1”的过程为：<br />
1）读入2A，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为<br />
reference类型的本地变量推送到操作数栈顶。<br />
2）读入B7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的<br />
reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、 private<br />
方法或者它的父类的方法。 这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向<br />
常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。<br />
3）读入00 0A，这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造<br />
器“＜init＞”方法的符号引用。<br />
4）读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。<br />
这条指令执行后，当前方法结束。<br />
图 6-10 Code属性结构实例<br />
这段字节码虽然很短，但是至少可以看出它的执行过程中的数据交换、 方法调用等操作<br />
都是基于栈（操作栈）的。 我们可以初步猜测：Java虚拟机执行字节码是基于栈的体系结<br />
构。 但是与一般基于堆栈的零字节指令又不太一样，某些指令（如invokespecial）后面还会<br />
带有参数，关于虚拟机字节码执行的讲解是后面两章的重点，我们不妨把这里的疑问放到第<br />
8章去解决。<br />
我们再次使用javap命令把此Class文件中的另外一个方法的字节码指令也计算出来，结<br />
果如代码清单6-4所示。<br />
代码清单6-4 用javap命令计算字节码指令<br />
//原始Java代码<br />
public class TestClass{<br />
private int m；<br />
public int inc（）{<br />
return m+1；<br />
}}C<br />
：\＞javap-verbose TestClass<br />
//常量表部分的输出见代码清单6-1，因版面原因这里省略掉<br />
{p<br />
ublic org.fenixsoft.clazz.TestClass（）；<br />
Code：<br />
Stack=1，Locals=1，Args_size=1<br />
0：aload_0<br />
1：invokespecial#10；//Method java/lang/Object."＜init＞"：（）V<br />
4：return<br />
LineNumberTable：<br />
line 3：0<br />
LocalVariableTable：<br />
Start Length Slot Name Signature<br />
0 5 0 this Lorg/fenixsoft/clazz/TestClass；<br />
public int inc（）；<br />
Code：<br />
Stack=2，Locals=1，Args_size=1<br />
0：aload_0<br />
1：getfield#18；//Field m：I<br />
4：iconst_1<br />
5：iadd<br />
6：ireturn<br />
LineNumberTable：<br />
line 8：0<br />
LocalVariableTable：<br />
Start Length Slot Name Signature<br />
0 7 0 this Lorg/fenixsoft/clazz/TestClass；<br />
} 如<br />
果大家注意到javap中输出的“Args_size”的值，可能会有疑问：这个类有两个方法——<br />
实例构造器＜init＞（）和inc（），这两个方法很明显都是没有参数的，为什么Args_size会<br />
为1？而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么<br />
会等于1？如果有这样的疑问，大家可能是忽略了一点：在任何实例方法里面，都可以通<br />
过“this”关键字访问到此方法所属的对象。 这个访问机制对Java程序的编写很重要，而它的实<br />
现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通<br />
方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。 因此在实例方法的局<br />
部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个<br />
Slot位来存放对象实例的引用，方法参数值从1开始计算。 这个处理只对实例方法有效，如果<br />
代码清单6-1中的inc（）方法声明为static，那Args_size就不会等于1而是等于0了。<br />
在字节码指令之后的是这个方法的显式异常处理表（下文简称异常表）集合，异常表对<br />
于Code属性来说并不是必须存在的，如代码清单6-4中就没有异常表生成。<br />
异常表的格式如表6-16所示，它包含4个字段，这些字段的含义为：如果当字节码在第<br />
start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常<br />
（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续<br />
处理。 当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。<br />
异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现<br />
Java异常及finally处理机制[2]。<br />
代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了在字节码层面中<br />
try-catch-finally是如何实现的。 在阅读字节码之前，大家不妨先看看下面的Java源码，想一下<br />
这段代码的返回值在出现异常和不出现异常的情况下分别应该是多少？<br />
代码清单6-5 异常表运作演示<br />
//Java源码<br />
public int inc（）{<br />
int x；<br />
try{<br />
x=1；<br />
return x；<br />
}catch（Exception e）{<br />
x=2；<br />
return x；<br />
}finally{<br />
x=3；<br />
}}/<br />
/编译后的ByteCode字节码及异常表<br />
public int inc（）；<br />
Code：<br />
Stack=1，Locals=5，Args_size=1<br />
0：iconst_1//try块中的x=1<br />
1：istore_1<br />
2：iload_1//保存x到returnValue中，此时x=1<br />
3：istore 4<br />
5：iconst_3//finaly块中的x=3<br />
6：istore_1<br />
7：iload 4//将returnValue中的值放到栈顶，准备给ireturn返回<br />
9：ireturn<br />
10：astore_2//给catch中定义的Exception e赋值，存储在Slot 2中<br />
11：iconst_2//catch块中的x=2<br />
12：istore_1<br />
13：iload_1//保存x到returnValue中，此时x=2<br />
14：istore 4<br />
16：iconst_3//finaly块中的x=3<br />
17：istore_1<br />
18：iload 4//将returnValue中的值放到栈顶，准备给ireturn返回<br />
20：ireturn<br />
21：astore_3//如果出现了不属于java.lang.Exception及其子类的异常才会走到这里<br />
22：iconst_3//finaly块中的x=3<br />
23：istore_1<br />
24：aload_3//将异常放置到栈顶，并抛出<br />
25：athrow<br />
Exception table：<br />
from to target type<br />
0 5 10 Class java/lang/Exception<br />
0 5 21 any<br />
10 16 21 any<br />
编译器为这段Java源码生成了3条异常表记录，对应3条可能出现的代码执行路径。 从<br />
Java代码的语义上讲，这3条执行路径分别为：<br />
如果try语句块中出现属于Exception或其子类的异常，则转到catch语句块处理。<br />
如果try语句块中出现不属于Exception或其子类的异常，则转到finally语句块处理。<br />
如果catch语句块中出现任何异常，则转到finally语句块处理。<br />
返回到我们上面提出的问题，这段代码的返回值应该是多少？对Java语言熟悉的读者应<br />
该很容易说出答案：如果没有出现异常，返回值是1；如果出现了Exception异常，返回值是<br />
2；如果出现了Exception以外的异常，方法非正常退出，没有返回值。 我们一起来分析一下<br />
字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。<br />
字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副<br />
本到最后一个本地变量表的Slot中（这个Slot里面的值在ireturn指令执行前将会被重新读到操<br />
作栈顶，作为方法返回值使用。 为了讲解方便，笔者给这个Slot起了个名字：returnValue）。<br />
如果这时没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后将之前保存在<br />
returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方<br />
法结束。 如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是将2赋值给<br />
变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。 方法返回前同样<br />
将returnValue中保留的整数2读到了操作栈顶。 从第21行开始的代码，作用是变量x的值赋为<br />
3，并将栈顶的异常抛出，方法结束。<br />
尽管大家都知道这段代码出现异常的概率非常小，但并不影响它为我们演示异常表的作<br />
用。 如果大家到这里仍然对字节码的运作过程比较模糊，其实也不要紧，关于虚拟机执行字<br />
节码的过程，本书第8章中将会有更详细的讲解。<br />
2.Exceptions属性<br />
这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚<br />
讲解完的异常表产生混淆。 Exceptions属性的作用是列举出方法中可能抛出的受查异常<br />
（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。 它的结构见表<br />
6-17。<br />
Exceptions属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查<br />
异常，每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指<br />
向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。<br />
3.LineNumberTable属性<br />
LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对<br />
应关系。 它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别<br />
使用-g：none或-g：lines选项来取消或要求生成这项信息。 如果选择不生成LineNumberTable<br />
属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，<br />
并且在调试程序的时候，也无法按照源码行来设置断点。 LineNumberTable属性的结构见表6-<br />
18。<br />
line_number_table是一个数量为line_number_table_length、 类型为line_number_info的集<br />
合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行<br />
号，后者是Java源码行号。<br />
4.LocalVariableTable属性<br />
LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之<br />
间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分<br />
别使用-g：none或-g：vars选项来取消或要求生成这项信息。 如果没有生成这项属性，最大的<br />
影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、<br />
arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大<br />
不便，而且在调试期间无法根据参数名称从上下文中获得参数值。 LocalVariableTable属性的<br />
结构见表6-19。<br />
其中，local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构见表6-<br />
20。<br />
start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用<br />
范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。<br />
name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分<br />
别代表了局部变量的名称以及这个局部变量的描述符。<br />
index是这个局部变量在栈帧局部变量表中Slot的位置。 当这个变量数据类型是64位类型<br />
时（double和long），它占用的Slot为index和index+1两个。<br />
顺便提一下，在JDK 1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：<br />
LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录<br />
的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来<br />
说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入之后，由于描述符中泛型<br />
的参数化类型被擦除掉[3]，描述符就不能准确地描述泛型类型了，因此出现了<br />
LocalVariableTypeTable。<br />
5.SourceFile属性<br />
SourceFile属性用于记录生成这个Class文件的源码文件名称。 这个属性也是可选的，可<br />
以分别使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。 在Java中，对于大<br />
多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。 如果不生<br />
成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。 这个属性是一个定<br />
长的属性，其结构见表6-21。<br />
sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源<br />
码文件的文件名。<br />
6.ConstantValue属性<br />
ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。 只有被static关键字修饰的<br />
变量（类变量）才可以使用这项属性。 类似“int x=123”和“static int x=123”这样的变量定义在<br />
Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。 对于<br />
非static类型的变量（也就是实例变量）的赋值是在实例构造器＜init＞方法中进行的；而对<br />
于类变量，则有两种方式可以选择：在类构造器＜clinit＞方法中或者使用ConstantValue属<br />
性。 目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，<br />
这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生<br />
成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字<br />
符串，则将会选择在＜clinit＞方法中进行初始化。<br />
虽然有final关键字才更符合“ConstantValue”的语义，但虚拟机规范中并没有强制要求字<br />
段必须设置了ACC_FINAL标志，只要求了有ConstantValue属性的字段必须设置ACC_STATIC<br />
标志而已，对final关键字的要求是Javac编译器自己加入的限制。 而对ConstantValue的属性值<br />
只能限于基本类型和String，不过笔者不认为这是什么限制，因为此属性的属性值只是一个<br />
常量池的索引号，由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面<br />
量，所以就算ConstantValue属性想支持别的类型也无能为力。 ConstantValue属性的结构见表<br />
6-22。<br />
从数据结构中可以看出，ConstantValue属性是一个定长属性，它的attribute_length数据项<br />
值必须固定为2。 constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字<br />
段类型的不同，字面量可以是CONSTANT_Long_info、 CONSTANT_Float_info、<br />
CONSTANT_Double_info、 CONSTANT_Integer_info、 CONSTANT_String_info常量中的一种。<br />
7.InnerClasses属性<br />
InnerClasses属性用于记录内部类与宿主类之间的关联。 如果一个类中定义了内部类，那<br />
编译器将会为它以及它所包含的内部类生成InnerClasses属性。 该属性的结构见表6-23。<br />
数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一<br />
个inner_classes_info表进行描述。 inner_classes_info表的结构见表6-24。<br />
inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info<br />
型常量的索引，分别代表了内部类和宿主类的符号引用。<br />
inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类<br />
的名称，如果是匿名内部类，那么这项值为0。<br />
inner_class_access_flags是内部类的访问标志，类似于类的access_flags，它的取值范围见<br />
表6-25。<br />
8.Deprecated及Synthetic属性<br />
Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没<br />
有属性值的概念。<br />
Deprecated属性用于表示某个类、 字段或者方法，已经被程序作者定为不再推荐使用，<br />
它可以通过在代码中使用@deprecated注释进行设置。<br />
Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添<br />
加的，在JDK 1.5之后，标识一个类、 字段或者方法是编译器自动产生的，也可以设置它们<br />
访问标志中的ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method。 所有由非用<br />
户代码产生的类、 方法及字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的<br />
一项，唯一的例外是实例构造器“＜init＞”方法和类构造器“＜clinit＞”方法。<br />
Deprecated和Synthetic属性的结构非常简单，见表6-26。<br />
其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。<br />
9.StackMapTable属性<br />
StackMapTable属性在JDK 1.6发布后增加到了Class文件规范中，它是一个复杂的变长属<br />
性，位于Code属性的属性表中。 这个属性会在虚拟机类加载的字节码验证阶段被新类型检查<br />
验证器（Type Checker）使用（见7.3.2节），目的在于代替以前比较消耗性能的基于数据流<br />
分析的类型推导验证器。<br />
这个类型检查验证器最初来源于Sheng Liang（听名字似乎是虚拟机团队中的华裔成员）<br />
为Java ME CLDC实现的字节码验证器。 新的验证器在同样能保证Class文件合法性的前提<br />
下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而是在编译阶<br />
段将一系列的验证类型（Verification Types）直接记录在Class文件之中，通过检查这些验证<br />
类型代替了类型推导过程，从而大幅提升了字节码验证的性能。 这个验证器在JDK 1.6中首<br />
次提供，并在JDK 1.7中强制代替原本基于类型推断的字节码验证器。 关于这个验证器的工<br />
作原理，《 Java虚拟机规范（Java SE 7版）》 花费了整整120页的篇幅来讲解描述，并且分<br />
析证明新验证方法的严谨性，笔者在此不再赘述。<br />
StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显<br />
式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈<br />
的验证类型。 类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确<br />
定一段字节码指令是否符合逻辑约束。 StackMapTable属性的结构见表6-27。<br />
《 Java虚拟机规范（Java SE 7版）》 明确规定：在版本号大于或等于50.0的Class文件<br />
中，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的<br />
StackMap属性。 这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属<br />
性。 一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError<br />
异常。<br />
10.Signature属性<br />
Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，<br />
可以出现于类、 属性表和方法表结构的属性表中。 在JDK 1.5中大幅增强了Java语言的语法，<br />
在此之后，任何类、 接口、 初始化方法或成员的泛型签名如果包含了类型变量（Type<br />
Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信<br />
息。 之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除<br />
法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量、 参数化类型）之后<br />
都通通被擦除掉。 使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做<br />
了很少的改动）、 非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。 但<br />
坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同<br />
等对待，例如运行期做反射时无法获得到泛型信息。 Signature属性就是为了弥补这个缺陷而<br />
增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。 关于Java<br />
泛型、 Signature属性和类型擦除，在第10章介绍编译器优化的时候会通过一个具体的例子来<br />
讲解。 Signature属性的结构见表6-28。<br />
其中signature_index项的值必须是一个对常量池的有效索引。 常量池在该索引处的项必须<br />
是CONSTANT_Utf8_info结构，表示类签名、 方法类型签名或字段类型签名。 如果当前的<br />
Signature属性是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表<br />
的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结<br />
构表示字段类型签名。<br />
11.BootstrapMethods属性<br />
BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变<br />
长属性，位于类文件的属性表中。 这个属性用于保存invokedynamic指令引用的引导方法限定<br />
符。 《 Java虚拟机规范（Java SE 7版）》 规定，如果某个类文件结构的常量池中曾经出现过<br />
CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确<br />
的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中<br />
出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。 BootstrapMethods<br />
属性与JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切，要介绍这个属性的<br />
作用，必须先弄清楚InovkeDynamic指令的运作原理，笔者将在第8章专门用1节篇幅去介绍它<br />
们，在此先暂时略过。<br />
目前的Javac暂时无法生成InvokeDynamic指令和BootstrapMethods属性，必须通过一些非<br />
常规的手段才能使用到它们，也许在不久的将来，等JSR-292更加成熟一些，这种状况就会<br />
改变。 BootstrapMethods属性的结构见表6-29。<br />
其中引用到的bootstrap_method结构见表6-30。<br />
BootstrapMethods属性中，num_bootstrap_methods项的值给出了bootstrap_methods[]数组中<br />
的引导方法限定符的数量。 而bootstrap_methods[]数组的每个成员包含了一个指向常量池<br />
CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法，还包含了这个引导方法<br />
静态参数的序列（可能为空）。 bootstrap_methods[]数组中的每个成员必须包含以下3项内<br />
容。<br />
bootstrap_method_ref：bootstrap_method_ref项的值必须是一个对常量池的有效索引。 常<br />
量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。<br />
num_bootstrap_arguments：num_bootstrap_arguments项的值给出了bootstrap_arguments[]数<br />
组成员的数量。<br />
bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效<br />
索引。 常量池在该索引处必须是下列结构之一：CONSTANT_String_info、<br />
CONSTANT_Class_info、 CONSTANT_Integer_info、 CONSTANT_Long_info、<br />
CONSTANT_Float_info、 CONSTANT_Double_info、 CONSTANT_MethodHandle_info或<br />
CONSTANT_MethodType_info。<br />
[1]此处字节码的“行”是一种形象的描述，指的是字节码相对于方法体开始的偏移量，而不是<br />
Java源码的行号，下同。<br />
[2]在JDK1.4.2之前的Javac编译器采用了jsr和ret指令实现finally语句，但1.4.2之后已经改为编<br />
译器自动在每段可能的分支路径之后都将finally语句块的内容冗余生成一遍来实现finally语<br />
义。 在JDK 1.7中，已经完全禁止Class文件中出现jsr和ret指令，如果遇到这两条指令，虚拟<br />
机会在类加载的字节码校验阶段抛出异常。<br />
[3]详见第10章中关于语法糖部分的内容。<br />
6.4 字节码指令简介<br />
Java虚拟机的指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作<br />
码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构<br />
成。 由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在<br />
第8章中探讨），所以大多数的指令都不包含操作数，只有一个操作码。<br />
字节码指令集是一种具有鲜明特点、 优劣势都很突出的指令集架构，由于限制了Java虚<br />
拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256<br />
条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些<br />
超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个<br />
16位长度的无符号整数使用两个无符号字节存储起来（将它们命名为byte1和byte2），那它<br />
们的值应该是这样的：<br />
（byte1＜＜8）|byte2<br />
这种操作在某种程度上会导致解释执行字节码时损失一些性能。 但这样做的优势也非常<br />
明显，放弃了操作数长度对齐[1]，就意味着可以省略很多填充和间隔符号；用一个字节来代<br />
表操作码，也是为了尽可能获得短小精干的编译代码。 这种追求尽可能小数据量、 高传输效<br />
率的设计是由Java语言设计之初面向网络、 智能家电的技术背景所决定的，并一直沿用至<br />
今。<br />
如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基<br />
本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：<br />
do{<br />
自动计算PC寄存器的值加1；<br />
根据PC寄存器的指示位置，从字节码流中取出操作码；<br />
if（字节码存在操作数）从字节码流中取出操作数；<br />
执行操作码所定义的操作；<br />
}while（字节码流长度＞0）；<br />
6.4.1 字节码与数据类型<br />
在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。 例<br />
如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是<br />
float类型的数据。 这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在<br />
Class文件中它们必须拥有各自独立的操作码。<br />
对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表<br />
明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long,s代表short,b代表byte,c代<br />
表char,f代表float,d代表double,a代表reference。 也有一些指令的助记符中没有明确地指明操作<br />
类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一<br />
个数组类型的对象。 还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。<br />
由于Java虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集<br />
的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时<br />
数据类型的话，那指令的数量恐怕就会超出一个字节所能表示的数量范围了。 因此，Java虚<br />
拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将<br />
会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为“Not Orthogonal”，即并非<br />
每种数据类型和每一种操作都有对应的指令）。 有一些单独的指令可以在必要的时候用来将<br />
一些不支持的类型转换为可被支持的类型。<br />
表6-31列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列<br />
所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。 如<br />
果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型<br />
执行这项操作。 例如，load指令有操作int类型的iload，但是没有操作byte类型的同类指令。<br />
注意，从表6-31中可以看出，大部分的指令都没有支持整数类型byte、 char和short，甚至<br />
没有任何指令支持boolean类型。 编译器会在编译期或运行期将byte和short类型的数据带符号<br />
扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（ZeroExtend）为相应的int类型数据。 与之类似，在处理boolean、 byte、 short和char类型的数组时，<br />
也会转换为使用对应的int类型的字节码指令来处理。 因此，大多数对于boolean、 byte、 short<br />
和char类型数据的操作，实际上都是使用相应的int类型作为运算类型（Computational<br />
Type）。<br />
在本章中，受篇幅所限，无法对字节码指令集中每条指令进行逐一讲解，但阅读字节码<br />
作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。 笔者将字节码操作按用途大<br />
致分为9类，按照分类来为读者概略介绍一下这些指令的用法。 如果读者需要了解更详细的<br />
信息，可以参考阅读笔者翻译的《 Java虚拟机规范（Java SE 7版）》 的第6章。<br />
[1]字节码指令流基本上都是单字节对齐的，只有“tableswitch”和“lookupswitch”两条指令例<br />
外，由于它们的操作数比较特殊，是以4字节为界划分开的，所以这两条指令也需要预留出<br />
相应的空位进行填充来实现对齐。<br />
6.4.2 加载和存储指令<br />
加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域<br />
的介绍）之间来回传输，这类指令包括如下内容。<br />
将一个局部变量加载到操作栈：iload、 iload_＜n＞、 lload、 lload_＜n＞、 fload、 fload_<br />
＜n＞、 dload、 dload_＜n＞、 aload、 aload_＜n＞。<br />
将一个数值从操作数栈存储到局部变量表：istore、 istore_＜n＞、 lstore、 lstore_＜n＞、<br />
fstore、 fstore_＜n＞、 dstore、 dstore_＜n＞、 astore、 astore_＜n＞。<br />
将一个常量加载到操作数栈：bipush、 sipush、 ldc、 ldc_w、 ldc2_w、 aconst_null、<br />
iconst_m1、 iconst_＜i＞、 lconst_＜l＞、 fconst_＜f＞、 dconst_＜d＞。<br />
扩充局部变量表的访问索引的指令：wide。<br />
存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还<br />
有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。<br />
上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload_＜n＞），这些指<br />
令助记符实际上是代表了一组指令（例如iload_＜n＞，它代表了iload_0、 iload_1、 iload_2和<br />
iload_3这几条指令）。 这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊<br />
形式，对于这若干组特殊指令来说，它们省略掉了显式的操作数，不需要进行取操作数的动<br />
作，实际上操作数就隐含在指令中。 除了这点之外，它们的语义与原生的通用指令完全一致<br />
（例如iload_0的语义与操作数为0时的iload指令语义完全一致）。 这种指令表示方法在本书<br />
以及《 Java虚拟机规范》 中都是通用的。<br />
6.4.3 运算指令<br />
运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操<br />
作栈顶。 大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运<br />
算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、<br />
short、 char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代<br />
替。 整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现，所有的算术<br />
指令如下。<br />
加法指令：iadd、 ladd、 fadd、 dadd。<br />
减法指令：isub、 lsub、 fsub、 dsub。<br />
乘法指令：imul、 lmul、 fmul、 dmul。<br />
除法指令：idiv、 ldiv、 fdiv、 ddiv。<br />
求余指令：irem、 lrem、 frem、 drem。<br />
取反指令：ineg、 lneg、 fneg、 dneg。<br />
位移指令：ishl、 ishr、 iushr、 lshl、 lshr、 lushr。<br />
按位或指令：ior、 lor。<br />
按位与指令：iand、 land。<br />
按位异或指令：ixor、 lxor。<br />
局部变量自增指令：iinc。<br />
比较指令：dcmpg、 dcmpl、 fcmpg、 fcmpl、 lcmp。<br />
Java虚拟机的指令集直接支持了在《 Java语言规范》 中描述的各种对整数及浮点数操作<br />
（参见《 Java语言规范（第3版）》 中的4.2.2节和4.2.4节）的语义。 数据运算可能会导致溢<br />
出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现<br />
象，对于程序员来说是很容易理解的，但其实Java虚拟机规范没有明确定义过整型数据溢出<br />
的具体运算结果，仅规定了在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令<br />
（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整<br />
型数运算场景都不应该抛出运行时异常。<br />
Java虚拟机规范要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定<br />
的行为和限制。 也就是说，Java虚拟机必须完全支持IEEE 754中定义的非正规浮点数值<br />
（Denormalized Floating-Point Numbers）和逐级下溢（Gradual Underflow）的运算规则。 这些<br />
特征将会使某些数值算法处理起来变得相对容易一些。<br />
Java虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精<br />
确的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接<br />
近，将优先选择最低有效位为零的。 这种舍入模式也是IEEE 754规范中的默认舍入模式，称<br />
为向最接近数舍入模式。<br />
在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式<br />
的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。 向零舍入模式将在<br />
目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。<br />
另外，Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java<br />
语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一<br />
种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结<br />
果没有明确的数学定义的话，将会使用NaN值来表示。 所有使用NaN值作为操作数的算术操<br />
作，结果都会返回NaN。<br />
在对long类型数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较<br />
时（dcmpg、 dcmpl、 fcmpg、 fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较<br />
（Nonsignaling Comparisons）方式。<br />
6.4.4 类型转换指令<br />
类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用<br />
户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相<br />
关指令无法与数据类型一一对应的问题。<br />
Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换<br />
（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）：<br />
int类型到long、 float或者double类型。<br />
long类型到float、 double类型。<br />
float类型到double类型。<br />
相对的，处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换<br />
指令来完成，这些转换指令包括：i2b、 i2c、 i2s、 l2i、 f2i、 f2l、 d2i、 d2l和d2f。 窄化类型转<br />
换可能会导致转换结果产生不同的正负号、 不同的数量级的情况，转换过程很可能会导致数<br />
值的精度丢失。<br />
在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单地丢弃除最低位N<br />
个字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的<br />
正负号。 这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果<br />
的符号就取决于低N个字节的首位了。<br />
在将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下<br />
转换规则：<br />
如果浮点值是NaN，那转换结果就是int或long类型的0。<br />
如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值<br />
v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。<br />
否则，将根据v的符号，转换为T所能表示的最大或者最小正数。<br />
从double类型到float类型的窄化转换过程与IEEE 754中定义的一致，通过IEEE 754向最接<br />
近数舍入模式舍入得到一个可以使用float类型表示的数字。 如果转换结果的绝对值太小而无<br />
法使用float来表示的话，将返回float类型的正负零。 如果转换结果的绝对值太大而无法使用<br />
float来表示的话，将返回float类型的正负无穷大，对于double类型的NaN值将按规定转换为<br />
float类型的NaN值。<br />
尽管数据类型窄化转换可能会发生上限溢出、 下限溢出和精度丢失等情况，但是Java虚<br />
拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。<br />
6.4.5 对象创建与访问指令<br />
虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的<br />
字节码指令（在第7章会讲到数组和普通类的类型创建过程是不同的）。 对象创建后，就可<br />
以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下。<br />
创建类实例的指令：new。<br />
创建数组的指令：newarray、 anewarray、 multianewarray。<br />
访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变<br />
量）的指令：getfield、 putfield、 getstatic、 putstatic。<br />
把一个数组元素加载到操作数栈的指令：baload、 caload、 saload、 iaload、 laload、<br />
faload、 daload、 aaload。<br />
将一个操作数栈的值存储到数组元素中的指令：bastore、 castore、 sastore、 iastore、<br />
fastore、 dastore、 aastore。<br />
取数组长度的指令：arraylength。<br />
检查类实例类型的指令：instanceof、 checkcast。<br />
6.4.6 操作数栈管理指令<br />
如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数<br />
栈的指令，包括：<br />
将操作数栈的栈顶一个或两个元素出栈：pop、 pop2。<br />
复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、 dup2、<br />
dup_x1、 dup2_x1、 dup_x2、 dup2_x2。<br />
将栈最顶端的两个数值互换：swap。<br />
6.4.7 控制转移指令<br />
控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指<br />
令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或<br />
无条件地修改PC寄存器的值。 控制转移指令如下。<br />
条件分支：ifeq、 iflt、 ifle、 ifne、 ifgt、 ifge、 ifnull、 ifnonnull、 if_icmpeq、 if_icmpne、<br />
if_icmplt、 if_icmpgt、 if_icmple、 if_icmpge、 if_acmpeq和if_acmpne。<br />
复合条件分支：tableswitch、 lookupswitch。<br />
无条件分支：goto、 goto_w、 jsr、 jsr_w、 ret。<br />
在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了<br />
可以无须明显标识一个实体值是否null，也有专门的指令用来检测null值。<br />
与前面算术运算时的规则一致，对于boolean类型、 byte类型、 char类型和short类型的条<br />
件分支比较操作，都是使用int类型的比较指令来完成，而对于long类型、 float类型和double类<br />
型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、 dcmpl、 fcmpg、<br />
fcmpl、 lcmp，见6.4.3节），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的<br />
条件分支比较操作来完成整个分支跳转。 由于各种类型的比较最终都会转化为int类型的比较<br />
操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支<br />
指令是最为丰富和强大的。<br />
6.4.8 方法调用和返回指令<br />
方法调用（分派、 执行过程）将在第8章具体讲解，这里仅列举以下5条用于方法调用的<br />
指令。<br />
invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分<br />
派），这也是Java语言中最常见的方法分派方式。<br />
invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对<br />
象，找出适合的方法进行调用。<br />
invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、 私有<br />
方法和父类方法。<br />
invokestatic指令用于调用类方法（static方法）。<br />
invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方<br />
法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻<br />
辑是由用户所设定的引导方法决定的。<br />
方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括<br />
ireturn（当返回值是boolean、 byte、 char、 short和int类型时使用）、 lreturn、 freturn、 dreturn和<br />
areturn，另外还有一条return指令供声明为void的方法、 实例初始化方法以及类和接口的类初<br />
始化方法使用。<br />
6.4.9 异常处理指令<br />
在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语<br />
句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指<br />
令检测到异常状况时自动抛出。 例如，在前面介绍的整数运算中，当除数为零时，虚拟机会<br />
在idiv或ldiv指令中抛出ArithmeticException异常。<br />
而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经<br />
使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。<br />
6.4.10 同步指令<br />
Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都<br />
是使用管程（Monitor）来支持的。<br />
方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作<br />
之中。 虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个<br />
方法是否声明为同步方法。 当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED<br />
访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，<br />
最后当方法完成（无论是正常完成还是非正常完成）时释放管程。 在方法执行期间，执行线<br />
程持有了管程，其他任何线程都无法再获取到同一个管程。 如果一个同步方法执行期间抛出<br />
了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同<br />
步方法之外时自动释放。<br />
同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的<br />
指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现<br />
synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，譬如代码清单6-6中所<br />
示的代码。<br />
代码清单6-6 代码同步演示<br />
void onlyMe（Foo f）{<br />
synchronized（f）{<br />
doSomething（）；<br />
}} 编<br />
译后，这段代码生成的字节码序列如下：<br />
Method void onlyMe（Foo）<br />
0 aload_1//将对象f入栈<br />
1 dup//复制栈顶元素（即f的引用）<br />
2 astore_2//将栈顶元素存储到局部变量表Slot 2中<br />
3 monitorenter//以栈顶元素（即f）作为锁，开始同步<br />
4 aload_0//将局部变量Slot 0（即this指针）的元素入栈<br />
5 invokevirtual#5//调用doSomething（）方法<br />
8 aload_2//将局部变量Slow 2的元素（即f）入栈<br />
9 monitorexit//退出同步<br />
10 goto 18//方法正常结束，跳转到18返回<br />
13 astore_3//从这步开始是异常路径，见下面异常表的Taget 13<br />
14 aload_2//将局部变量Slow 2的元素（即f）入栈<br />
15 monitorexit//退出同步<br />
16 aload_3//将局部变量Slow 3的元素（即异常对象）入栈<br />
17 athrow//把异常对象重新抛出给onlyMe（）方法的调用者<br />
18 return//方法正常返回<br />
Exception table：<br />
FromTo Target Type<br />
4 10 13 any<br />
13 16 13 any<br />
编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必<br />
须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。<br />
从代码清单6-6的字节码序列中可以看到，为了保证在方法异常完成时monitorenter和<br />
monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理<br />
器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。<br />
6.5 公有设计和私有实现<br />
Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码<br />
指令集。 这些内容与硬件、 操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实<br />
现者可能更愿意把它们看做是程序在各种Java平台实现之间互相安全地交互的手段。<br />
理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取<br />
Class文件并精确实现包含在其中的Java虚拟机代码的语义。 拿着Java虚拟机规范一成不变地<br />
逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机<br />
规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现<br />
者这样做。 只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的<br />
保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理Class文件完全是<br />
实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。<br />
虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、 更低的内存消耗或<br />
者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。 虚拟机实<br />
现的方式主要有以下两种：<br />
将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。<br />
将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生<br />
成技术）。<br />
精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限<br />
制，Java虚拟机应被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的<br />
同时提供不同的、 新的、 有趣的解决方案。<br />
[1]这里其实多少存在一些例外：譬如调试器（Debuggers）、 性能监视器（Profilers）和即时<br />
编译器（Just-In-Time Code Generator）等都可能需要访问一些通常认为是“虚拟机后台”的元<br />
素。<br />
6.6 Class文件结构的发展<br />
Class文件结构自Java虚拟机规范第1版订立以来，已经有十多年的历史。 这十多年<br />
间，Java技术体系有了翻天覆地的改变，JDK的版本号已经从1.0提升到了1.7。 相对于语言、<br />
API以及Java技术体系中其他方面的变化，Class文件结构一直处于比较稳定的状态，Class文<br />
件的主体结构、 字节码指令的语义和数量几乎没有出现过变动[1]，所有对Class文件格式的改<br />
进，都集中在向访问标志、 属性表这些在设计上就可扩展的数据结构中添加内容。<br />
如果以《 Java虚拟机规范（第2版）》 为基准进行比较的话，那么在后续Class文件格式<br />
的发展过程中，访问标志里新加入了ACC_SYNTHETIC、 ACC_ANNOTATION、<br />
ACC_ENUM、 ACC_BRIDGE、 ACC_VARARGS共5个标志。 而属性表集合中，在JDK 1.5到<br />
JDK 1.7版本之间一共增加了12项新的属性，这些属性大部分用于支持Java中许多新出现的语<br />
言特性，如枚举、 变长参数、 泛型、 动态注解等。 还有一些是为了支持性能改进和调试信<br />
息，譬如JDK 1.6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的<br />
SourceDebugExtension属性。<br />
Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、 紧凑、 稳定和可扩<br />
展的特点，是Java技术体系实现平台无关、 语言无关两项特性的重要支柱。<br />
[1]十余年间，字节码的数量和语义只发生过屈指可数的几次变动，例如，JDK1.0.2时改动过<br />
invokespecial指令的语义；JDK 1.7增加了invokedynamic指令，禁止了ret和jsr指令。<br />
6.7 本章小结<br />
Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一。 了解<br />
Class文件的结构对后面进一步了解虚拟机执行引擎有很重要的意义。<br />
本章详细讲解了Class文件结构中的各个组成部分，以及每个部分的定义、 数据结构和使<br />
用方法。 通过代码清单6-1的Java代码与它的Class文件样例，以实战的方式演示了Class的数<br />
据是如何存储和访问的。 从第7章开始，我们将以动态的、 运行时的角度去看看字节码流在<br />
虚拟机执行引擎中是怎样被解释执行的。<br />
第7章 虚拟机类加载机制<br />
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言<br />
发展的一大步。<br />
7.1 概述<br />
上一章我们了解了Class文件存储格式的具体细节，在Class文件中描述的各种信息，最<br />
终都需要加载到虚拟机中之后才能运行和使用。 而虚拟机如何加载这些Class文件？Class文<br />
件中的信息进入到虚拟机后会发生什么变化？这些都是本章将要讲解的内容。<br />
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、 转换解析和初始<br />
化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br />
与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、 连接和<br />
初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开<br />
销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依<br />
赖运行期动态加载和动态连接这个特点实现的。 例如，如果编写一个面向接口的应用程序，<br />
可以等到运行时再指定其实际的实现类；用户可以通过Java预定义的和自定义类加载器，让<br />
一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部<br />
分，这种组装应用程序的方式目前已广泛应用于Java程序之中。 从最基础的Applet、 JSP到相<br />
对复杂的OSGi技术，都使用了Java语言运行期类加载的特性。<br />
为了避免语言表达中可能产生的偏差，在本章正式开始之前，笔者先设立两个语言上的<br />
约定：第一，在实际情况中，每个Class文件都有可能代表着Java语言中的一个类或接口，后<br />
文中直接对“类”的描述都包括了类和接口的可能性，而对于类和接口需要分开描述的场景会<br />
特别指明；第二，与前面介绍Class文件格式时的约定一致，笔者本章所提到的“Class文<br />
件”并非特指某个存在于具体磁盘中的文件，这里所说的“Class文件”应当是一串二进制的字<br />
节流，无论以何种形式存在都可以。<br />
7.2 类加载的时机<br />
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载<br />
（Loading）、 验证（Verification）、 准备（Preparation）、 解析（Resolution）、 初始化<br />
（Initialization）、 使用（Using）和卸载（Unloading）7个阶段。 其中验证、 准备、 解析3个<br />
部分统称为连接（Linking），这7个阶段的发生顺序如图7-1所示。<br />
图 7-1 类的生命周期<br />
图7-1中，加载、 验证、 准备、 初始化和卸载这5个阶段的顺序是确定的，类的加载过程<br />
必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶<br />
段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 注<br />
意，这里笔者写的是按部就班地“开始”，而不是按部就班地“进行”或“完成”，强调这点是因<br />
为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用、 激活<br />
另外一个阶段。<br />
什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强<br />
制约束，这点可以交给虚拟机的具体实现来自由把握。 但是对于初始化阶段，虚拟机规范则<br />
是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、 验证、 准备自然需要<br />
在此之前开始）：<br />
1）遇到new、 getstatic、 putstatic或invokestatic这4条字节码指令时，如果类没有进行过初<br />
始化，则需要先触发其初始化。 生成这4条指令的最常见的Java代码场景是：使用new关键字<br />
实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常<br />
量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。<br />
2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，<br />
则需要先触发其初始化。<br />
3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父<br />
类的初始化。<br />
4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个<br />
类），虚拟机会先初始化这个主类。<br />
5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后<br />
的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄，并且这个方法句柄<br />
所对应的类没有进行过初始化，则需要先触发其初始化。<br />
对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有<br />
且只有”，这5种场景中的行为称为对一个类进行主动引用。 除此之外，所有引用类的方式都<br />
不会触发初始化，称为被动引用。 下面举3个例子来说明何为被动引用，分别见代码清单7-1<br />
～代码清单7-3。<br />
代码清单7-1 被动引用的例子之一<br />
package org.fenixsoft.classloading；<br />
/**<br />
*被动使用类字段演示一：<br />
*通过子类引用父类的静态字段，不会导致子类初始化<br />
**/<br />
public class SuperClass{<br />
static{<br />
System.out.println（"SuperClass init！"）；<br />
}p<br />
ublic static int value=123；<br />
}p<br />
ublic class SubClass extends SuperClass{<br />
static{<br />
System.out.println（"SubClass init！"）；<br />
}}/<br />
**<br />
*非主动使用类字段演示<br />
**/<br />
public class NotInitialization{<br />
public static void main（String[]args）{<br />
System.out.println（SubClass.value）；<br />
}} 上<br />
述代码运行之后，只会输出“SuperClass init！”，而不会输出“SubClass init！”。 对于静<br />
态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静<br />
态字段，只会触发父类的初始化而不会触发子类的初始化。 至于是否要触发子类的加载和验<br />
证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。 对于Sun HotSpot虚拟机<br />
来说，可通过-XX：+TraceClassLoading参数观察到此操作会导致子类的加载。<br />
代码清单7-2 被动引用的例子之二<br />
package org.fenixsoft.classloading；<br />
/**<br />
*被动使用类字段演示二：<br />
*通过数组定义来引用类，不会触发此类的初始化<br />
**/<br />
public class NotInitialization{<br />
public static void main（String[]args）{<br />
SuperClass[]sca=new SuperClass[10]；<br />
}} 为<br />
了节省版面，这段代码复用了代码清单7-1中的SuperClass，运行之后发现没有输<br />
出“SuperClass init！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。<br />
但是这段代码里面触发了另外一个名为“[Lorg.fenixsoft.classloading.SuperClass”的类的初始化<br />
阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、 直<br />
接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。<br />
这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应<br />
有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone（）方法）都实<br />
现在这个类里。 Java语言中对数组的访问比C/C++相对安全是因为这个类封装了数组元素的<br />
访问方法[1]，而C/C++直接翻译为对数组指针的移动。 在Java语言中，当检查到发生数组越界<br />
时会抛出java.lang.ArrayIndexOutOfBoundsException异常。<br />
代码清单7-3 被动引用的例子之三<br />
package org.fenixsoft.classloading；<br />
/**<br />
*被动使用类字段演示三：<br />
*常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br />
**/<br />
public class ConstClass{<br />
static{<br />
System.out.println（"ConstClass init！"）；<br />
}p<br />
ublic static final String HELLOWORLD="hello world"；<br />
}/<br />
**<br />
*非主动使用类字段演示<br />
**/<br />
public class NotInitialization{<br />
public static void main（String[]args）{<br />
System.out.println（ConstClass.HELLOWORLD）；<br />
}} 上<br />
述代码运行之后，也没有输出“ConstClass init！”，这是因为虽然在Java源码中引用了<br />
ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量<br />
的值“hello world”存储到了NotInitialization类的常量池中，以后NotInitialization对常量<br />
ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。<br />
也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两<br />
个类在编译成Class之后就不存在任何联系了。<br />
接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有<br />
初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息<br />
的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“＜clinit＞（）”类构造<br />
器[2]，用于初始化接口中所定义的成员变量。 接口与类真正有所区别的是前面讲述的5种“有<br />
且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始<br />
化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使<br />
用到父接口的时候（如引用接口中定义的常量）才会初始化。<br />
[1]准确地说，越界检查不是封装在数组元素访问的类中，而是封装在数组访问的xaload、<br />
xastore字节码指令中。<br />
[2]关于类构造器＜clinit＞和方法构造器＜init＞的生成过程和作用，可参见第10章的相关内<br />
容。<br />
7.3 类加载的过程<br />
接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、 验证、 准备、 解<br />
析和初始化这5个阶段所执行的具体动作。<br />
7.3.1 加载<br />
“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来<br />
很相似的名词。 在加载阶段，虚拟机需要完成以下3件事情：<br />
1）通过一个类的全限定名来获取定义此类的二进制字节流。<br />
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br />
3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据<br />
的访问入口。<br />
虚拟机规范的这3点要求其实并不算具体，因此虚拟机实现与具体应用的灵活度都是相<br />
当大的。 例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条，它没有指明二<br />
进制字节流要从一个Class文件中获取，准确地说是根本没有指明要从哪里获取、 怎样获取。<br />
虚拟机设计团队在加载阶段搭建了一个相当开放的、 广阔的“舞台”，Java发展历程中，充满<br />
创造力的开发人员则在这个“舞台”上玩出了各种花样，许多举足轻重的Java技术都建立在这<br />
一基础之上，例如：<br />
从ZIP包中读取，这很常见，最终成为日后JAR、 EAR、 WAR格式的基础。<br />
从网络中获取，这种场景最典型的应用就是Applet。<br />
运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy<br />
中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类<br />
的二进制字节流。<br />
由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。<br />
从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAP Netweaver）<br />
可以选择把程序安装到数据库中来完成程序代码在集群间的分发。<br />
……<br />
相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获<br />
取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供<br />
的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自<br />
己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass（）方法）。<br />
对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟<br />
机直接创建的。 但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element<br />
Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简<br />
称为C）创建过程就遵循以下规则：<br />
如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型）是引用类<br />
型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型<br />
的类加载器的类名称空间上被标识（这点很重要，在7.4节会介绍到，一个类必须与类加载<br />
器一起确定唯一性）。<br />
如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与<br />
引导类加载器关联。<br />
数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类<br />
的可见性将默认为public。<br />
关于类加载器的话题，笔者将在本章的7.4节专门讲述。<br />
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之<br />
中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据<br />
结构。 然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对<br />
于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这<br />
个对象将作为程序访问方法区中的这些类型数据的外部接口。<br />
加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，<br />
加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属<br />
于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。<br />
7.3.2 验证<br />
验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息<br />
符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br />
Java语言本身是相对安全的语言（依然是相对于C/C++来说），使用纯粹的Java代码无<br />
法做到诸如访问数组边界以外的数据、 将一个对象转型为它并未实现的类型、 跳转到不存在<br />
的代码行之类的事情，如果这样做了，编译器将拒绝编译。 但前面已经说过，Class文件并不<br />
一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编<br />
写来产生Class文件。 在字节码语言层面上，上述Java代码无法做到的事情都是可以实现的，<br />
至少语义上是可以表达出来的。 虚拟机如果不检查输入的字节流，对其完全信任的话，很可<br />
能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工<br />
作。<br />
验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代<br />
码的攻击，从执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载子系统中又占了相<br />
当大的一部分。 《 Java虚拟机规范（第2版）》 对这个阶段的限制、 指导还是比较笼统的，<br />
规范中列举了一些Class文件格式中的静态和结构化约束，如果验证到输入的字节流不符合<br />
Class文件格式的约束，虚拟机就应抛出一个java.lang.VerifyError异常或其子类异常，但具体<br />
应当检查哪些方面，如何检查，何时检查，都没有足够具体的要求和明确的说明。 直到2011<br />
年发布的《 Java虚拟机规范（Java SE 7版）》 ，大幅增加了描述验证过程的篇幅（从不到10<br />
页增加到130页），这时约束和验证规则才变得具体起来。 受篇幅所限，本书无法逐条规则<br />
去讲解，但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、<br />
元数据验证、 字节码验证、 符号引用验证。<br />
1.文件格式验证<br />
第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处<br />
理。 这一阶段可能包括下面这些验证点：<br />
是否以魔数0xCAFEBABE开头。<br />
主、 次版本号是否在当前虚拟机处理范围之内。<br />
常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。<br />
指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。<br />
CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。<br />
Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。<br />
……<br />
实际上，第一阶段的验证点还远不止这些，上面这些只是从HotSpot虚拟机源码[1]中摘抄<br />
的一小部分内容，该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区<br />
之内，格式上符合描述一个Java类型信息的要求。 这阶段的验证是基于二进制字节流进行<br />
的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的<br />
3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。<br />
2.元数据验证<br />
第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范<br />
的要求，这个阶段可能包括的验证点如下：<br />
这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。<br />
这个类的父类是否继承了不允许被继承的类（被final修饰的类）。<br />
如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。<br />
类中的字段、 方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合<br />
规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。<br />
……<br />
第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规<br />
范的元数据信息。<br />
3.字节码验证<br />
第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，<br />
确定程序语义是合法的、 符合逻辑的。 在第二阶段对元数据信息中的数据类型做完校验后，<br />
这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机<br />
安全的事件，例如：<br />
保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这<br />
样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表<br />
中。<br />
保证跳转指令不会跳转到方法体以外的字节码指令上。<br />
保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这<br />
是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、 完<br />
全不相干的一个数据类型，则是危险和不合法的。<br />
……<br />
如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法<br />
体通过了字节码验证，也不能说明其一定就是安全的。 即使字节码验证之中进行了大量的检<br />
查，也不能保证这一点。 这里涉及了离散数学中一个很著名的问题“Halting Problem”[2]：通俗<br />
一点的说法就是，通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地<br />
检查出程序是否能在有限的时间之内结束运行。<br />
由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶<br />
段，在JDK 1.6之后的Javac编译器和Java虚拟机中进行了一项优化，给方法体的Code属性的<br />
属性表中增加了一项名为“StackMapTable”的属性，这项属性描述了方法体中所有的基本块<br />
（Basic Block，按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节<br />
码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中<br />
的记录是否合法即可。 这样将字节码验证的类型推导转变为类型检查从而节省一些时间。<br />
理论上StackMapTable属性也存在错误或被篡改的可能，所以是否有可能在恶意篡改了<br />
Code属性的同时，也生成相应的StackMapTable属性来骗过虚拟机的类型校验则是虚拟机设<br />
计者值得思考的问题。<br />
在JDK 1.6的HotSpot虚拟机中提供了-XX：-UseSplitVerifier选项来关闭这项优化，或者使<br />
用参数-XX：+FailOverToOldVerifier要求在类型校验失败的时候退回到旧的类型推导方式进<br />
行校验。 而在JDK 1.7之后，对于主版本号大于50的Class文件，使用类型检查来完成数据流<br />
分析校验则是唯一的选择，不允许再退回到类型推导的校验方式。<br />
4.符号引用验证<br />
最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将<br />
在连接的第三阶段——解析阶段中发生。 符号引用验证可以看做是对类自身以外（常量池中<br />
的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：<br />
符号引用中通过字符串描述的全限定名是否能找到对应的类。<br />
在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。<br />
符号引用中的类、 字段、 方法的访问性（private、 protected、 public、 default）是否可被<br />
当前类访问。<br />
……<br />
符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将<br />
会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如<br />
java.lang.IllegalAccessError、 java.lang.NoSuchFieldError、 java.lang.NoSuchMethodError等。<br />
对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、 但不是一定必要（因为对<br />
程序运行期没有影响）的阶段。 如果所运行的全部代码（包括自己编写的及第三方包中的代<br />
码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify：none参数来关<br />
闭大部分的类验证措施，以缩短虚拟机类加载的时间。<br />
[1]源码位置：hotspot\src\share\vm\classfile\classFileParser.cpp。<br />
[2]停机问题就是判断任意一个程序是否会在有限的时间之内结束运行的问题。 如果这个问题<br />
可以在有限的时间之内解决，可以有一个程序判断其本身是否会停机并做出相反的行为。 这<br />
时候显然不管停机问题的结果是什么都不会符合要求，所以这是一个不可解的问题。 具体的<br />
证明过程可参考：http://zh.wikipedia.org/zh/停机问题。<br />
7.3.3 准备<br />
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存<br />
都将在方法区中进行分配。 这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这<br />
时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将<br />
会在对象实例化时随着对象一起分配在Java堆中。 其次，这里所说的初始值“通常情况”下是<br />
数据类型的零值，假设一个类变量的定义为：<br />
public static int value=123；<br />
那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java<br />
方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方<br />
法之中，所以把value赋值为123的动作将在初始化阶段才会执行。 表7-1列出了Java中所有基<br />
本数据类型的零值。<br />
上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段<br />
的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为<br />
ConstantValue属性所指定的值，假设上面类变量value的定义变为：<br />
public static final int value=123；<br />
编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据<br />
ConstantValue的设置将value赋值为123。<br />
7.3.4 解析<br />
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在前一章讲<br />
解Class文件格式的时候已经出现过多次，在Class文件中它以CONSTANT_Class_info、<br />
CONSTANT_Fieldref_info、 CONSTANT_Methodref_info等类型的常量出现，那解析阶段中所<br />
说的直接引用与符号引用又有什么关联呢？<br />
符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可<br />
以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的<br />
内存布局无关，引用的目标并不一定已经加载到内存中。 各种虚拟机实现的内存布局可以各<br />
不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义<br />
在Java虚拟机规范的Class文件格式中。<br />
直接引用（Direct References）：直接引用可以是直接指向目标的指针、 相对偏移量或是<br />
一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局相关的，同一个符号引<br />
用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用，那引用的目<br />
标必定已经在内存中存在。<br />
虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、<br />
checkcast、 getfield、 getstatic、 instanceof、 invokedynamic、 invokeinterface、 invokespecial、<br />
invokestatic、 invokevirtual、 ldc、 ldc_w、 multianewarray、 new、 putfield和putstatic这16个用于<br />
操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。 所以虚拟机实现可<br />
以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到<br />
一个符号引用将要被使用前才去解析它。<br />
对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟<br />
机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识<br />
为已解析状态）从而避免解析动作重复进行。 无论是否真正执行了多次解析动作，虚拟机需<br />
要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解<br />
析请求就应当一直成功；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析<br />
请求也应该收到相同的异常。<br />
对于invokedynamic指令，上面规则则不成立。 当碰到某个前面已经由invokedynamic指令<br />
触发过解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生<br />
效。 因为invokedynamic指令的目的本来就是用于动态语言支持（目前仅使用Java语言不会生<br />
成这条字节码指令），它所对应的引用称为“动态调用点限定符”（Dynamic Call Site<br />
Specifier），这里“动态”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才<br />
能进行。 相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有<br />
开始执行代码时就进行解析。<br />
解析动作主要针对类或接口、 字段、 类方法、 接口方法、 方法类型、 方法句柄和调用点<br />
限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、<br />
CONSTANT_Fieldref_info、 CONSTANT_Methodref_info、<br />
CONSTANT_InterfaceMethodref_info、 CONSTANT_MethodType_info、<br />
CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型 [1]。 下面将讲<br />
解前面4种引用的解析过程，对于后面3种，与JDK 1.7新增的动态语言支持息息相关，由于<br />
Java语言是一门静态类型语言，因此在没有介绍invokedynamic指令的语义之前，没有办法将<br />
它们和现在的Java语言对应上，笔者将在第8章介绍动态语言调用时一起分析讲解。<br />
1.类或接口的解析<br />
假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接<br />
口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：<br />
1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去<br />
加载这个类C。 在加载过程中，由于元数据验证、 字节码验证的需要，又可能触发其他相关<br />
类的加载动作，例如加载这个类的父类或实现的接口。 一旦这个加载过程出现了任何异常，<br />
解析过程就宣告失败。<br />
2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类<br />
似“[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。 如果N的描述符<br />
如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个<br />
代表此数组维度和元素的数组对象。<br />
3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类<br />
或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。 如<br />
果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。<br />
2.字段解析<br />
要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index[2]项中索引的<br />
CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。 如果在<br />
解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。<br />
如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤<br />
对C进行后续字段的搜索。<br />
1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段<br />
的直接引用，查找结束。<br />
2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的<br />
父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段<br />
的直接引用，查找结束。<br />
3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父<br />
类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的<br />
直接引用，查找结束。<br />
4）否则，查找失败，抛出java.lang.NoSuchFieldError异常。<br />
如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段<br />
的访问权限，将抛出java.lang.IllegalAccessError异常。<br />
在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一<br />
个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编<br />
译器将可能拒绝编译。 在代码清单7-4中，如果注释了Sub类中的“public static int A=4；”，接<br />
口与父类同时存在字段A，那编译器将提示“The field Sub.A is ambiguous”，并且拒绝编译这<br />
段代码。<br />
代码清单7-4 字段解析<br />
package org.fenixsoft.classloading；<br />
public class FieldResolution{<br />
interface Interface0{<br />
int A=0；<br />
}i<br />
nterface Interface1 extends Interface0{<br />
int A=1；<br />
}i<br />
nterface Interface2{<br />
int A=2；<br />
}s<br />
tatic class Parent implements Interface1{<br />
public static int A=3；<br />
}s<br />
tatic class Sub extends Parent implements Interface2{<br />
public static int A=4；<br />
}p<br />
ublic static void main（String[]args）{<br />
System.out.println（Sub.A）；<br />
}} 3<br />
.类方法解析<br />
类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index[3]项中<br />
索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来<br />
虚拟机将会按照如下步骤进行后续的类方法搜索。<br />
1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现<br />
class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。<br />
2）如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，<br />
如果有则返回这个方法的直接引用，查找结束。<br />
3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如<br />
果有则返回这个方法的直接引用，查找结束。<br />
4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符<br />
都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛<br />
出java.lang.AbstractMethodError异常。<br />
5）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。<br />
最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不<br />
具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。<br />
4.接口方法解析<br />
接口方法也需要先解析出接口方法表的class_index[4]项中索引的方法所属的类或接口的符<br />
号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续<br />
的接口方法搜索。<br />
1）与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接<br />
口，那就直接抛出java.lang.IncompatibleClassChangeError异常。<br />
2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返<br />
回这个方法的直接引用，查找结束。<br />
3）否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括<br />
Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方<br />
法的直接引用，查找结束。<br />
4）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。<br />
由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法<br />
的符号解析应当不会抛出java.lang.IllegalAccessError异常。<br />
[1]严格来说，CONSTANT_String_info和CONSTANT_InterfaceMethodref_info这两种类型的常<br />
量也有解析过程，但很简单、 直观，不再做单独介绍。<br />
[2]参见第6章中关于CONSTANT_Fieldref_info常量的内容。<br />
[3]参见第6章关于CONSTANT_Methodref_info常量的内容。<br />
[4]参见第6章中关于CONSTANT_InterfaceMethodref_info常量的内容。<br />
7.3.5 初始化<br />
类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应<br />
用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。 到了初始化<br />
阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。<br />
在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通<br />
过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始<br />
化阶段是执行类构造器＜clinit＞（）方法的过程。 我们在下文会讲解＜clinit＞（）方法是怎<br />
么生成的，在这里，我们先看一下＜clinit＞（）方法执行过程中一些可能会影响程序运行行<br />
为的特点和细节，这部分相对更贴近于普通的程序开发人员[1]。<br />
＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块<br />
（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决<br />
定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前<br />
面的静态语句块可以赋值，但是不能访问，如代码清单7-5中的例子所示。<br />
代码清单7-5 非法向前引用变量<br />
public class Test{<br />
static{<br />
i=0；//给变量赋值可以正常编译通过<br />
System.out.print（i）；//这句编译器会提示"非法向前引用"<br />
}s<br />
tatic int i=1；<br />
}<br />
＜clinit＞（）方法与类的构造函数（或者说实例构造器＜init＞（）方法）不同，它不<br />
需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞（）方法执行之前，父类的＜<br />
clinit＞（）方法已经执行完毕。 因此在虚拟机中第一个被执行的＜clinit＞（）方法的类肯定<br />
是java.lang.Object。<br />
由于父类的＜clinit＞（）方法先执行，也就意味着父类中定义的静态语句块要优先于子<br />
类的变量赋值操作，如在代码清单7-6中，字段B的值将会是2而不是1。<br />
代码清单7-6＜clinit＞（）方法执行顺序<br />
static class Parent{<br />
public static int A=1；<br />
static{<br />
A=2；<br />
}}s<br />
tatic class Sub extends Parent{<br />
public static int B=A；<br />
}p<br />
ublic static void main（String[]args）{<br />
System.out.println（Sub.B）；<br />
}<br />
＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也<br />
没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。<br />
接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会<br />
生成＜clinit＞（）方法。 但接口与类不同的是，执行接口的＜clinit＞（）方法不需要先执行<br />
父接口的＜clinit＞（）方法。 只有当父接口中定义的变量使用时，父接口才会初始化。 另<br />
外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞（）方法。<br />
虚拟机会保证一个类的＜clinit＞（）方法在多线程环境中被正确地加锁、 同步，如果多<br />
个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞（）方法，其他<br />
线程都需要阻塞等待，直到活动线程执行＜clinit＞（）方法完毕。 如果在一个类的＜clinit＞<br />
（）方法中有耗时很长的操作，就可能造成多个进程阻塞[2]，在实际应用中这种阻塞往往是<br />
很隐蔽的。 代码清单7-7演示了这种场景。<br />
代码清单7-7 字段解析<br />
static class DeadLoopClass{<br />
static{<br />
/*如果不加上这个if语句，编译器将提示"Initializer does not complete normally"并拒绝编译*/<br />
if（true）{<br />
System.out.println（Thread.currentThread（）+"init DeadLoopClass"）；<br />
while（true）{<br />
}}}}p<br />
ublic static void main（String[]args）{<br />
Runnable script=new Runnable（）{<br />
public void run（）{<br />
System.out.println（Thread.currentThread（）+"start"）；<br />
DeadLoopClass dlc=new DeadLoopClass（）；<br />
System.out.println（Thread.currentThread（）+"run over"）；<br />
}}<br />
；<br />
Thread thread1=new Thread（script）；<br />
Thread thread2=new Thread（script）；<br />
thread1.start（）；<br />
thread2.start（）；<br />
} 运<br />
行结果如下，即一条线程在死循环以模拟长时间操作，另外一条线程在阻塞等待。<br />
Thread[Thread-0，5，main]start<br />
Thread[Thread-1，5，main]start<br />
Thread[Thread-0，5，main]init DeadLoopClass<br />
[1]这里只限于Java语言编译产生的Class文件，并不包括其他JVM语言。<br />
[2]需要注意的是，其他线程虽然会被阻塞，但如果执行＜clinit＞（）方法的那条线程退出<br />
＜clinit＞（）方法后，其他线程唤醒之后不会再次进入＜clinit＞（）方法。 同一个类加载器<br />
下，一个类型只会初始化一次。<br />
7.4 类加载器<br />
虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字<br />
节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的<br />
类。 实现这个动作的代码模块称为“类加载器”。<br />
类加载器可以说是Java语言的一项创新，也是Java语言流行的重要原因之一，它最初是<br />
为了满足Java Applet的需求而开发出来的。 虽然目前Java Applet技术基本上已经“死掉” [1]，但<br />
类加载器却在类层次划分、 OSGi、 热部署、 代码加密等领域大放异彩，成为了Java技术体系<br />
中一块重要的基石，可谓是失之桑榆，收之东隅。<br />
7.4.1 类与类加载器<br />
类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类<br />
加载阶段。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚<br />
拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。 这句话可以表达得更通<br />
俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意<br />
义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类<br />
加载器不同，那这两个类就必定不相等。<br />
这里所指的“相等”，包括代表类的Class对象的equals（）方法、 isAssignableFrom（）方<br />
法、 isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情<br />
况。 如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果，代码清<br />
单7-8中演示了不同的类加载器对instanceof关键字运算的结果的影响。<br />
代码清单7-8 不同的类加载器对instanceof关键字运算的结果的影响<br />
/**<br />
*类加载器与instanceof关键字演示<br />
**<br />
@author zzm<br />
*/<br />
public class ClassLoaderTest{<br />
public static void main（String[]args）throws Exception{<br />
ClassLoader myLoader=new ClassLoader（）{<br />
@Override<br />
public Class＜?＞loadClass（String name）throws ClassNotFoundException{<br />
try{<br />
String fileName=name.substring（name.lastIndexOf（"."）+1）+".class"；<br />
InputStream is=getClass（）.getResourceAsStream（fileName）；<br />
if（is==null）{<br />
return super.loadClass（name）；<br />
}b<br />
yte[]b=new byte[is.available（）]；<br />
is.read（b）；<br />
return defineClass（name,b，0，b.length）；<br />
}catch（IOException e）{<br />
throw new ClassNotFoundException（name）；<br />
}}}<br />
；<br />
Object obj=myLoader.loadClass（"org.fenixsoft.classloading.ClassLoaderTest"）.newInstance（）；<br />
System.out.println（obj.getClass（））；<br />
System.out.println（obj instanceof org.fenixsoft.classloading.ClassLoaderTest）；<br />
}} 运<br />
行结果：<br />
class org.fenixsoft.classloading.ClassLoaderTest<br />
false<br />
代码清单7-8中构造了一个简单的类加载器，尽管很简单，但是对于这个演示来说还是<br />
够用了。 它可以加载与自己在同一路径下的Class文件。 我们使用这个类加载器去加载了一个<br />
名为“org.fenixsoft.classloading.ClassLoaderTest”的类，并实例化了这个类的对象。 两行输出结<br />
果中，从第一句可以看出，这个对象确实是类org.fenixsoft.classloading.ClassLoaderTest实例化<br />
出来的对象，但从第二句可以发现，这个对象与类org.fenixsoft.classloading.ClassLoaderTest做<br />
所属类型检查的时候却返回了false，这是因为虚拟机中存在了两个ClassLoaderTest类，一个<br />
是由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来<br />
自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然为false。<br />
[1]特指浏览器上的Java Applets，在其他领域，如智能卡上，Java Applets仍然有广阔的市<br />
场。<br />
7.4.2 双亲委派模型<br />
从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器<br />
（Bootstrap ClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；另<br />
一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且<br />
全都继承自抽象类java.lang.ClassLoader。<br />
从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都<br />
会使用到以下3种系统提供的类加载器。<br />
启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在＜<br />
JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机<br />
识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）<br />
类库加载到虚拟机内存中。 启动类加载器无法被Java程序直接引用，用户在编写自定义类加<br />
载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如代码清单<br />
7-9所示为java.lang.ClassLoader.getClassLoader（）方法的代码片段。<br />
代码清单7-9 ClassLoader.getClassLoader（）方法的代码片段<br />
/**<br />
Returns the class loader for the class.Some implementations may use null to represent the bootstrap class loader.This method will return null in such<br />
implementations if this class was loaded by the bootstrap class loader.<br />
*/<br />
public ClassLoader getClassLoader（）{<br />
ClassLoader cl=getClassLoader0（）；<br />
if（cl==null）<br />
return null；<br />
SecurityManager sm=System.getSecurityManager（）；<br />
if（sm！=null）{<br />
ClassLoader ccl=ClassLoader.getCallerClassLoader（）；<br />
if（ccl！=null＆＆ccl！=cl＆＆！cl.isAncestor（ccl））{<br />
sm.checkPermission（SecurityConstants.GET_CLASSLOADER_PERMISSION）；<br />
}}r<br />
eturn cl；<br />
} 扩<br />
展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher<br />
$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系<br />
统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<br />
应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。 由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回<br />
值，所以一般也称它为系统类加载器。 它负责加载用户类路径（ClassPath）上所指定的类<br />
库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一<br />
般情况下这个就是程序中默认的类加载器。<br />
我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入<br />
自己定义的类加载器。 这些类加载器之间的关系一般如图7-2所示。<br />
图 7-2 类加载器双亲委派模型<br />
图7-2中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents<br />
Delegation Model）。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当<br />
有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系<br />
来实现，而是都使用组合（Composition）关系来复用父加载器的代码。<br />
类加载器的双亲委派模型在JDK 1.2期间被引入并被广泛应用于之后几乎所有的Java程序<br />
中，但它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现<br />
方式。<br />
双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己<br />
去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是<br />
如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈<br />
自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自<br />
己去加载。<br />
使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着<br />
它的类加载器一起具备了一种带有优先级的层次关系。 例如类java.lang.Object，它存放在<br />
rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加<br />
载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。 相反，如果没有<br />
使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为<br />
java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object<br />
类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 如果读者<br />
有兴趣的话，可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编<br />
译，但永远无法被加载运行[2]。<br />
双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲<br />
委派的代码都集中在java.lang.ClassLoader的loadClass（）方法之中，如代码清单7-10所示，<br />
逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方<br />
法，若父加载器为空则默认使用启动类加载器作为父加载器。 如果父类加载失败，抛出<br />
ClassNotFoundException异常后，再调用自己的findClass（）方法进行加载。<br />
代码清单7-10 双亲委派模型的实现<br />
protected synchronized Class＜?＞loadClass（String name,boolean resolve）throws ClassNotFoundException<br />
{/<br />
/首先，检查请求的类是否已经被加载过了<br />
Class c=findLoadedClass（name）；<br />
if（c==null）{<br />
try{<br />
if（parent！=null）{<br />
c=parent.loadClass（name,false）；<br />
}else{<br />
c=findBootstrapClassOrNull（name）；<br />
}}<br />
catch（ClassNotFoundException e）{<br />
//如果父类加载器抛出ClassNotFoundException<br />
//说明父类加载器无法完成加载请求<br />
}i<br />
f（c==null）{<br />
//在父类加载器无法加载的时候<br />
//再调用本身的findClass方法来进行类加载<br />
c=findClass（name）；<br />
}}i<br />
f（resolve）{<br />
resolveClass（c）；<br />
}r<br />
eturn c；<br />
}<br />
[1]这里只限于HotSpot，像MRP、 Maxine等虚拟机，整个虚拟机本身都是由Java编写的，自<br />
然Bootstrap ClassLoader也是由Java语言而不是C++实现的。 退一步讲，除了HotSpot以外的其<br />
他两个高性能虚拟机JRockit和J9都有一个代表Bootstrap ClassLoader的Java类存在，但是关键<br />
方法的实现仍然是使用JNI回调到C（注意不是C++）的实现上，这个Bootstrap ClassLoader的<br />
实例也无法被用户获取到。<br />
[2]即使自定义了自己的类加载器，强行用defineClass（）方法去加载一个以“java.lang”开头<br />
的类也不会成功。 如果尝试这样做的话，将会收到一个由虚拟机自己抛出<br />
的“java.lang.SecurityException：Prohibited package name：java.lang”异常。<br />
7.4.3 破坏双亲委派模型<br />
上文提到过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者<br />
的类加载器实现方式。 在Java的世界中大部分的类加载器都遵循这个模型，但也有例外，到<br />
目前为止，双亲委派模型主要出现过3较大规模的“被破坏”情况。<br />
双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2发布之<br />
前。 由于双亲委派模型在JDK 1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则<br />
在JDK 1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引<br />
入双亲委派模型时不得不做出一些妥协。 为了向前兼容，JDK 1.2之后的java.lang.ClassLoader<br />
添加了一个新的protected方法findClass（），在此之前，用户去继承java.lang.ClassLoader的<br />
唯一目的就是为了重写loadClass（）方法，因为虚拟机在进行类加载的时候会调用加载器的<br />
私有方法loadClassInternal（），而这个方法的唯一逻辑就是去调用自己的loadClass（）。<br />
上一节我们已经看过loadClass（）方法的代码，双亲委派的具体逻辑就实现在这个方法<br />
之中，JDK 1.2之后已不提倡用户再去覆盖loadClass（）方法，而应当把自己的类加载逻辑<br />
写到findClass（）方法中，在loadClass（）方法的逻辑里如果父类加载失败，则会调用自己<br />
的findClass（）方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则<br />
的。<br />
双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解<br />
决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类<br />
之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完<br />
美，如果基础类又要调用回用户的代码，那该怎么办？<br />
这并非是不可能的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服<br />
务，它的代码由启动类加载器去加载（在JDK 1.3时放进去的rt.jar），但JNDI的目的就是对<br />
资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的<br />
JNDI接口提供者（SPI,Service Provider Interface）的代码，但启动类加载器不可能“认识”这些<br />
代码啊！那该怎么办？<br />
为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载<br />
器（Thread Context ClassLoader）。 这个类加载器可以通过java.lang.Thread类的<br />
setContextClassLoaser（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承<br />
一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序<br />
类加载器。<br />
有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下<br />
文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动<br />
作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经<br />
违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。 Java中所有涉及SPI的加载动<br />
作基本上都采用这种方式，例如JNDI、 JDBC、 JCE、 JAXB和JBI等。<br />
双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说<br />
的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、 模块热部署（Hot<br />
Deployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、 U盘，<br />
不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。 对于<br />
个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一<br />
次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者<br />
具有很大的吸引力。<br />
Sun公司所提出的JSR-294[1]、 JSR-277[2]规范在与JCP组织的模块化规范之争中落败给JSR-<br />
291（即OSGi R4.2），虽然Sun不甘失去Java模块化的主导权，独立在发展Jigsaw项目，但目<br />
前OSGi已经成为了业界“事实上”的Java模块化标准[3]，而OSGi实现模块化热部署的关键则是<br />
它自定义的类加载器机制的实现。 每一个程序模块（OSGi中称为Bundle）都有一个自己的类<br />
加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替<br />
换。<br />
在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加<br />
复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：<br />
1）将以java.*开头的类委派给父类加载器加载。<br />
2）否则，将委派列表名单内的类委派给父类加载器加载。<br />
3）否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。<br />
4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。<br />
5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的<br />
类加载器加载。<br />
6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br />
7）否则，类查找失败。<br />
上面的查找顺序中只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类<br />
加载器中进行的。<br />
笔者虽然使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这<br />
里“被破坏”并不带有贬义的感情色彩。 只要有足够意义和理由，突破已有的原则就可认为是<br />
一种创新。 正如OSGi中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为<br />
了实现热部署而带来的额外的高复杂度还存在不少争议，但在Java程序员中基本有一个共<br />
识：OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，就可以算是掌握了类<br />
加载器的精髓。<br />
[1]JSR-294：Improved Modularity Support in the Java Programming Language（Java编程语言中的<br />
改进模块性支持）。<br />
[2]JSR-277：Java Module System（Java模块系统）。<br />
[3]如果读者对Java模块化之争或者OSGi本身感兴趣，可以阅读笔者的另一本书《 深入理解<br />
OSGi：Equinox原理、 应用与最佳实践》 。<br />
7.5 本章小结<br />
本章介绍了类加载过程的“加载”、 “验证”、 “准备”、 “解析”和“初始化”5个阶段中虚拟机<br />
进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。<br />
经过第6和第7两章的讲解，相信读者已经对如何在Class文件中定义类，如何将类加载到<br />
虚拟机中这两个问题有了比较系统的了解，第8章我们将一起来看看虚拟机如何执行定义在<br />
Class文件里的字节码。</p>

<h2>第8章 虚拟机字节码执行引擎</h2>

<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言<br />
发展的一大步。<br />
8.1 概述<br />
执行引擎是Java虚拟机最核心的组成部分之一。 “虚拟机”是一个相对于“物理机”的概<br />
念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、 硬<br />
件、 指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制<br />
定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。<br />
在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种<br />
虚拟机执行引擎的统一外观（Facade）。 在不同的虚拟机实现里面，执行引擎在执行Java代<br />
码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码<br />
执行）两种选择[1]，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。<br />
但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理<br />
过程是字节码解析的等效过程，输出的是执行结果，本章将主要从概念模型的角度来讲解虚<br />
拟机的方法调用和字节码执行。<br />
[1]有一些虚拟机（如Sun Classic VM）的内部只存在解释器，只能解释执行，而另外一些虚<br />
拟机（如BEA JRockit）的内部只存在即时编译器，只能编译执行。<br />
8.2 运行时栈帧结构<br />
栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟<br />
机运行时数据区中的虚拟机栈（Virtual Machine Stack）[1]的栈元素。 栈帧存储了方法的局部<br />
变量表、 操作数栈、 动态连接和方法返回地址等信息。 每一个方法从调用开始至执行完成的<br />
过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br />
每一个栈帧都包括了局部变量表、 操作数栈、 动态连接、 方法返回地址和一些额外的附<br />
加信息。 在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完<br />
全确定了，并且写入到方法表的Code属性之中[2]，因此一个栈帧需要分配多少内存，不会受<br />
到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。<br />
一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。 对于执行引擎来<br />
说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack<br />
Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。 执行引擎运行的所有<br />
字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图8-1所示。<br />
图 8-1 栈帧的概念结构<br />
接下来详细讲解一下栈帧中的局部变量表、 操作数栈、 动态连接、 方法返回地址等各个<br />
部分的作用和数据结构。<br />
8.2.1 局部变量表<br />
局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法<br />
内部定义的局部变量。 在Java程序编译为Class文件时，就在方法的Code属性的max_locals数<br />
据项中确定了该方法所需要分配的局部变量表的最大容量。<br />
局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，虚拟机规范中并没<br />
有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一<br />
个boolean、 byte、 char、 short、 int、 float、 reference或returnAddress类型的数据，这8种数据类<br />
型，都可以使用32位或更小的物理内存来存放，但这种描述与明确指出“每个Slot占用32位长<br />
度的内存空间”是有一些差别的，它允许Slot的长度可以随着处理器、 操作系统或虚拟机的不<br />
同而发生变化。 只要保证即使在64位虚拟机中使用了64位的物理内存空间去实现一个Slot，<br />
虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。<br />
既然前面提到了Java虚拟机的数据类型，在此再简单介绍一下它们。 一个Slot可以存放<br />
一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、 byte、 char、 short、<br />
int、 float、 reference[3]和returnAddress 8种类型。 前面6种不需要多加解释，读者可以按照Java<br />
语言中对应数据类型的概念去理解它们（仅是这样理解而已，Java语言与Java虚拟机中的基<br />
本数据类型是存在本质差别的），而第7种reference类型表示对一个对象实例的引用，虚拟机<br />
规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。 但一般来说，虚拟机<br />
实现至少都应当能通过这个引用做到两点，一是从此引用中直接或间接地查找到对象在Java<br />
堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方<br />
法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束约束[4]。 第8种即<br />
returnAddress类型目前已经很少见了，它是为字节码指令jsr、 jsr_w和ret服务的，指向了一条<br />
字节码指令的地址，很古老的Java虚拟机曾经使用这几条指令来实现异常处理，现在已经由<br />
异常表代替。<br />
对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。 Java<br />
语言中明确的（reference类型则可能是32位也可能是64位）64位的数据类型只有long和double<br />
两种。 值得一提的是，这里把long和double数据类型分割存储的做法与“long和double的非原<br />
子性协定”中把一次long和double数据类型读写分割为两次32位读写的做法有些类似，读者阅<br />
读到Java内存模型时可以互相对比一下。 不过，由于局部变量表建立在线程的堆栈上，是线<br />
程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题[5]。<br />
虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最<br />
大的Slot数量。 如果访问的是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64<br />
位数据类型的变量，则说明会同时使用n和n+1两个Slot。 对于两个相邻的共同存放一个64位<br />
数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求<br />
了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。<br />
在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如<br />
果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方<br />
法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。 其余参<br />
数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体<br />
内部定义的变量顺序和作用域分配其余的Slot。<br />
为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，<br />
其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的<br />
作用域，那这个变量对应的Slot就可以交给其他变量使用。 不过，这样的设计除了节省栈帧<br />
空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接影响到系<br />
统的垃圾收集行为，请看代码清单8-1～代码清单8-3的3个演示。<br />
代码清单8-1 局部变量表Slot复用对垃圾收集的影响之一<br />
public static void main（String[]args）（）{<br />
byte[]placeholder=new byte[64*1024*1024]；<br />
System.gc（）；<br />
} 代<br />
码清单8-1中的代码很简单，即向内存填充了64MB的数据，然后通知虚拟机进行垃圾<br />
收集。 我们在虚拟机运行参数中加上“-verbose：gc”来看看垃圾收集的过程，发现在<br />
System.gc（）运行后并没有回收这64MB的内存，下面是运行的结果：<br />
[GC 66846K-＞65824K（125632K），0.0032678 secs]<br />
[Full GC 65824K-＞65746K（125632K），0.0064131 secs]<br />
没有回收placeholder所占的内存能说得过去，因为在执行System.gc（）时，变量<br />
placeholder还处于作用域之内，虚拟机自然不敢回收placeholder的内存。 那我们把代码修改<br />
一下，变成代码清单8-2中的样子。<br />
代码清单8-2 局部变量表Slot复用对垃圾收集的影响之二<br />
public static void main（String[]args）（）{<br />
{b<br />
yte[]placeholder=new byte[64*1024*1024]；<br />
}S<br />
ystem.gc（）；<br />
} 加<br />
入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执<br />
行System.gc（）的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现<br />
运行结果如下，还是有64MB的内存没有被回收，这又是为什么呢？<br />
[GC 66846K-＞65888K（125632K），0.0009397 secs]<br />
[Full GC 65888K-＞65746K（125632K），0.0051574 secs]<br />
在解释为什么之前，我们先对这段代码进行第二次修改，在调用System.gc（）之前加入<br />
一行“int a=0；”，变成代码清单8-3的样子。<br />
代码清单8-3 局部变量表Slot复用对垃圾收集的影响之三<br />
public static void main（String[]args）（）{<br />
{b<br />
yte[]placeholder=new byte[64*1024*1024]；<br />
}i<br />
nt a=0；<br />
System.gc（）；<br />
}<br />
这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了。<br />
[GC 66401K-＞65778K（125632K），0.0035471 secs]<br />
[Full GC 65778K-＞218K（125632K），0.0140596 secs]<br />
在代码清单8-1～代码清单8-3中，placeholder能否被回收的根本原因是：局部变量表中<br />
的Slot是否还存有关于placeholder数组对象的引用。 第一次修改中，代码虽然已经离开了<br />
placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所<br />
占用的Slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保持着对<br />
它的关联。 这种关联没有被及时打断，在绝大部分情况下影响都很轻微。 但如果遇到一个方<br />
法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、 实际上已经不<br />
会再使用的变量，手动将其设置为null值（用来代替那句int a=0，把变量对应的局部变量表<br />
Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象<br />
占用内存大、 此方法的栈帧长时间不能被回收、 方法调用次数达不到JIT的编译条件）下<br />
的“奇技”来使用。 Java语言的一本非常著名的书籍《 Practical Java》 中把“不使用的对象应手<br />
动赋值为null”作为一条推荐的编码规则，但是并没有解释具体的原因，很长时间之内都有读<br />
者对这条规则感到疑惑。<br />
虽然代码清单8-1～代码清单8-3的代码示例说明了赋null值的操作在某些情况下确实是有<br />
用的，但笔者的观点是不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普<br />
遍的编码规则来推广。 原因有两点，从编码角度讲，以恰当的变量作用域来控制变量回收时<br />
间才是最优雅的解决方法，如代码清单8-3那样的场景并不多见。 更关键的是，从执行角度<br />
讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上<br />
的，在第6章介绍完字节码后，笔者专门增加了一个6.5节“公有设计、 私有实现”来强调概念<br />
模型与实际执行过程是外部看起来等效，内部看上去则可以完全不同。 在虚拟机使用解释器<br />
执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方<br />
式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有<br />
意义的。 字节码被编译为本地代码后，对GC Roots的枚举也与解释执行时期有巨大差别，以<br />
前面例子来看，代码清单8-2在经过JIT编译后，System.gc（）执行时就可以正确地回收掉内<br />
存，无须写成代码清单8-3的样子。<br />
关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的<br />
类变量那样存在“准备阶段”。 通过第7章的讲解，我们已经知道类变量有两次赋初始值的过<br />
程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始<br />
值。 因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确<br />
定的初始值。 但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用<br />
的，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样<br />
的默认值。 如代码清单8-4所示，这段代码其实并不能运行，还好编译器能在编译期间就检<br />
查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字<br />
节码校验的时候也会被虚拟机发现而导致类加载失败。<br />
代码清单8-4 未赋值的局部变量<br />
public static void main（String[]args）{<br />
int a；<br />
System.out.println（a）；<br />
}<br />
[1]详细内容请参见2.2节的相关内容。<br />
[2]详细内容请参见6.3.7节的相关内容。<br />
[3]Java虚拟机规范中没有明确规定reference类型的长度，它的长度与实际使用32还是64位虚<br />
拟机有关，如果是64位虚拟机，还与是否开启某些对象指针压缩的优化有关，这里暂且只取<br />
32位虚拟机的reference长度。<br />
[4]并不是所有语言的对象引用都能满足这两点，例如C++语言，默认情况下（不开启RTTI支<br />
持的情况），就只能满足第一点，而不满足第二点。 这也是为何C++中提供Java语言里很常<br />
见的反射的根本原因。<br />
[5]这是Java内存模型中定义的内容，关于原子操作与“long和double的非原子性协定”等问<br />
题，将在本书第12章中详细讲解。<br />
8.2.2 操作数栈<br />
操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First<br />
Out,LIFO）栈。 同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的<br />
max_stacks数据项中。 操作数栈的每一个元素可以是任意的Java数据类型，包括long和<br />
double。 32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。 在方法执行的任<br />
何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。<br />
当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，<br />
会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。 例如，在做算<br />
术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进<br />
行参数传递的。<br />
举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素<br />
已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加<br />
的结果入栈。<br />
操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时<br />
候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。 再以上<br />
面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据<br />
类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。<br />
另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。 但在大多虚<br />
拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。 让下面栈帧的部分操作数<br />
栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数<br />
据，无须进行额外的参数复制传递，重叠的过程如图8-2所示。<br />
图 8-2 两个栈帧之间的数据共享<br />
Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。<br />
本章稍后会对基于栈的代码过程进行更详细的讲解。<br />
8.2.3 动态连接<br />
每个栈帧都包含一个指向运行时常量池[1]中该栈帧所属方法的引用，持有这个引用是为<br />
了支持方法调用过程中的动态连接（Dynamic Linking）。 通过第6章的讲解，我们知道Class<br />
文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符<br />
号引用作为参数。 这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接<br />
引用，这种转化称为静态解析。 另外一部分将在每一次运行期间转化为直接引用，这部分称<br />
为动态连接。 关于这两个转化过程的详细信息，将在8.3节中详细讲解。<br />
[1]运行时常量池可参考第2章。<br />
8.2.4 方法返回地址<br />
当一个方法开始执行后，只有两种方式可以退出这个方法。 第一种方式是执行引擎遇到<br />
任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当<br />
前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来<br />
决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。<br />
另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得<br />
到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异<br />
常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出<br />
方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。 一个方法使用异常<br />
完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。<br />
无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能<br />
继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行<br />
状态。 一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可<br />
能会保存这个计数器值。 而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈<br />
帧中一般不会保存这部分信息。<br />
方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复<br />
上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈<br />
中，调整PC计数器的值以指向方法调用指令后面的一条指令等。<br />
8.2.5 附加信息<br />
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与<br />
调试相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。 在实际开发<br />
中，一般会把动态连接、 方法返回地址与其他附加信息全部归为一类，称为栈帧信息。<br />
8.3 方法调用<br />
方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本<br />
（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。 在程序运行时，进行方法<br />
调用是最普遍、 最频繁的操作，但前面已经讲过，Class文件的编译过程中不包含传统编译中<br />
的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行<br />
时内存布局中的入口地址（相当于之前说的直接引用）。 这个特性给Java带来了更强大的动<br />
态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运<br />
行期间才能确定目标方法的直接引用。<br />
8.3.1 解析<br />
继续前面关于方法调用的话题，所有方法调用中的目标方法在Class文件里面都是一个常<br />
量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这<br />
种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方<br />
法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、 编译器进行编<br />
译时就必须确定下来。 这类方法的调用称为解析（Resolution）。<br />
在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和<br />
私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决<br />
定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解<br />
析。<br />
与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。<br />
invokestatic：调用静态方法。<br />
invokespecial：调用实例构造器＜init＞方法、 私有方法和父类方法。<br />
invokevirtual：调用所有的虚方法。<br />
invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。<br />
invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方<br />
法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令<br />
的分派逻辑是由用户所设定的引导方法决定的。<br />
只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的<br />
调用版本，符合这个条件的有静态方法、 私有方法、 实例构造器、 父类方法4类，它们在类<br />
加载的时候就会把符号引用解析为该方法的直接引用。 这些方法可以称为非虚方法，与之相<br />
反，其他方法称为虚方法（除去final方法，后文会提到）。 代码清单8-5演示了一个最常见的<br />
解析调用的例子，此样例中，静态方法sayHello（）只可能属于类型StaticResolution，没有任<br />
何手段可以覆盖或隐藏这个方法。<br />
代码清单8-5 方法静态解析演示<br />
/**<br />
*方法静态解析演示<br />
**<br />
@author zzm<br />
*/<br />
public class StaticResolution{<br />
public static void sayHello（）{<br />
System.out.println（"hello world"）；<br />
}p<br />
ublic static void main（String[]args）{<br />
StaticResolution.sayHello（）；<br />
}} 使<br />
用javap命令查看这段程序的字节码，会发现的确是通过invokestatic命令来调用<br />
sayHello（）方法的。<br />
D：\Develop\＞javap-verbose StaticResolution<br />
public static void main（java.lang.String[]）；<br />
Code：<br />
Stack=0，Locals=1，Args_size=1<br />
0：invokestatic#31；//Method sayHello：（）V<br />
3：return<br />
LineNumberTable：<br />
line 15：0<br />
line 16：3<br />
Java中的非虚方法除了使用invokestatic、 invokespecial调用的方法之外还有一种，就是被<br />
final修饰的方法。 虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，<br />
没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯<br />
一的。 在Java语言规范中明确说明了final方法是一种非虚方法。<br />
解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉<br />
及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。 而分派<br />
（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数[1]可分为单分派和<br />
多分派。 这两类分派方式的两两组合就构成了静态单分派、 静态多分派、 动态单分派、 动态<br />
多分派4种分派组合情况，下面我们再看看虚拟机中的方法分派是如何进行的。<br />
[1]这里涉及的分派的相关概念（如“宗量”等）在后文中都会有所解释。<br />
8.3.2 分派<br />
众所周知，Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征：继<br />
承、 封装和多态。 本节讲解的分派调用过程将会揭示多态性特征的一些最基本的体现，<br />
如“重载”和“重写”在Java虚拟机之中是如何实现的，这里的实现当然不是语法上该如何写，<br />
我们关心的依然是虚拟机如何确定正确的目标方法。<br />
1.静态分派<br />
在开始讲解静态分派[1]前，笔者准备了一段经常出现在面试题中的程序代码，读者不妨<br />
先看一遍，想一下程序的输出结果是什么。 后面我们的话题将围绕这个类的方法来重载<br />
（Overload）代码，以分析虚拟机和编译器确定方法版本的过程。 方法静态分派如代码清单<br />
8-6所示。<br />
代码清单8-6 方法静态分派演示<br />
package org.fenixsoft.polymorphic；<br />
/**<br />
*方法静态分派演示<br />
*@author zzm<br />
*/<br />
public class StaticDispatch{<br />
static abstract class Human{<br />
}s<br />
tatic class Man extends Human{<br />
}s<br />
tatic class Woman extends Human{<br />
}p<br />
ublic void sayHello（Human guy）{<br />
System.out.println（"hello,guy！"）；<br />
}p<br />
ublic void sayHello（Man guy）{<br />
System.out.println（"hello,gentleman！"）；<br />
}p<br />
ublic void sayHello（Woman guy）{<br />
System.out.println（"hello,lady！"）；<br />
}p<br />
ublic static void main（String[]args）{<br />
Human man=new Man（）；<br />
Human woman=new Woman（）；<br />
StaticDispatch sr=new StaticDispatch（）；<br />
sr.sayHello（man）；<br />
sr.sayHello（woman）；<br />
}} 运<br />
行结果：<br />
hello,guy！<br />
hello,guy！<br />
代码清单8-6中的代码实际上是在考验阅读者对重载的理解程度，相信对Java编程稍有经<br />
验的程序员看完程序后都能得出正确的运行结果，但为什么会选择执行参数类型为Human的<br />
重载呢？在解决这个问题之前，我们先按如下代码定义两个重要的概念。<br />
Human man=new Man（）；<br />
我们把上面代码中的“Human”称为变量的静态类型（Static Type），或者叫做的外观类型<br />
（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际<br />
类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的<br />
静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运<br />
行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。 例如下面的<br />
代码：<br />
//实际类型变化<br />
Human man=new Man（）；<br />
man=new Woman（）；<br />
//静态类型变化<br />
sr.sayHello（（Man）man）<br />
sr.sayHello（（Woman）man）<br />
解释了这两个概念，再回到代码清单8-6的样例代码中。 main（）里面的两次<br />
sayHello（）方法调用，在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就<br />
完全取决于传入参数的数量和数据类型。 代码中刻意地定义了两个静态类型相同但实际类型<br />
不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类<br />
型作为判定依据的。 并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根<br />
据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标，<br />
并把这个方法的符号引用写到main（）方法里的两条invokevirtual指令的参数中。<br />
所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 静态分派的典型应用<br />
是方法重载。 静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执<br />
行的。 另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不<br />
是“唯一的”，往往只能确定一个“更加合适的”版本。 这种模糊的结论在由0和1构成的计算机<br />
世界中算是比较“稀罕”的事情，产生这种模糊结论的主要原因是字面量不需要定义，所以字<br />
面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。 代码清单8-<br />
7演示了何为“更加合适的”版本。<br />
代码清单8-7 重载方法匹配优先级<br />
package org.fenixsoft.polymorphic；<br />
public class Overload{<br />
public static void sayHello（Object arg）{<br />
System.out.println（"hello Object"）；<br />
}p<br />
ublic static void sayHello（int arg）{<br />
System.out.println（"hello int"）；<br />
}p<br />
ublic static void sayHello（long arg）{<br />
System.out.println（"hello long"）；<br />
}p<br />
ublic static void sayHello（Character arg）{<br />
System.out.println（"hello Character"）；<br />
}p<br />
ublic static void sayHello（char arg）{<br />
System.out.println（"hello char"）；<br />
}p<br />
ublic static void sayHello（char……arg）{<br />
System.out.println（"hello char……"）；<br />
}p<br />
ublic static void sayHello（Serializable arg）{<br />
System.out.println（"hello Serializable"）；<br />
}p<br />
ublic static void main（String[]args）{<br />
sayHello（'a'）；<br />
}} 上<br />
面的代码运行后会输出：<br />
hello char<br />
这很好理解，'a'是一个char类型的数据，自然会寻找参数类型为char的重载方法，如果<br />
注释掉sayHello（char arg）方法，那输出会变为：<br />
hello int<br />
这时发生了一次自动类型转换，'a'除了可以代表一个字符串，还可以代表数字97（字<br />
符'a'的Unicode数值为十进制数字97），因此参数类型为int的重载也是合适的。 我们继续注释<br />
掉sayHello（int arg）方法，那输出会变为：<br />
hello long<br />
这时发生了两次自动类型转换，'a'转型为整数97之后，进一步转型为长整数97L，匹配<br />
了参数类型为long的重载。 笔者在代码中没有写其他的类型如float、 double等的重载，不过实<br />
际上自动转型还能继续发生多次，按照char-＞int-＞long-＞float-＞double的顺序转型进行匹<br />
配。 但不会匹配到byte和short类型的重载，因为char到byte或short的转型是不安全的。 我们继<br />
续注释掉sayHello（long arg）方法，那输出会变为：<br />
hello Character<br />
这时发生了一次自动装箱，'a'被包装为它的封装类型java.lang.Character，所以匹配到了<br />
参数类型为Character的重载，继续注释掉sayHello（Character arg）方法，那输出会变为：<br />
hello Serializable<br />
这个输出可能会让人感觉摸不着头脑，一个字符或数字与序列化有什么关系？出现hello<br />
Serializable，是因为java.lang.Serializable是java.lang.Character类实现的一个接口，当自动装箱<br />
之后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生一次<br />
自动转型。 char可以转型成int，但是Character是绝对不会转型为Integer的，它只能安全地转<br />
型为它实现的接口或父类。 Character还实现了另外一个接口java.lang.Comparable＜Character<br />
＞，如果同时出现两个参数分别为Serializable和Comparable＜Character＞的重载方法，那它<br />
们在此时的优先级是一样的。 编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒<br />
绝编译。 程序必须在调用时显式地指定字面量的静态类型，如：sayHello（（Comparable＜<br />
Character＞）'a'），才能编译通过。 下面继续注释掉sayHello（Serializable arg）方法，输出<br />
会变为：<br />
hello Object<br />
这时是char装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜<br />
索，越接近上层的优先级越低。 即使方法调用传入的参数值为null时，这个规则仍然适用。<br />
我们把sayHello（Object arg）也注释掉，输出将会变为：<br />
hello char……<br />
7个重载方法已经被注释得只剩一个了，可见变长参数的重载优先级是最低的，这时候<br />
字符'a'被当做了一个数组元素。 笔者使用的是char类型的变长参数，读者在验证时还可以选<br />
择int类型、 Character类型、 Object类型等的变长参数重载来把上面的过程重新演示一遍。 但<br />
要注意的是，有一些在单个参数中能成立的自动转型，如char转型为int，在变长参数中是不<br />
成立的[2]。<br />
代码清单8-7演示了编译期间选择静态分派目标的过程，这个过程也是Java语言实现方法<br />
重载的本质。 演示所用的这段程序属于很极端的例子，除了用做面试题为难求职者以外，在<br />
实际工作中几乎不可能有实际用途。 笔者拿来做演示仅仅是用于讲解重载时目标方法选择的<br />
过程，大部分情况下进行这样极端的重载都可算是真正的“关于茴香豆的茴有几种写法的研<br />
究”。 无论对重载的认识有多么深刻，一个合格的程序员都不应该在实际应用中写出如此极<br />
端的重载代码。<br />
另外还有一点读者可能比较容易混淆：笔者讲述的解析与分派这两者之间的关系并不是<br />
二选一的排他关系，它们是在不同层次上去筛选、 确定目标方法的过程。 例如，前面说过，<br />
静态方法会在类加载期就进行解析，而静态方法显然也是可以拥有重载版本的，选择重载版<br />
本的过程也是通过静态分派完成的。<br />
2.动态分派<br />
了解了静态分派，我们接下来看一下动态分派的过程，它和多态性的另外一个重要体<br />
现[3]——重写（Override）有着很密切的关联。 我们还是用前面的Man和Woman一起sayHello<br />
的例子来讲解动态分派，请看代码清单8-8中所示的代码。<br />
代码清单8-8 方法动态分派演示<br />
package org.fenixsoft.polymorphic；<br />
/**<br />
*方法动态分派演示<br />
*@author zzm<br />
*/<br />
public class DynamicDispatch{<br />
static abstract class Human{<br />
protected abstract void sayHello（）；<br />
}s<br />
tatic class Man extends Human{<br />
@Override<br />
protected void sayHello（）{<br />
System.out.println（"man say hello"）；<br />
}}s<br />
tatic class Woman extends Human{<br />
@Override<br />
protected void sayHello（）{<br />
System.out.println（"woman say hello"）；<br />
}}p<br />
ublic static void main（String[]args）{<br />
Human man=new Man（）；<br />
Human woman=new Woman（）；<br />
man.sayHello（）；<br />
woman.sayHello（）；<br />
man=new Woman（）；<br />
man.sayHello（）；<br />
}} 运<br />
行结果：<br />
man say hello<br />
woman say hello<br />
woman say hello<br />
这个运行结果相信不会出乎任何人的意料，对于习惯了面向对象思维的Java程序员会觉<br />
得这是完全理所当然的。 现在的问题还是和前面的一样，虚拟机是如何知道要调用哪个方法<br />
的？<br />
显然这里不可能再根据静态类型来决定，因为静态类型同样都是Human的两个变量man<br />
和woman在调用sayHello（）方法时执行了不同的行为，并且变量man在两次调用中执行了不<br />
同的方法。 导致这个现象的原因很明显，是这两个变量的实际类型不同，Java虚拟机是如何<br />
根据实际类型来分派方法执行版本的呢？我们使用javap命令输出这段代码的字节码，尝试从<br />
中寻找答案，输出结果如代码清单8-9所示。<br />
代码清单8-9 main（）方法的字节码<br />
public static void main（java.lang.String[]）；<br />
Code：<br />
Stack=2，Locals=3，Args_size=1<br />
0：new#16；//class org/fenixsoft/polymorphic/DynamicDispatch $Man<br />
3：dup<br />
4：invokespecial#18；//Method org/fenixsoft/polymorphic/DynamicDispatch $Man."＜init＞"：（）V<br />
7：astore_1<br />
8：new#19；//class org/fenixsoft/polymorphic/DynamicDispatch $Woman<br />
11：dup<br />
12：invokespecial#21；//Method org/fenixsoft/polymorphic/DynamicDispa<br />
tch $Woman."＜init＞"：（）V<br />
15：astore_2<br />
16：aload_1<br />
17：invokevirtual#22；//Method org/fenixsoft/polymorphic/DynamicDispatch $Human.sayHello：（）V<br />
20：aload_2<br />
21：invokevirtual#22；//Method org/fenixsoft/polymorphic/DynamicDispatch $Human.sayHello：（）V<br />
24：new#19；//class org/fenixsoft/polymorphic/DynamicDispatch $Woman<br />
27：dup<br />
28：invokespecial#21；//Method org/fenixsoft/polymorphic/Dynam<br />
icDispatch $Woman."＜init＞"：（）V<br />
31：astore_1<br />
32：aload_1<br />
33：invokevirtual#22；//Method org/fenixsoft/polymorphic/<br />
DynamicDispatch $Human.sayHello：（）V<br />
36：return<br />
0～15行的字节码是准备动作，作用是建立man和woman的内存空间、 调用Man和Woman<br />
类型的实例构造器，将这两个实例的引用存放在第1、 2个局部变量表Slot之中，这个动作也<br />
就对应了代码中的这两句：<br />
Human man=new Man（）；<br />
Human woman=new Woman（）；<br />
接下来的16～21句是关键部分，16、 20两句分别把刚刚创建的两个对象的引用压到栈<br />
顶，这两个对象是将要执行的sayHello（）方法的所有者，称为接收者（Receiver）；17和21<br />
句是方法调用指令，这两条调用指令单从字节码角度来看，无论是指令（都是<br />
invokevirtual）还是参数（都是常量池中第22项的常量，注释显示了这个常量是<br />
Human.sayHello（）的符号引用）完全一样的，但是这两句指令最终执行的目标方法并不相<br />
同。 原因就需要从invokevirtual指令的多态查找过程开始说起，invokevirtual指令的运行时解<br />
析过程大致分为以下几个步骤：<br />
1）找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。<br />
2）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校<br />
验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回<br />
java.lang.IllegalAccessError异常。<br />
3）否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。<br />
4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。<br />
由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调<br />
用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过<br />
程就是Java语言中方法重写的本质。 我们把这种在运行期根据实际类型确定方法执行版本的<br />
分派过程称为动态分派。<br />
3.单分派与多分派<br />
方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于《 Java与模<br />
式》 一书。 根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。 单分派是根<br />
据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。<br />
单分派和多分派的定义读起来拗口，从字面上看也比较抽象，不过对照着实例看就不难<br />
理解了。 代码清单8-10中列举了一个Father和Son一起来做出“一个艰难的决定”的例子。<br />
代码清单8-10 单分派和多分派<br />
/**<br />
*单分派、 多分派演示<br />
*@author zzm<br />
*/<br />
public class Dispatch{<br />
static class QQ{}<br />
static class_360{}<br />
public static class Father{<br />
public void hardChoice（QQ arg）{<br />
System.out.println（"father choose qq"）；<br />
}p<br />
ublic void hardChoice（_360 arg）{<br />
System.out.println（"father choose 360"）；<br />
}}p<br />
ublic static class Son extends Father{<br />
public void hardChoice（QQ arg）{<br />
System.out.println（"son choose qq"）；<br />
}p<br />
ublic void hardChoice（_360 arg）{<br />
System.out.println（"son choose 360"）；<br />
}}p<br />
ublic static void main（String[]args）{<br />
Father father=new Father（）；<br />
Father son=new Son（）；<br />
father.hardChoice（new_360（））；<br />
son.hardChoice（new QQ（））；<br />
}} 运<br />
行结果：<br />
father choose 360<br />
son choose qq<br />
在main函数中调用了两次hardChoice（）方法，这两次hardChoice（）方法的选择结果在<br />
程序输出中已经显示得很清楚了。<br />
我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。 这时选择目标方法的<br />
依据有两点：一是静态类型是Father还是Son，二是方法参数是QQ还是360。 这次选择结果的<br />
最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向<br />
Father.hardChoice（360）及Father.hardChoice（QQ）方法的符号引用。 因为是根据两个宗量<br />
进行选择，所以Java语言的静态分派属于多分派类型。<br />
再看看运行阶段虚拟机的选择，也就是动态分派的过程。 在执行“son.hardChoice（new<br />
QQ（））”这句代码时，更准确地说，是在执行这句代码所对应的invokevirtual指令时，由于<br />
编译期已经决定目标方法的签名必须为hardChoice（QQ），虚拟机此时不会关心传递过来的<br />
参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、 实际类型都对方法的<br />
选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是<br />
Father还是Son。 因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类<br />
型。<br />
根据上述论证的结果，我们可以总结一句：今天（直至还未发布的Java 1.8）的Java语言<br />
是一门静态多分派、 动态单分派的语言。 强调“今天的Java语言”是因为这个结论未必会恒久<br />
不变，C#在3.0及之前的版本与Java一样是动态单分派语言，但在C#4.0中引入了dynamic类型<br />
后，就可以很方便地实现动态多分派。<br />
按照目前Java语言的发展趋势，它并没有直接变为动态语言的迹象，而是通过内置动态<br />
语言（如JavaScript）执行引擎的方式来满足动态性的需求。 但是Java虚拟机层面上则不是如<br />
此，在JDK 1.7中实现的JSR-292[4]里面就已经开始提供对动态语言的支持了，JDK 1.7中新增<br />
的invokedynamic指令也成为了最复杂的一条方法调用的字节码指令，稍后笔者将专门讲解这<br />
个JDK 1.7的新特性。<br />
4.虚拟机动态分派的实现<br />
前面介绍的分派过程，作为对虚拟机概念模型的解析基本上已经足够了，它已经解决了<br />
虚拟机在分派中“会做什么”这个问题。 但是虚拟机“具体是如何做到的”，可能各种虚拟机的<br />
实现都会有些差别。<br />
由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的<br />
方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实<br />
现都不会真正地进行如此频繁的搜索。 面对这种情况，最常用的“稳定优化”手段就是为类在<br />
方法区中建立一个虚方法表（Vritual Method Table，也称为vtable，与此对应的，在<br />
invokeinterface执行时也会用到接口方法表——Inteface Method Table，简称itable），使用虚<br />
方法表索引来代替元数据查找以提高性能。 我们先看看代码清单8-10所对应的虚方法表结构<br />
示例，如图8-3所示。<br />
图 8-3 方法表结构<br />
虚方法表中存放着各个方法的实际入口地址。 如果某个方法在子类中没有被重写，那子<br />
类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入<br />
口。 如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口<br />
地址。 图8-3中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数<br />
据的箭头。 但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从<br />
Object继承来的方法都指向了Object的数据类型。<br />
为了程序实现上的方便，具有相同签名的方法，在父类、 子类的虚方法表中都应当具有<br />
一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表<br />
中按索引转换出所需的入口地址。<br />
方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该<br />
类的方法表也初始化完毕。<br />
上文中笔者说方法表是分派调用的“稳定优化”手段，虚拟机除了使用方法表之外，在条<br />
件允许的情况下，还会使用内联缓存（Inline Cache）和基于“类型继承关系分析”（Class<br />
Hierarchy Analysis,CHA）技术的守护内联（Guarded Inlining）两种非稳定的“激进优化”手段<br />
来获得更高的性能，关于这两种优化技术的原理和运作过程，读者可以参考本书第11章中的<br />
相关内容。<br />
[1]严格来说，Dispatch这个词一般不用在静态环境之中，英文技术文档的称呼是“Method<br />
Overload Resolution”，但国内的各种资料都普遍将这种行为翻译成“静态分派”，特此说明。<br />
[2]重载中选择最合适方法的过程，可参见Java语言规范的§15.12.2.5 Choosing the Most<br />
Specific Method章节。<br />
[3]有一种观点认为：因为重载是静态的，重写是动态的，所以只有重写算是多态性的体现，<br />
重载不算多态。 笔者认为这种争论没有意义，概念仅仅是说明问题的一种工具而已。<br />
[4]JSR-292：Supporting Dynamically Typed Languages on the Java Platform（Java平台的动态语<br />
言支持）。<br />
8.3.3 动态类型语言支持<br />
Java虚拟机的字节码指令集的数量从Sun公司的第一款Java虚拟机问世至JDK 7来临之前<br />
的十余年时间里，一直没有发生任何变化。 随着JDK 7的发布，字节码指令集终于迎来了第<br />
一位新成员——invokedynamic指令。 这条新增加的指令是JDK 7实现“动态类型语<br />
言”（Dynamically Typed Language）支持而进行的改进之一，也是为JDK 8可以顺利实现<br />
Lambda表达式做技术准备。 在本节中，我们将详细讲解JDK 7这项新特性出现的前因后果和<br />
它的深远意义。<br />
1.动态类型语言<br />
在介绍Java虚拟机的动态类型语言支持之前，我们要先弄明白动态类型语言是什么？它<br />
与Java语言、 Java虚拟机有什么关系？了解JDK 1.7提供动态类型语言支持的技术背景，对理<br />
解这个语言特性是很有必要的。<br />
什么是动态类型语言[1]？动态类型语言的关键特征是它的类型检查的主体过程是在运行<br />
期而不是编译期，满足这个特征的语言有很多，常用的包括：APL、 Clojure、 Erlang、<br />
Groovy、 JavaScript、 Jython、 Lisp、 Lua、 PHP、 Prolog、 Python、 Ruby、 Smalltalk和Tcl等。 相<br />
对的，在编译期就进行类型检查过程的语言（如C++和Java等）就是最常用的静态类型语<br />
言。<br />
觉得上面定义过于概念化？那我们不妨通过两个例子以最浅显的方式来说明什么是“在<br />
编译期/运行期进行”和什么是“类型检查”。 首先看下面这段简单的Java代码，它是否能正常<br />
编译和运行？<br />
public static void main（String[]args）{<br />
int[][][]array=new int[1][0][-1]；<br />
} 这<br />
段代码能够正常编译，但运行的时候会报NegativeArraySizeException异常。 在Java虚<br />
拟机规范中明确规定了NegativeArraySizeException是一个运行时异常，通俗一点来说，运行<br />
时异常就是只要代码不运行到这一行就不会有问题。 与运行时异常相对应的是连接时异常，<br />
例如很常见的NoClassDefFoundError便属于连接时异常，即使会导致连接时异常的代码放在<br />
一条无法执行到的分支路径上，类加载时（Java的连接过程不在编译阶段，而在类加载阶<br />
段）也照样会抛出异常。<br />
不过，在C语言中，含义相同的代码会在编译期报错：<br />
int main（void）{<br />
int i[1][0][-1]；//GCC拒绝编译，报“size of array is negative”<br />
return 0；<br />
} 由<br />
此看来，一门语言的哪一种检查行为要在运行期进行，哪一种检查要在编译期进行并<br />
没有必然的因果逻辑关系，关键是语言规范中人为规定的。 再举一个例子来解释“类型检<br />
查”，例如下面这一句非常简单的代码：<br />
obj.println（"hello world"）；<br />
虽然每个人都能看懂这行代码要做什么，但对于计算机来说，这一行代码“没头没尾”是<br />
无法执行的，它需要一个具体的上下文才有讨论的意义。<br />
现在假设这行代码是在Java语言中，并且变量obj的静态类型为java.io.PrintStream，那变<br />
量obj的实际类型就必须是PrintStream的子类（实现了PrintStream接口的类）才是合法的。 否<br />
则，哪怕obj属于一个确实有用println（String）方法，但与PrintStream接口没有继承关系，代<br />
码依然不可能运行——因为类型检查不合法。<br />
但是相同的代码在ECMAScript（JavaScript）中情况则不一样，无论obj具体是何种类<br />
型，只要这种类型的定义中确实包含有println（String）方法，那方法调用便可成功。<br />
这种差别产生的原因是Java语言在编译期间已将println（String）方法完整的符号引用<br />
（本例中为一个CONSTANT_InterfaceMethodref_info常量）生成出来，作为方法调用指令的<br />
参数存储到Class文件中，例如下面这段代码：<br />
invokevirtual#4；//Method java/io/PrintStream.println：（Ljava/lang/String；）V<br />
这个符号引用包含了此方法定义在哪个具体类型之中、 方法的名字以及参数顺序、 参数<br />
类型和方法返回值等信息，通过这个符号引用，虚拟机可以翻译出这个方法的直接引用。 而<br />
在ECMAScript等动态类型语言中，变量obj本身是没有类型的，变量obj的值才具有类型，编<br />
译时最多只能确定方法名称、 参数、 返回值这些信息，而不会去确定方法所在的具体类型<br />
（即方法接收者不固定）。 “变量无类型而变量值才有类型”这个特点也是动态类型语言的一<br />
个重要特征。<br />
了解了动态和静态类型语言的区别后，也许读者的下一个问题就是动态、 静态类型语言<br />
两者谁更好，或者谁更加先进？这种比较不会有确切答案，因为它们都有自己的优点，选择<br />
哪种语言是需要经过权衡的。 静态类型语言在编译期确定类型，最显著的好处是编译器可以<br />
提供严谨的类型检查，这样与类型相关的问题能在编码的时候就及时发现，利于稳定性及代<br />
码达到更大规模。 而动态类型语言在运行期确定类型，这可以为开发人员提供更大的灵活<br />
性，某些在静态类型语言中需用大量“臃肿”代码来实现的功能，由动态类型语言来实现可能<br />
会更加清晰和简洁，清晰和简洁通常也就意味着开发效率的提升。<br />
2.JDK 1.7与动态类型<br />
回到本节的主题，来看看Java语言、 虚拟机与动态类型语言之间有什么关系。 Java虚拟<br />
机毫无疑问是Java语言的运行平台，但它的使命并不仅限于此，早在1997年出版的《 Java虚<br />
拟机规范》 中就规划了这样一个愿景：“在未来，我们会对Java虚拟机进行适当的扩展，以<br />
便更好地支持其他语言运行于Java虚拟机之上”。 而目前确实已经有许多动态类型语言运行<br />
于Java虚拟机之上了，如Clojure、 Groovy、 Jython和JRuby等，能够在同一个虚拟机上可以达<br />
到静态类型语言的严谨性与动态类型语言的灵活性，这是一件很美妙的事情。<br />
但遗憾的是，Java虚拟机层面对动态类型语言的支持一直都有所欠缺，主要表现在方法<br />
调用方面：JDK 1.7以前的字节码指令集中，4条方法调用指令（invokevirtual、<br />
invokespecial、 invokestatic、 invokeinterface）的第一个参数都是被调用的方法的符号引用<br />
（CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info常量），前面已经提到<br />
过，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定接收者类型。 这<br />
样，在Java虚拟机上实现的动态类型语言就不得不使用其他方式（如编译时留个占位符类<br />
型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现，这样势必让动态类<br />
型语言实现的复杂度增加，也可能带来额外的性能或者内存开销。 尽管可以利用一些办法<br />
（如Call Site Caching）让这些开销尽量变小，但这种底层问题终归是应当在虚拟机层次上去<br />
解决才最合适，因此在Java虚拟机层面上提供动态类型的直接支持就成为了Java平台的发展<br />
趋势之一，这就是JDK 1.7（JSR-292）中invokedynamic指令以及java.lang.invoke包出现的技术<br />
背景。<br />
3.java.lang.invoke包<br />
JDK 1.7实现了JSR-292，新加入的java.lang.invoke包[2]就是JSR-292的一个重要组成部分，<br />
这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式以外，提供一<br />
种新的动态确定目标方法的机制，称为MethodHandle。 这种表达方式也许不太好懂？那不妨<br />
把MethodHandle与C/C++中的Function Pointer，或者C#里面的Delegate类比一下。 举个例子，<br />
如果我们要实现一个带谓词的排序函数，在C/C++中常用的做法是把谓词定义为函数，用函<br />
数指针把谓词传递到排序方法，如下：<br />
void sort（int list[]，const int size,int（*compare）（int,int））<br />
但Java语言做不到这一点，即没有办法单独地把一个函数作为参数进行传递。 普遍的做<br />
法是设计一个带有compare（）方法的Comparator接口，以实现了这个接口的对象作为参数，<br />
例如Collections.sort（）就是这样定义的：<br />
void sort（List list,Comparator c）<br />
不过，在拥有Method Handle之后，Java语言也可以拥有类似于函数指针或者委托的方法<br />
别名的工具了。 代码清单8-11演示了MethodHandle的基本用途，无论obj是何种类型（临时定<br />
义的ClassA抑或是实现PrintStream接口的实现类System.out），都可以正确地调用到<br />
println（）方法。<br />
代码清单8-11 MethodHandle演示<br />
import static java.lang.invoke.MethodHandles.lookup；<br />
import java.lang.invoke.MethodHandle；<br />
import java.lang.invoke.MethodType；<br />
/**<br />
*JSR-292 Method Handle基础用法演示<br />
*@author zzm<br />
*/<br />
public class MethodHandleTest{<br />
static class ClassA{<br />
public void println（String s）{<br />
System.out.println（s）；<br />
}}p<br />
ublic static void main（String[]args）throws Throwable{<br />
Object obj=System.currentTimeMillis（）%2==0?System.out：new ClassA（）；<br />
/*无论obj最终是哪个实现类，下面这句都能正确调用到println方法<br />
getPrintlnMH（obj）.invokeExact（"icyfenix"）；<br />
}p<br />
rivate static MethodHandle getPrintlnMH（Object reveiver）throws Throwable{<br />
/*MethodType：代表“方法类型”，包含了方法的返回值（methodType（）的第一个参数）和具体参数（methodType（）第二个及以后的参数）*/<br />
MethodType mt=MethodType.methodType（void.class,String.class）；<br />
/*lookup（）方法来自于MethodHandles.lookup，这句的作用是在指定类中查找符合给定的方法名称、 方法类型，并且符合调用权限的方法句柄*/<br />
/*因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，也即是this指向的对象，这个参数以前是放在参数列表中进行传递的，而现在提供了bindTo（）方法来完<br />
成这件事情*/<br />
return lookup（）.findVirtual（reveiver.getClass（），"println"，mt）.bindTo（reveiver）；<br />
}} 实<br />
际上，方法getPrintlnMH（）中模拟了invokevirtual指令的执行过程，只不过它的分派<br />
逻辑并非固化在Class文件的字节码上，而是通过一个具体方法来实现。 而这个方法本身的返<br />
回值（MethodHandle对象），可以视为对最终调用方法的一个“引用”。 以此为基础，有了<br />
MethodHandle就可以写出类似于下面这样的函数声明：<br />
void sort（List list,MethodHandle compare）<br />
从上面的例子可以看出，使用MethodHandle并没有什么困难，不过看完它的用法之后，<br />
读者大概就会产生疑问，相同的事情，用反射不是早就可以实现了吗？<br />
确实，仅站在Java语言的角度来看，MethodHandle的使用方法和效果与Reflection有众多<br />
相似之处，不过，它们还是有以下这些区别：<br />
从本质上讲，Reflection和MethodHandle机制都是在模拟方法调用，但Reflection是在模拟<br />
Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。 在<br />
MethodHandles.lookup中的3个方法——findStatic（）、 findVirtual（）、 findSpecial（）正是<br />
为了对应于invokestatic、 invokevirtual＆invokeinterface和invokespecial这几条字节码指令的执<br />
行权限校验行为，而这些底层细节在使用Reflection API时是不需要关心的。<br />
Reflection中的java.lang.reflect.Method对象远比MethodHandle机制中的<br />
java.lang.invoke.MethodHandle对象所包含的信息多。 前者是方法在Java一端的全面映像，包<br />
含了方法的签名、 描述符以及方法属性表中各种属性的Java端表示方式，还包含执行权限等<br />
的运行期信息。 而后者仅仅包含与执行该方法相关的信息。 用通俗的话来讲，Reflection是重<br />
量级，而MethodHandle是轻量级。<br />
由于MethodHandle是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的<br />
各种优化（如方法内联），在MethodHandle上也应当可以采用类似思路去支持（但目前实现<br />
还不完善）。 而通过反射去调用方法则不行。<br />
MethodHandle与Reflection除了上面列举的区别外，最关键的一点还在于去掉前面讨论施<br />
加的前提“仅站在Java语言的角度来看”：Reflection API的设计目标是只为Java语言服务的，<br />
而MethodHandle则设计成可服务于所有Java虚拟机之上的语言，其中也包括Java语言。<br />
4.invokedynamic指令<br />
本节一开始就提到了JDK 1.7为了更好地支持动态类型语言，引入了第5条方法调用的字<br />
节码指令invokedynamic，之后一直没有再提到它，甚至把代码清单8-11中使用MethodHandle<br />
的示例代码反编译后也不会看见invokedynamic的身影，它的应用之处在哪里呢？<br />
在某种程度上，invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决<br />
原有4条“invoke*”指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定<br />
权从虚拟机转嫁到具体用户代码之中，让用户（包含其他语言的设计者）有更高的自由度。<br />
而且，它们两者的思路也是可类比的，可以把它们想象成为了达成同一个目的，一个采用上<br />
层Java代码和API来实现，另一个用字节码和Class中其他属性、 常量来完成。 因此，如果理<br />
解了前面的MethodHandle例子，那么理解invokedynamic指令也并不困难。<br />
每一处含有invokedynamic指令的位置都称做“动态调用点”（Dynamic Call Site），这条指<br />
令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是变为JDK<br />
1.7新加入的CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：引导<br />
方法（Bootstrap Method，此方法存放在新增的BootstrapMethods属性中）、 方法类型<br />
（MethodType）和名称。 引导方法是有固定的参数，并且返回值是java.lang.invoke.CallSite对<br />
象，这个代表真正要执行的目标方法调用。 根据CONSTANT_InvokeDynamic_info常量中提供<br />
的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行<br />
的目标方法。 我们还是举一个实际的例子来解释这个过程，如代码清单8-12所示。<br />
代码清单8-12 invokedynamic指令演示<br />
import static java.lang.invoke.MethodHandles.lookup；<br />
import java.lang.invoke.CallSite；<br />
import java.lang.invoke.ConstantCallSite；<br />
import java.lang.invoke.MethodHandle；<br />
import java.lang.invoke.MethodHandles；<br />
import java.lang.invoke.MethodType；<br />
public class InvokeDynamicTest{<br />
public static void main（String[]args）throws Throwable{<br />
INDY_BootstrapMethod（）.invokeExact（"icyfenix"）；<br />
}p<br />
ublic static void testMethod（String s）{<br />
System.out.println（"hello String："+s）；<br />
}p<br />
ublic static CallSite BootstrapMethod（MethodHandles.Lookup lookup,String name,MethodType mt）throws Throwable{<br />
return new ConstantCallSite（lookup.findStatic（InvokeDynamicTest.class,name,mt））；<br />
}p<br />
rivate static MethodType MT_BootstrapMethod（）{<br />
return MethodType<br />
.fromMethodDescriptorString（<br />
"（Ljava/lang/invoke/MethodHandles $Lookup；Ljava/lang/String；Ljava/lang/invoke/MethodType；）Ljava/lang/invoke/CallSite；"，<br />
null）；<br />
}p<br />
rivate static MethodHandle MH_BootstrapMethod（）throws Throwable{<br />
return lookup（）.findStatic（InvokeDynamicTest.class，"BootstrapMethod"，MT_BootstrapMethod（））；<br />
}p<br />
rivate static MethodHandle INDY_BootstrapMethod（）throws Throwable{<br />
CallSite cs=（CallSite）MH_BootstrapMethod（）.invokeWithArguments（lookup（），"testMethod"，<br />
MethodType.fromMethodDescriptorString（"（Ljava/lang/String；）V"，null））；<br />
return cs.dynamicInvoker（）；<br />
}} 这<br />
段代码与前面MethodHandleTest的作用基本上是一样的，虽然笔者没有加以注释，但<br />
是阅读起来应当不困难。 本书前面提到过，由于invokedynamic指令所面向的使用者并非Java<br />
语言，而是其他Java虚拟机之上的动态语言，因此仅依靠Java语言的编译器Javac没有办法生<br />
成带有invokedynamic指令的字节码（曾经有一个java.dyn.InvokeDynamic的语法糖可以实现，<br />
但后来被取消了），所以要使用Java语言来演示invokedynamic指令只能用一些变通的办法。<br />
John Rose（Da Vinci Machine Project的Leader）编写了一个把程序的字节码转换为使用<br />
invokedynamic的简单工具INDY[3]来完成这件事情，我们要使用这个工具来产生最终要的字节<br />
码，因此这个示例代码中的方法名称不能随意改动，更不能把几个方法合并到一起写，因为<br />
它们是要被INDY工具读取的。<br />
把上面代码编译、 再使用INDY转换后重新生成的字节码如代码清单8-13所示（结果使<br />
用javap输出，因版面原因，精简了许多无关的内容）。<br />
代码清单8-13 invokedynamic指令演示（2）<br />
Constant pool：<br />
#121=NameAndType#33：#30//testMethod：（Ljava/lang/String；）V<br />
#123=InvokeDynamic#0：#121//#0：testMethod：（Ljava/lang/String；）V<br />
public static void main（java.lang.String[]）throws java.lang.Throwable；<br />
Code：<br />
stack=2，locals=1，args_size=1<br />
0：ldc#23//String abc<br />
2：invokedynamic#123，0//InvokeDynamic#0：testMethod：（Ljava/lang/String；）V<br />
7：nop<br />
8：return<br />
public static java.lang.invoke.CallSite BootstrapMethod（java.lang.invoke.MethodHandles $Lookup,java.lang.String,java.lang.invoke.MethodType）throws<br />
java.lang.Throwable；<br />
Code：<br />
stack=6，locals=3，args_size=3<br />
0：new#63//class java/lang/invoke/ConstantCallSite<br />
3：dup<br />
4：aload_0<br />
5：ldc#1//class org/fenixsoft/InvokeDynamicTest<br />
7：aload_1<br />
8：aload_2<br />
9：invokevirtual#65//Method java/lang/invoke/MethodHandles $Lookup.findStatic：（Ljava/lang/Class；Ljava/lang/String；<br />
Ljava/lang/invoke/MethodType；）Ljava/lang/invoke/MethodHandle；<br />
12：invokespecial#71//Method java/lang/invoke/ConstantCallSite."＜in it＞"：（Ljava/lang/invoke/MethodHandle；）V<br />
15：areturn<br />
从main（）方法的字节码可见，原本的方法调用指令已经替换为invokedynamic，它的参<br />
数为第123项常量（第二个值为0的参数在HotSpot中用不到，与invokeinterface指令那个值为0<br />
的参数一样都是占位的）。<br />
2：invokedynamic#123，0//InvokeDynamic#0：testMethod：（Ljava/lang/String；）V<br />
从常量池中可见，第123项常量显示“#123=InvokeDynamic#0：#121”说明它是一项<br />
CONSTANT_InvokeDynamic_info类型常量，常量值中前面的“#0”代表引导方法取<br />
BootstrapMethods属性表的第0项（javap没有列出属性表的具体内容，不过示例中仅有一个引<br />
导方法，即BootstrapMethod（）），而后面的“#121”代表引用第121项类型为<br />
CONSTANT_NameAndType_info的常量，从这个常量中可以获取方法名称和描述符，即后面<br />
输出的“testMethod：（Ljava/lang/String；）V”。<br />
再看一下BootstrapMethod（），这个方法Java源码中没有，是INDY产生的，但是它的字<br />
节码很容易读懂，所有逻辑就是调用MethodHandles $Lookup的findStatic（）方法，产生<br />
testMethod（）方法的MethodHandle，然后用它创建一个ConstantCallSite对象。 最后，这个对<br />
象返回给invokedynamic指令实现对testMethod（）方法的调用，invokedynamic指令的调用过<br />
程到此就宣告完成了。<br />
5.掌控方法分派规则<br />
invokedynamic指令与前面4条“invoke*”指令的最大差别就是它的分派逻辑不是由虚拟机<br />
决定的，而是由程序员决定。 在介绍Java虚拟机动态语言支持的最后一个小结中，笔者通过<br />
一个简单例子（如代码清单8-14所示），帮助读者理解程序员在可以掌控方法分派规则之<br />
后，能做什么以前无法做到的事情。<br />
代码清单8-14 方法调用问题<br />
class GrandFather{<br />
void thinking（）{<br />
System.out.println（"i am grandfather"）；<br />
}}c<br />
lass Father extends GrandFather{<br />
void thinking（）{<br />
System.out.println（"i am father"）；<br />
}}c<br />
lass Son extends Father{<br />
void thinking（）{<br />
//请读者在这里填入适当的代码（不能修改其他地方的代码）<br />
//实现调用祖父类的thinking（）方法，打印"i am grandfather"<br />
}} 在<br />
Java程序中，可以通过“super”关键字很方便地调用到父类中的方法，但如果要访问祖<br />
类的方法呢？读者在阅读本书下面提供的解决方案之前，不妨自己思考一下，在JDK 1.7之<br />
前有没有办法解决这个问题。<br />
在JDK 1.7之前，使用纯粹的Java语言很难处理这个问题（直接生成字节码就很简单，如<br />
使用ASM等字节码工具），原因是在Son类的thinking（）方法中无法获取一个实际类型是<br />
GrandFather的对象引用，而invokevirtual指令的分派逻辑就是按照方法接收者的实际类型进行<br />
分派，这个逻辑是固化在虚拟机中的，程序员无法改变。 在JDK 1.7中，可以使用代码清单8-<br />
15中的程序来解决这个问题。<br />
代码清单8-15 使用MethodHandle来解决相关问题<br />
import static java.lang.invoke.MethodHandles.lookup；<br />
import java.lang.invoke.MethodHandle；<br />
import java.lang.invoke.MethodType；<br />
class Test{<br />
class GrandFather{<br />
void thinking（）{<br />
System.out.println（"i am grandfather"）；<br />
}}c<br />
lass Father extends GrandFather{<br />
void thinking（）{<br />
System.out.println（"i am father"）；<br />
}}c<br />
lass Son extends Father{<br />
void thinking（）{<br />
try{<br />
MethodType mt=MethodType.methodType（void.class）；<br />
MethodHandle mh=lookup（）.findSpecial（GrandFather.class，"thinking"，mt,getClass（））；<br />
mh.invoke（this）；<br />
}catch（Throwable e）{<br />
}}}p<br />
ublic static void main（String[]args）{<br />
（new Test（）.new Son（））.thinking（）；<br />
}} 运<br />
行结果：<br />
i am grandfather<br />
[1]注意，动态类型语言与动态语言、 弱类型语言并不是一个概念，需要区别对待。<br />
[2]这个包在很长一段时间里称为java.dyn，也曾经短暂更名为java.lang.mh，如果读者在其他<br />
资料上看到这两个包名，可以把它们理解为java.lang.invoke。<br />
[3]INDY下载地址：http://blogs.oracle.com/jrose/entry/a_modest_tool_for_writing。<br />
8.4 基于栈的字节码解释执行引擎<br />
虚拟机是如何调用方法的内容已经讲解完毕，从本节开始，我们来探讨虚拟机是如何执<br />
行方法中的字节码指令的。 上文中提到过，许多Java虚拟机的执行引擎在执行Java代码的时<br />
候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种<br />
选择，在本章中，我们先来探讨一下在解释执行时，虚拟机执行引擎是如何工作的。<br />
8.4.1 解释执行<br />
Java语言经常被人们定位为“解释执行”的语言，在Java初生的JDK 1.0时代，这种定义还<br />
算是比较准确的，但当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被<br />
解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事情。 再后来，Java也发展<br />
出了可以直接生成本地代码的编译器[如GCJ[1]（GNU Compiler for the Java）]，而C/C++语言<br />
也出现了通过解释器执行的版本（如CINT[2]），这时候再笼统地说“解释执行”，对于整个<br />
Java语言来说就成了几乎是没有意义的概念，只有确定了谈论对象是某种具体的Java实现版<br />
本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。<br />
不论是解释还是编译，也不论是物理机还是虚拟机，对于应用程序，机器都不可能如人<br />
那样阅读、 理解，然后就获得了执行能力。 大部分的程序代码到物理机的目标代码或虚拟机<br />
能执行的指令集之前，都需要经过图8-4中的各个步骤。 如果读者对编译原理的相关课程还<br />
有印象的话，很容易就会发现图8-4中下面那条分支，就是传统编译原理中程序代码到目标<br />
机器代码的生成过程，而中间的那条分支，自然就是解释执行的过程。<br />
如今，基于物理机、 Java虚拟机，或者非Java的其他高级语言虚拟机（HLLVM）的语<br />
言，大多都会遵循这种基于现代经典编译原理的思路，在执行前先对程序源码进行词法分析<br />
和语法分析处理，把源码转化为抽象语法树（Abstract Syntax Tree,AST）。 对于一门具体语<br />
言的实现来说，词法分析、 语法分析以至后面的优化器和目标代码生成器都可以选择独立于<br />
执行引擎，形成一个完整意义的编译器去实现，这类代表是C/C++语言。 也可以选择把其中<br />
一部分步骤（如生成抽象语法树之前的步骤）实现为一个半独立的编译器，这类代表是Java<br />
语言。 又或者把这些步骤和执行引擎全部集中封装在一个封闭的黑匣子之中，如大多数的<br />
JavaScript执行器。<br />
图 8-4 编译过程<br />
Java语言中，Javac编译器完成了程序代码经过词法分析、 语法分析到抽象语法树，再遍<br />
历语法树生成线性的字节码指令流的过程。 因为这一部分动作是在Java虚拟机之外进行的，<br />
而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。<br />
[1]GCJ：http://gcc.gnu.org/java/。<br />
[2]CINT：http://root.cern.ch/drupal/content/cint。<br />
8.4.2 基于栈的指令集与基于寄存器的指令集<br />
Java编译器输出的指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set<br />
Architecture,ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。<br />
与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址<br />
指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄<br />
存器进行工作。 那么，基于栈的指令集与基于寄存器的指令集这两者之间有什么不同呢？<br />
举个最简单的例子，分别使用这两种指令集计算“1+1”的结果，基于栈的指令集会是这<br />
样子的：<br />
iconst_1<br />
iconst_1<br />
iadd<br />
istore_0<br />
两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、 相加，然<br />
后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。<br />
如果基于寄存器，那程序可能会是这个样子：<br />
mov eax，1<br />
add eax，1<br />
mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存<br />
器里面。<br />
了解了基于栈的指令集与基于寄存器的指令集的区别后，读者可能会有进一步的疑问，<br />
这两套指令集谁更好一些呢？<br />
应该这么说，既然两套指令集会同时并存和发展，那肯定是各有优势的，如果有一套指<br />
令集全面优于另外一套的话，就不会存在选择的问题了。<br />
基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供[2]，程序直接依赖这些<br />
硬件寄存器则不可避免地要受到硬件的约束。 例如，现在32位80x86体系的处理器中提供了8<br />
个32位的寄存器，而ARM体系的CPU（在当前的手机、 PDA中相当流行的一种处理器）则提<br />
供了16个32位的通用寄存器。 如果使用栈架构的指令集，用户程序不会直接使用这些寄存<br />
器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、 栈顶缓存等）<br />
放到寄存器中以获取尽量好的性能，这样实现起来也更加简单一些。 栈架构的指令集还有一<br />
些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集<br />
中还需要存放参数）、 编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈<br />
上操作）等。<br />
栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。 所有主流物理机的指令集都<br />
是寄存器架构也从侧面印证了这一点。<br />
虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器<br />
架构多，因为出栈、 入栈操作本身就产生了相当多的指令数量。 更重要的是，栈实现在内存<br />
之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度<br />
的瓶颈。 尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内<br />
存访问，但这也只能是优化措施而不是解决本质问题的方法。 由于指令数量和内存访问的原<br />
因，所以导致了栈架构指令集的执行速度会相对较慢。<br />
[1]使用“基本上”，是因为部分字节码指令会带有参数，而纯粹基于栈的指令集架构中应当全<br />
部都是零地址指令，也就是都不存在显式的参数。 Java这样实现主要是考虑了代码的可校验<br />
性。<br />
[2]这里说的是物理机器上的寄存器，也有基于寄存器的虚拟机，如Google Android平台的<br />
Dalvik VM。 即使是基于寄存器的虚拟机，也希望把虚拟机寄存器尽量映射到物理寄存器上<br />
以获取尽可能高的性能。<br />
8.4.3 基于栈的解释器执行过程<br />
初步的理论知识已经讲解过了，本节准备了一段Java代码，看看在虚拟机中实际是如何<br />
执行的。 前面曾经举过一个计算“1+1”的例子，这样的算术题目显然太过简单了，笔者准备<br />
了四则运算的例子，请看代码清单8-16。<br />
代码清单8-16 一段简单的算术代码<br />
public int calc（）{<br />
int a=100；<br />
int b=200；<br />
int c=300；<br />
return（a+b）*c；<br />
} 从<br />
Java语言的角度来看，这段代码没有任何解释的必要，可以直接使用javap命令看看它<br />
的字节码指令，如代码清单8-17所示。<br />
代码清单8-17 一段简单的算术代码的字节码表示<br />
public int calc（）；<br />
Code：<br />
Stack=2，Locals=4，Args_size=1<br />
0：bipush 100<br />
2：istore_1<br />
3：sipush 200<br />
6：istore_2<br />
7：sipush 300<br />
10：istore_3<br />
11：iload_1<br />
12：iload_2<br />
13：iadd<br />
14：iload_3<br />
15：imul<br />
16：ireturn<br />
} j<br />
avap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，笔者根据这些信<br />
息画了图8-5～图8-11共7张图，用它们来描述代码清单8-17执行过程中的代码、 操作数栈和<br />
局部变量表的变化情况。<br />
图 8-5 执行偏移地址为0的指令的情况<br />
图 8-6 执行偏移地址为1的指令的情况<br />
图 8-7 执行偏移地址为11的指令的情况<br />
图 8-8 执行偏移地址为12的指令的情况<br />
图 8-9 执行偏移地址为13的指令的情况<br />
图 8-10 执行偏移地址为14的指令的情况<br />
图 8-11 执行偏移地址为16的指令的情况<br />
上面的执行过程仅仅是一种概念模型，虚拟机最终会对执行过程做一些优化来提高性<br />
能，实际的运作过程不一定完全符合概念模型的描述……更准确地说，实际情况会和上面描<br />
述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入<br />
的字节码进行优化，例如，在HotSpot虚拟机中，有很多以“fast_”开头的非标准字节码指令用<br />
于合并、 替换输入的字节码以提升解释执行性能，而即时编译器的优化手段更加花样繁<br />
多[1]。<br />
不过，我们从这段程序的执行中也可以看出栈结构指令集的一般运行过程，整个运算过<br />
程的中间变量都以操作数栈的出栈、 入栈为信息交换途径，符合我们在前面分析的特点。<br />
[1]具体可以参考第11章中的相关内容。<br />
8.5 本章小结<br />
本章中，我们分析了虚拟机在执行代码时，如何找到正确的方法、 如何执行方法内的字<br />
节码，以及执行代码时涉及的内存结构。 在第6、 7、 8三章中，我们针对Java程序是如何存<br />
储的、 如何载入（创建）的，以及如何执行的问题把相关知识进行了讲解，第9章我们将一<br />
起看看这些理论知识在具体开发之中的经典应用。<br />
第9章 类加载及执行子系统的案例与实战<br />
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言<br />
发展的一大步。<br />
9.1 概述<br />
在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不太多，Class<br />
文件以何种格式存储，类型何时加载、 如何连接，以及虚拟机如何执行字节码指令等都是由<br />
虚拟机直接控制的行为，用户程序无法对其进行改变。 能通过程序进行操作的，主要是字节<br />
码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣<br />
赏和借鉴的思路，这些思路后来成为了许多常用功能和程序实现的基础。 在本章中，我们将<br />
看一下前面所学的知识在实际开发之中是如何应用的。<br />
9.2 案例分析<br />
在案例分析部分，笔者准备了4个例子，关于类加载器和字节码的案例各有两个。 并且<br />
这两个领域的案例中各有一个案例是大多数Java开发人员都使用过的工具或技术，另外一个<br />
案例虽然不一定每个人都使用过，但却特别精彩地演绎出这个领域中的技术特性。 希望这些<br />
案例能引起读者的思考，并给读者的日常工作带来灵感。<br />
9.2.1 Tomcat：正统的类加载器架构<br />
主流的Java Web服务器，如Tomcat、 Jetty、 WebLogic、 WebSphere或其他笔者没有列举<br />
的服务器，都实现了自己定义的类加载器（一般都不止一个）。 因为一个功能健全的Web服<br />
务器，要解决如下几个问题：<br />
部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离。 这是<br />
最基本的需求，两个不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求一<br />
个类库在一个服务器中只有一份，服务器应当保证两个应用程序的类库可以互相独立使用。<br />
部署在同一个服务器上的两个Web应用程序所使用的Java类库可以互相共享。 这个需求<br />
也很常见，例如，用户可能有10个使用Spring组织的应用程序部署在同一台服务器上，如果<br />
把10份Spring分别存放在各个应用程序的隔离目录中，将会是很大的资源浪费——这主要倒<br />
不是浪费磁盘空间的问题，而是指类库在使用时都要被加载到服务器内存，如果类库不能共<br />
享，虚拟机的方法区就会很容易出现过度膨胀的风险。<br />
服务器需要尽可能地保证自身的安全不受部署的Web应用程序影响。 目前，有许多主流<br />
的Java Web服务器自身也是使用Java语言来实现的。 因此，服务器本身也有类库依赖的问<br />
题，一般来说，基于安全考虑，服务器所使用的类库应该与应用程序的类库互相独立。<br />
支持JSP应用的Web服务器，大多数都需要支持HotSwap功能。 我们知道，JSP文件最终<br />
要编译成Java Class才能由虚拟机执行，但JSP文件由于其纯文本存储的特性，运行时修改的<br />
概率远远大于第三方类库或程序自身的Class文件。 而且ASP、 PHP和JSP这些网页应用也把<br />
修改后无须重启作为一个很大的“优势”来看待，因此“主流”的Web服务器都会支持JSP生成类<br />
的热替换，当然也有“非主流”的，如运行在生产模式（Production Mode）下的WebLogic服务<br />
器默认就不会处理JSP文件的变化。<br />
由于存在上述问题，在部署Web应用时，单独的一个ClassPath就无法满足需求了，所以<br />
各种Web服务器都“不约而同”地提供了好几个ClassPath路径供用户存放第三方类库，这些路<br />
径一般都以“lib”或“classes”命名。 被放置到不同路径中的类库，具备不同的访问范围和服务<br />
对象，通常，每一个目录都会有一个相应的自定义类加载器去加载放置在里面的Java类库。<br />
现在，笔者就以Tomcat服务器[1]为例，看一看Tomcat具体是如何规划用户类库结构和类加载<br />
器的。<br />
在Tomcat目录结构中，有3组目录（“/common/*”、 “/server/*”和“/shared/*”）可以存放<br />
Java类库，另外还可以加上Web应用程序自身的目录“/WEB-INF/*”，一共4组，把Java类库放<br />
置在这些目录中的含义分别如下。<br />
放置在/common目录中：类库可被Tomcat和所有的Web应用程序共同使用。<br />
放置在/server目录中：类库可被Tomcat使用，对所有的Web应用程序都不可见。<br />
放置在/shared目录中：类库可被所有的Web应用程序共同使用，但对Tomcat自己不可<br />
见。<br />
放置在/WebApp/WEB-INF目录中：类库仅仅可以被此Web应用程序使用，对Tomcat和其<br />
他Web应用程序都不可见。<br />
为了支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat自定义了多个类<br />
加载器，这些类加载器按照经典的双亲委派模型来实现，其关系如图9-1所示。<br />
图 9-1 Tomcat服务器的类加载架构<br />
灰色背景的3个类加载器是JDK默认提供的类加载器，这3个加载器的作用在第7章中已<br />
经介绍过了。 而CommonClassLoader、 CatalinaClassLoader、 SharedClassLoader和<br />
WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载/common/*、 /server/*、<br />
/shared/*和/WebApp/WEB-INF/*中的Java类库。 其中WebApp类加载器和Jsp类加载器通常会<br />
存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp<br />
类加载器。<br />
从图9-1的委派关系中可以看出，CommonClassLoader能加载的类都可以被Catalina<br />
ClassLoader和SharedClassLoader使用，而CatalinaClassLoader和SharedClassLoader自己能加载<br />
的类则与对方相互隔离。 WebAppClassLoader可以使用SharedClassLoader加载到的类，但各<br />
个WebAppClassLoader实例之间相互隔离。 而JasperLoader的加载范围仅仅是这个JSP文件所<br />
编译出来的那一个Class，它出现的目的就是为了被丢弃：当服务器检测到JSP文件被修改<br />
时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件<br />
的HotSwap功能。<br />
对于Tomcat的6.x版本，只有指定了tomcat/conf/catalina.properties配置文件的server.loader<br />
和share.loader项后才会真正建立CatalinaClassLoader和SharedClassLoader的实例，否则会用到<br />
这两个类加载器的地方都会用CommonClassLoader的实例代替，而默认的配置文件中没有设<br />
置这两个loader项，所以Tomcat 6.x顺理成章地把/common、 /server和/shared三个目录默认合<br />
并到一起变成一个/lib目录，这个目录里的类库相当于以前/common目录中类库的作用。 这是<br />
Tomcat设计团队为了简化大多数的部署场景所做的一项改进，如果默认设置不能满足需要，<br />
用户可以通过修改配置文件指定server.loader和share.loader的方式重新启用Tomcat 5.x的加载<br />
器架构。<br />
Tomcat加载器的实现清晰易懂，并且采用了官方推荐的“正统”的使用类加载器的方式。<br />
如果读者阅读完上面的案例后，能完全理解Tomcat设计团队这样布置加载器架构的用意，那<br />
说明已经大致掌握了类加载器“主流”的使用方式，那么笔者不妨再提一个问题让读者思考一<br />
下：前面曾经提到过一个场景，如果有10个Web应用程序都是用Spring来进行组织和管理的<br />
话，可以把Spring放到Common或Shared目录下让这些程序共享。 Spring要对用户程序的类进<br />
行管理，自然要能访问到用户程序的类，而用户的程序显然是放在/WebApp/WEB-INF目录中<br />
的，那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问并不在其加载范围<br />
内的用户程序呢？如果读过本书第7章的相关内容，相信读者可以很容易地回答这个问题。<br />
[1]Tomcat是Apache基金会中的一款开源的Java Web服务器，主页地址为：<br />
http://tomcat.apache.org。 本案例中选用的是Tomcat 5.x服务器的目录和类加载器结构，在<br />
Tomcat 6.x的默认配置下，/common、 /server和/shared三个目录已经合并到一起了。<br />
9.2.2 OSGi：灵活的类加载器架构<br />
Java程序社区中流传着这么一个观点：“学习JEE规范，去看JBoss源码；学习类加载器，<br />
就去看OSGi源码”。 尽管“JEE规范”和“类加载器的知识”并不是一个对等的概念，不过，既然<br />
这个观点能在程序员中流传开来，也从侧面说明了OSGi对类加载器的运用确实有其独到之<br />
处。<br />
OSGi[1]（Open Service Gateway Initiative）是OSGi联盟（OSGi Alliance）制定的一个基于<br />
Java语言的动态模块化规范，这个规范最初由Sun、 IBM、 爱立信等公司联合发起，目的是使<br />
服务提供商通过住宅网关为各种家用智能设备提供各种服务，后来这个规范在Java的其他技<br />
术领域也有相当不错的发展，现在已经成为Java世界中“事实上”的模块化标准，并且已经有<br />
了Equinox、 Felix等成熟的实现。 OSGi在Java程序员中最著名的应用案例就是Eclipse IDE，另<br />
外还有许多大型的软件平台和中间件服务器都基于或声明将会基于OSGi规范来实现，如IBM<br />
Jazz平台、 GlassFish服务器、 jBoss OSGi等。<br />
OSGi中的每个模块（称为Bundle）与普通的Java类库区别并不太大，两者一般都以JAR<br />
格式进行封装，并且内部存储的都是Java Package和Class。 但是一个Bundle可以声明它所依<br />
赖的Java Package（通过Import-Package描述），也可以声明它允许导出发布的Java<br />
Package（通过Export-Package描述）。 在OSGi里面，Bundle之间的依赖关系从传统的上层模<br />
块依赖底层模块转变为平级模块之间的依赖（至少外观上如此），而且类库的可见性能得到<br />
非常精确的控制，一个模块里只有被Export过的Package才可能由外界访问，其他的Package和<br />
Class将会隐藏起来。 除了更精确的模块划分和可见性控制外，引入OSGi的另外一个重要理<br />
由是，基于OSGi的程序很可能（只是很可能，并不是一定会）可以实现模块级的热插拔功<br />
能，当程序升级更新或调试除错时，可以只停用、 重新安装然后启用程序的其中一部分，这<br />
对企业级程序开发来说是一个非常有诱惑力的特性。<br />
OSGi之所以能有上述“诱人”的特点，要归功于它灵活的类加载器架构。 OSGi的Bundle类<br />
加载器之间只有规则，没有固定的委派关系。 例如，某个Bundle声明了一个它依赖的<br />
Package，如果有其他Bundle声明发布了这个Package，那么所有对这个Package的类加载动作<br />
都会委派给发布它的Bundle类加载器去完成。 不涉及某个具体的Package时，各个Bundle加载<br />
器都是平级关系，只有具体使用某个Package和Class的时候，才会根据Package导入导出定义<br />
来构造Bundle间的委派和依赖。<br />
另外，一个Bundle类加载器为其他Bundle提供服务时，会根据Export-Package列表严格控<br />
制访问范围。 如果一个类存在于Bundle的类库中但是没有被Export，那么这个Bundle的类加<br />
载器能找到这个类，但不会提供给其他Bundle使用，而且OSGi平台也不会把其他Bundle的类<br />
加载请求分配给这个Bundle来处理。<br />
我们可以举一个更具体一些的简单例子，假设存在Bundle A、 Bundle B、 Bundle C三个模<br />
块，并且这三个Bundle定义的依赖关系如下。<br />
Bundle A：声明发布了packageA，依赖了java.*的包。<br />
Bundle B：声明依赖了packageA和packageC，同时也依赖了java.*的包。<br />
Bundle C：声明发布了packageC，依赖了packageA。<br />
那么，这三个Bundle之间的类加载器及父类加载器之间的关系如图9-2所示。<br />
图 9-2 OSGi的类加载器架构<br />
由于没有牵扯到具体的OSGi实现，所以图9-2中的类加载器都没有指明具体的加载器实<br />
现，只是一个体现了加载器之间关系的概念模型，并且只是体现了OSGi中最简单的加载器<br />
委派关系。 一般来说，在OSGi中，加载一个类可能发生的查找行为和委派关系会比图9-2中<br />
显示的复杂得多，类加载时可能进行的查找规则如下：<br />
以java.*开头的类，委派给父类加载器加载。<br />
否则，委派列表名单内的类，委派给父类加载器加载。<br />
否则，Import列表中的类，委派给Export这个类的Bundle的类加载器加载。<br />
否则，查找当前Bundle的Classpath，使用自己的类加载器加载。<br />
否则，查找是否在自己的Fragment Bundle中，如果是，则委派给Fragment Bundle的类加<br />
载器加载。<br />
否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。<br />
否则，类查找失败。<br />
从图9-2中还可以看出，在OSGi里面，加载器之间的关系不再是双亲委派模型的树形结<br />
构，而是已经进一步发展成了一种更为复杂的、 运行时才能确定的网状结构。 这种网状的类<br />
加载器架构在带来更好的灵活性的同时，也可能会产生许多新的隐患。 笔者曾经参与过将一<br />
个非OSGi的大型系统向Equinox OSGi平台迁移的项目，由于历史原因，代码模块之间的依赖<br />
关系错综复杂，勉强分离出各个模块的Bundle后，发现在高并发环境下经常出现死锁。 我们<br />
很容易就找到了死锁的原因：如果出现了Bundle A依赖Bundle B的Package B，而Bundle B又<br />
依赖了Bundle A的Package A，这两个Bundle进行类加载时就很容易发生死锁。 具体情况是当<br />
Bundle A加载Package B的类时，首先需要锁定当前类加载器的实例对象<br />
（java.lang.ClassLoader.loadClass（）是一个synchronized方法），然后把请求委派给Bundle B<br />
的加载器处理，但如果这时候Bundle B也正好想加载Package A的类，它也先锁定自己的加载<br />
器再去请求Bundle A的加载器处理，这样，两个加载器都在等待对方处理自己的请求，而对<br />
方处理完之前自己又一直处于同步锁定的状态，因此它们就互相死锁，永远无法完成加载请<br />
求了。 Equinox的Bug List中有关于这类问题的Bug[2]，也提供了一个以牺牲性能为代价的解决<br />
方案——用户可以启用osgi.classloader.singleThreadLoads参数来按单线程串行化的方式强制<br />
进行类加载动作。 在JDK 1.7中，为非树状继承关系下的类加载器架构进行了一次专门的升<br />
级[3]，目的是从底层避免这类死锁出现的可能。<br />
总体来说，OSGi描绘了一个很美好的模块化开发的目标，而且定义了实现这个目标所<br />
需要的各种服务，同时也有成熟框架对其提供实现支持。 对于单个虚拟机下的应用，从开发<br />
初期就建立在OSGi上是一个很不错的选择，这样便于约束依赖。 但并非所有的应用都适合<br />
采用OSGi作为基础架构，OSGi在提供强大功能的同时，也引入了额外的复杂度，带来了线<br />
程死锁和内存泄漏的风险。<br />
[1]OSGi官方站点：http://www.osgi.org/Main/HomePage。<br />
[2]Bug-121737：https://bugs.eclipse.org/bugs/show_bug.cgi?id=121737。<br />
[3]JDK 1.7-Upgrade class-loader architecture：<br />
http://openjdk.java.net/projects/jdk7/features/#f352。<br />
9.2.3 字节码生成技术与动态代理的实现<br />
“字节码生成”并不是什么高深的技术，读者在看到“字节码生成”这个标题时也先不必去<br />
想诸如Javassist、 CGLib、 ASM之类的字节码类库，因为JDK里面的javac命令就是字节码生<br />
成技术的“老祖宗”，并且javac也是一个由Java语言写成的程序，它的代码存放在OpenJDK的<br />
langtools/src/share/classes/com/sun/tools/javac目录中[1]。 要深入了解字节码生成，阅读javac的<br />
源码是个很好的途径，不过javac对于我们这个例子来说太过庞大了。 在Java里面除了javac和<br />
字节码类库外，使用字节码生成的例子还有很多，如Web服务器中的JSP编译器，编译时植<br />
入的AOP框架，还有很常用的动态代理技术，甚至在使用反射的时候虚拟机都有可能会在运<br />
行时生成字节码来提高执行速度。 我们选择其中相对简单的动态代理来看看字节码生成技术<br />
是如何影响程序运作的。<br />
相信许多Java开发人员都使用过动态代理，即使没有直接使用过java.lang.reflect.Proxy或<br />
实现过java.lang.reflect.InvocationHandler接口，应该也用过Spring来做过Bean的组织管理。 如<br />
果使用过Spring，那大多数情况都会用过动态代理，因为如果Bean是面向接口编程，那么在<br />
Spring内部都是通过动态代理的方式来对Bean进行增强的。 动态代理中所谓的“动态”，是针<br />
对使用Java代码实际编写了代理类的“静态”代理而言的，它的优势不在于省去了编写代理类<br />
那一点工作量，而是实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，<br />
当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景之中。<br />
代码清单9-1演示了一个最简单的动态代理的用法，原始的逻辑是打印一句“hello<br />
world”，代理类的逻辑是在原始类方法执行前打印一句“welcome”。 我们先看一下代码，然<br />
后再分析JDK是如何做到的。<br />
代码清单9-1 动态代理的简单示例<br />
public class DynamicProxyTest{<br />
interface IHello{<br />
void sayHello（）；<br />
}s<br />
tatic class Hello implements IHello{<br />
@Override<br />
public void sayHello（）{<br />
System.out.println（"hello world"）；<br />
}}s<br />
tatic class DynamicProxy implements InvocationHandler{<br />
Object originalObj；<br />
Object bind（Object originalObj）{<br />
this.originalObj=originalObj；<br />
return<br />
Proxy.newProxyInstance（originalObj.getClass（）.getClassLoader（），originalObj.getClass（）.getInterfaces（），this）；<br />
}@<br />
Override<br />
public Object invoke（Object proxy,Method method,Object[]args）throws Throwable{<br />
System.out.println（"welcome"）；<br />
return method.invoke（originalObj,args）；<br />
}}p<br />
ublic static void main（String[]args）{<br />
IHello hello=（IHello）new DynamicProxy（）.bind（new Hello（））；<br />
hello.sayHello（）；<br />
}} 运<br />
行结果如下：<br />
welcome<br />
hello world<br />
上述代码里，唯一的“黑匣子”就是Proxy.newProxyInstance（）方法，除此之外再没有任<br />
何特殊之处。 这个方法返回一个实现了IHello的接口，并且代理了new Hello（）实例行为的<br />
对象。 跟踪这个方法的源码，可以看到程序进行了验证、 优化、 缓存、 同步、 生成字节码、<br />
显式类加载等操作，前面的步骤并不是我们关注的重点，而最后它调用了<br />
sun.misc.ProxyGenerator.generateProxyClass（）方法来完成生成字节码的动作，这个方法可以<br />
在运行时产生一个描述代理类的字节码byte[]数组。 如果想看一看这个在运行时产生的代理<br />
类中写了些什么，可以在main（）方法中加入下面这句：<br />
System.getProperties（）.put（"sun.misc.ProxyGenerator.saveGeneratedFiles"，"true"）；<br />
加入这句代码后再次运行程序，磁盘中将会产生一个名为“$Proxy0.class”的代理类Class<br />
文件，反编译后可以看见如代码清单9-2所示的内容。<br />
代码清单9-2 反编译的动态代理类的代码<br />
package org.fenixsoft.bytecode；<br />
import java.lang.reflect.InvocationHandler；<br />
import java.lang.reflect.Method；<br />
import java.lang.reflect.Proxy；<br />
import java.lang.reflect.UndeclaredThrowableException；<br />
public final class $Proxy0 extends Proxy<br />
implements DynamicProxyTest.IHello<br />
{p<br />
rivate static Method m3；<br />
private static Method m1；<br />
private static Method m0；<br />
private static Method m2；<br />
public $Proxy0（InvocationHandler paramInvocationHandler）<br />
throws<br />
{s<br />
uper（paramInvocationHandler）；<br />
}p<br />
ublic final void sayHello（）<br />
throws<br />
{t<br />
ry<br />
{t<br />
his.h.invoke（this,m3，null）；<br />
return；<br />
}c<br />
atch（RuntimeException localRuntimeException）<br />
{t<br />
hrow localRuntimeException；<br />
}c<br />
atch（Throwable localThrowable）<br />
{t<br />
hrow new UndeclaredThrowableException（localThrowable）；<br />
}}/<br />
/此处由于版面原因，省略equals（）、 hashCode（）、 toString（）三个方法的代码<br />
//这3个方法的内容与sayHello（）非常相似。<br />
static<br />
{t<br />
ry<br />
{m<br />
3=Class.forName（"org.fenixsoft.bytecode.DynamicProxyTest $IHello"）.getMethod（"sayHello"，new Class[0]）；<br />
m1=Class.forName（"java.lang.Object"）.getMethod（"equals"，new Class[]{Class.forName（"java.lang.Object"）}）；<br />
m0=Class.forName（"java.lang.Object"）.getMethod（"hashCode"，new Class[0]）；<br />
m2=Class.forName（"java.lang.Object"）.getMethod（"toString"，new Class[0]）；<br />
return；<br />
}c<br />
atch（NoSuchMethodException localNoSuchMethodException）<br />
{t<br />
hrow new NoSuchMethodError（localNoSuchMethodException.getMessage（））；<br />
}c<br />
atch（ClassNotFoundException localClassNotFoundException）<br />
{t<br />
hrow new NoClassDefFoundError（localClassNotFoundException.getMessage（））；<br />
}}} 这<br />
个代理类的实现代码也很简单，它为传入接口中的每一个方法，以及从<br />
java.lang.Object中继承来的equals（）、 hashCode（）、 toString（）方法都生成了对应的实<br />
现，并且统一调用了InvocationHandler对象的invoke（）方法（代码中的“this.h”就是父类<br />
Proxy中保存的InvocationHandler实例变量）来实现这些方法的内容，各个方法的区别不过是<br />
传入的参数和Method对象有所不同而已，所以无论调用动态代理的哪一个方法，实际上都是<br />
在执行InvocationHandler.invoke（）中的代理逻辑。<br />
这个例子中并没有讲到generateProxyClass（）方法具体是如何产生代理<br />
类“$Proxy0.class”的字节码的，大致的生成过程其实就是根据Class文件的格式规范去拼装字<br />
节码，但在实际开发中，以byte为单位直接拼装出字节码的应用场合很少见，这种生成方式<br />
也只能产生一些高度模板化的代码。 对于用户的程序代码来说，如果有要大量操作字节码的<br />
需求，还是使用封装好的字节码类库比较合适。 如果读者对动态代理的字节码拼装过程很感<br />
兴趣，可以在OpenJDK的jdk/src/share/classes/sun/misc目录下找到sun.misc.ProxyGenerator的源<br />
码。<br />
[1]如何获取OpenJDK源码，请参见本书第1章的相关内容。<br />
9.2.4 Retrotranslator：跨越JDK版本<br />
一般来说，以“做项目”为主的软件公司比较容易更新技术，在下一个项目中换一个技术<br />
框架、 升级到最新的JDK版本，甚至把Java换成C#、 C++来开发程序都是有可能的。 但当公<br />
司发展壮大，技术有所积累，逐渐成为以“做产品”为主的软件公司后，自主选择技术的权利<br />
就会丧失掉，因为之前所积累的代码和技术都是用真金白银换来的，一个稳健的团队也不会<br />
随意地改变底层的技术。 然而在飞速发展的程序设计领域，新技术总是日新月异、 层出不<br />
穷，偏偏这些新技术又如鲜花之于蜜蜂一样，对程序员散发着天然的吸引力。<br />
在Java世界里，每一次JDK大版本的发布，都伴随着一场大规模的技术革新，而对Java<br />
程序编写习惯改变最大的，无疑是JDK 1.5的发布。 自动装箱、 泛型、 动态注解、 枚举、 变<br />
长参数、 遍历循环（foreach循环）……事实上，在没有这些语法特性的年代，Java程序也照<br />
样能写，但是现在看来，上述每一种语法的改进几乎都是“必不可少”的。 就如同习惯了24寸<br />
液晶显示器的程序员，很难习惯在15寸纯平显示器上编写代码。 但假如“不幸”因为要保护现<br />
有投资、 维持程序结构稳定等，必须使用1.5以前版本的JDK呢？我们没有办法把15寸显示器<br />
变成24寸的，但却可以跨越JDK版本之间的沟壑，把JDK 1.5中编写的代码放到JDK 1.4或1.3<br />
的环境中去部署使用。 为了解决这个问题，一种名为“Java逆向移植”的工具（Java<br />
Backporting Tools）应运而生，Retrotranslator[1]是这类工具中较出色的一个。<br />
Retrotranslator的作用是将JDK 1.5编译出来的Class文件转变为可以在JDK 1.4或1.3上部署<br />
的版本，它可以很好地支持自动装箱、 泛型、 动态注解、 枚举、 变长参数、 遍历循环、 静态<br />
导入这些语法特性，甚至还可以支持JDK 1.5中新增的集合改进、 并发包以及对泛型、 注解<br />
等的反射操作。 了解了Retrotranslator这种逆向移植工具可以做什么以后，现在关心的是它是<br />
怎样做到的？<br />
要想知道Retrotranslator如何在旧版本JDK中模拟新版本JDK的功能，首先要弄清楚JDK<br />
升级中会提供哪些新的功能。 JDK每次升级新增的功能大致可以分为以下4类：<br />
在编译器层面做的改进。 如自动装箱拆箱，实际上就是编译器在程序中使用到包装对象<br />
的地方自动插入了很多Integer.valueOf（）、 Float.valueOf（）之类的代码；变长参数在编译<br />
之后就自动转化成了一个数组来完成参数传递；泛型的信息则在编译阶段就已经擦除掉了<br />
（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码[2]。<br />
对Java API的代码增强。 譬如JDK 1.2时代引入的java.util.Collections等一系列集合类，在<br />
JDK 1.5时代引入的java.util.concurrent并发包等。<br />
需要在字节码中进行支持的改动。 如JDK 1.7里面新加入的语法特性：动态语言支持，<br />
就需要在虚拟机中新增一条invokedynamic字节码指令来实现相关的调用功能。 不过字节码指<br />
令集一直处于相对比较稳定的状态，这种需要在字节码层面直接进行的改动是比较少见的。<br />
虚拟机内部的改进。 如JDK 1.5中实现的JSR-133[3]规范重新定义的Java内存模型（Java<br />
Memory Model,JMM）、 CMS收集器之类的改动，这类改动对于程序员编写代码基本是透明<br />
的，但会对程序运行时产生影响。<br />
上述4类新功能中，Retrotranslator只能模拟前两类，对于后面两类直接在虚拟机内部实<br />
现的改进，一般所有的逆向移植工具都是无能为力的，至少不能完整地或者在可接受的效率<br />
上完成全部模拟，否则虚拟机设计团队也没有必要舍近求远地改动处于JDK底层的虚拟机。<br />
在可以模拟的两类功能中，第二类模拟相对更容易实现一些，如JDK 1.5引入的<br />
java.util.concurrent包，实际是由多线程大师Doug Lea开发的一套并发包，在JDK 1.5出现之前<br />
就已经存在（那时候名字叫做dl.util.concurrent，引入JDK时由作者和JDK开发团队共同做了<br />
一些改进），所以要在旧的JDK中支持这部分功能，以独立类库的方式便可实现。<br />
Retrotranslator中附带了一个名叫“backport-util-concurrent.jar”的类库（由另一个名为“Backport<br />
ot JSR 166”的项目所提供）来代替JDK 1.5的并发包。<br />
至于JDK在编译阶段进行处理的那些改进，Retrotranslator则是使用ASM框架直接对字节<br />
码进行处理。 由于组成Class文件的字节码指令数量并没有改变，所以无论是JDK 1.3、 JDK<br />
1.4还是JDK 1.5，能用字节码表达的语义范围应该是一致的。 当然，肯定不可能简单地把<br />
Class的文件版本号从49.0改回48.0就能解决问题了，虽然字节码指令的数量没有变化，但是<br />
元数据信息和一些语法支持的内容还是要做相应的修改。 以枚举为例，在JDK 1.5中增加了<br />
enum关键字，但是Class文件常量池的CONSTANT_Class_info类型常量并没有发生任何语义变<br />
化，仍然是代表一个类或接口的符号引用，没有加入枚举，也没有增加<br />
过“CONSTANT_Enum_info”之类的“枚举符号引用”常量。 所以使用enum关键字定义常量，虽<br />
然从Java语法上看起来与使用class关键字定义类、 使用interface关键字定义接口是同一层次<br />
的，但实际上这是由Javac编译器做出来的假象，从字节码的角度来看，枚举仅仅是一个继<br />
承于java.lang.Enum、 自动生成了values（）和valueOf（）方法的普通Java类而已。<br />
Retrotranslator对枚举所做的主要处理就是把枚举类的父类从“java.lang.Enum”替换为它运<br />
行时类库中包含的“net.sf.retrotranslator.runtime.java.lang.Enum_”，然后再在类和字段的访问标<br />
志中抹去ACC_ENUM标志位。 当然，这只是处理的总体思路，具体的实现要比上面说的复<br />
杂得多。 可以想象既然两个父类实现都不一样，values（）和valueOf（）的方法自然需要重<br />
写，常量池需要引入大量新的来自父类的符号引用，这些都是实现细节。 图9-3是一个使用<br />
JDK 1.5编译的枚举类与被Retrotranslator转换处理后的字节码的对比图。<br />
图 9-3 Retrotranslator处理前后的枚举类字节码对比<br />
[1]Retrotranslator官方站点：http://retrotranslator.sf.net。<br />
[2]如果想了解编译器在这个阶段所做的各种动作的详细信息，那么可以参考10.3节。<br />
[3]JSR-133：Java Memory Model and Thread Specification Revision（Java内存模型和线程规范<br />
修订）。<br />
9.3 实战：自己动手实现远程执行功能<br />
不知道读者在做程序维护的时候是否遇到过这类情形：排查问题的过程中，想查看内存<br />
中的一些参数值，却又没有方法把这些值输出到界面或日志中，又或者定位到某个缓存数据<br />
有问题，但缺少缓存的统一管理界面，不得不重启服务才能清理这个缓存。 类似的需求有一<br />
个共同的特点，那就是只要在服务中执行一段程序代码，就可以定位或排除问题，但就是偏<br />
偏找不到可以让服务器执行临时代码的途径，这时候就会希望Java服务器中也有提供类似<br />
Groovy Console的功能。<br />
JDK 1.6之后提供了Compiler API，可以动态地编译Java程序，虽然这样达不到动态语言<br />
的灵活度，但让服务器执行临时代码的需求就可以得到解决了。 在JDK 1.6之前，也可以通<br />
过其他方式来做到，譬如写一个JSP文件上传到服务器，然后在浏览器中运行它，或者在服<br />
务端程序中加入一个BeanShell Script、 JavaScript等的执行引擎（如Mozilla Rhino[1]）去执行动<br />
态脚本。 在本章的实战部分，我们将使用前面学到的关于类加载及虚拟机执行子系统的知识<br />
去实现在服务端执行临时代码的功能。<br />
9.3.1 目标<br />
首先，在实现“在服务端执行临时代码”这个需求之前，先来明确一下本次实战的具体目<br />
标，我们希望最终的产品是这样的：<br />
不依赖JDK版本，能在目前还普遍使用的JDK中部署，也就是使用JDK 1.4～JDK 1.7都可<br />
以运行。<br />
不改变原有服务端程序的部署，不依赖任何第三方类库。<br />
不侵入原有程序，即无须改动原程序的任何代码，也不会对原有程序的运行带来任何影<br />
响。<br />
考到BeanShell Script或JavaScript等脚本编写起来不太方便，“临时代码”需要直接支持<br />
Java语言。<br />
“临时代码”应当具备足够的自由度，不需要依赖特定的类或实现特定的接口。 这里写的<br />
是“不需要”而不是“不可以”，当“临时代码”需要引用其他类库时也没有限制，只要服务端程<br />
序能使用的，临时代码应当都能直接引用。<br />
“临时代码”的执行结果能返回到客户端，执行结果可以包括程序中输出的信息及抛出的<br />
异常等。<br />
看完上面列出的目标，你觉得完成这个需求需要做多少工作呢？也许答案比大多数人所<br />
想的都要简单一些：5个类，250行代码（含注释），大约一个半小时左右的开发时间就可以<br />
了，现在就开始编写程序吧！<br />
[1]Rhino站点：http://www.mozilla.org/rhino/，Rhino已被收编入JDK 1.6中。<br />
9.3.2 思路<br />
在程序实现的过程中，我们需要解决以下3个问题：<br />
如何编译提交到服务器的Java代码？<br />
如何执行编译之后的Java代码？<br />
如何收集Java代码的执行结果？<br />
对于第一个问题，我们有两种思路可以选择，一种是使用tools.jar包（在Sun JDK/lib目录<br />
下）中的com.sun.tools.javac.Main类来编译Java文件，这其实和使用Javac命令编译是一样的。<br />
这种思路的缺点是引入了额外的JAR包，而且把程序“绑死”在Sun的JDK上了，要部署到其他<br />
公司的JDK中还得把tools.jar带上（虽然JRockit和J9虚拟机也有这个JAR包，但它总不是标准<br />
所规定必须存在的）。 另外一种思路是直接在客户端编译好，把字节码而不是Java代码传到<br />
服务端，这听起来好像有点投机取巧，一般来说确实不应该假定客户端一定具有编译代码的<br />
能力，但是既然程序员会写Java代码去给服务端排查问题，那么很难想象他的机器上会连编<br />
译Java程序的环境都没有。<br />
对于第二个问题，简单地一想：要执行编译后的Java代码，让类加载器加载这个类生成<br />
一个Class对象，然后反射调用一下某个方法就可以了（因为不实现任何接口，我们可以借用<br />
一下Java中人人皆知的“main（）”方法）。 但我们还应该考虑得更周全些：一段程序往往不<br />
是编写、 运行一次就能达到效果，同一个类可能要反复地修改、 提交、 执行。 另外，提交上<br />
去的类要能访问服务端的其他类库才行。 还有，既然提交的是临时代码，那提交的Java类在<br />
执行完后就应当能卸载和回收。<br />
最后的一个问题，我们想把程序往标准输出（System.out）和标准错误输出<br />
（System.err）中打印的信息收集起来，但标准输出设备是整个虚拟机进程全局共享的资源，<br />
如果使用System.setOut（）/System.setErr（）方法把输出流重定向到自己定义的PrintStream对<br />
象上固然可以收集输出信息，但也会对原有程序产生影响：会把其他线程向标准输出中打印<br />
的信息也收集了。 虽然这些并不是不能解决的问题，不过为了达到完全不影响原程序的目<br />
的，我们可以采用另外一种办法，即直接在执行的类中把对System.out的符号引用替换为我<br />
们准备的PrintStream的符号引用，依赖前面学习的知识，做到这一点并不困难。<br />
9.3.3 实现<br />
在程序实现部分，我们主要看一下代码及其注释。 首先看看实现过程中需要用到的4个<br />
支持类。 第一个类用于实现“同一个类的代码可以被多次加载”这个需求，即用于解决9.3.1节<br />
中列举的第2个问题的HotSwapClassLoader，具体程序如代码清单9-3所示。<br />
代码清单9-3 HotSwapClassLoader的实现<br />
/**<br />
*为了多次载入执行类而加入的加载器＜br＞<br />
*把defineClass方法开放出来，只有外部显式调用的时候才会使用到loadByte方法<br />
*由虚拟机调用时，仍然按照原有的双亲委派规则使用loadClass方法进行类加载<br />
**<br />
@author zzm<br />
*/<br />
public class HotSwapClassLoader extends ClassLoader{<br />
public HotSwapClassLoader（）{<br />
super（HotSwapClassLoader.class.getClassLoader（））；<br />
}p<br />
ublic Class loadByte（byte[]classByte）{<br />
return defineClass（null,classByte，0，classByte.length）；<br />
}} H<br />
otSwapClassLoader所做的事情仅仅是公开父类（即java.lang.ClassLoader）中的<br />
protected方法defineClass（），我们将会使用这个方法把提交执行的Java类的byte[]数组转变<br />
为Class对象。 HotSwapClassLoader中并没有重写loadClass（）或findClass（）方法，因此如<br />
果不算外部手工调用loadByte（）方法的话，这个类加载器的类查找范围与它的父类加载器<br />
是完全一致的，在被虚拟机调用时，它会按照双亲委派模型交给父类加载。 构造函数中指定<br />
为加载HotSwapClassLoader类的类加载器作为父类加载器，这一步是实现提交的执行代码可<br />
以访问服务端引用类库的关键，下面我们来看看代码清单9-3。<br />
第二个类是实现将java.lang.System替换为我们自己定义的HackSystem类的过程，它直接<br />
修改符合Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的<br />
CONSTANT_Utf8_info常量替换为新的字符串，具体代码如代码清单9-4所示。 ClassModifier<br />
中涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据<br />
的替换操作封装在代码清单9-5所示的ByteUtils中。<br />
代码清单9-4 ClassModifier的实现<br />
/**<br />
*修改Class文件，暂时只提供修改常量池常量的功能<br />
*@author zzm<br />
*/<br />
public class ClassModifier{<br />
/**<br />
*Class文件中常量池的起始偏移<br />
*/<br />
private static final int CONSTANT_POOL_COUNT_INDEX=8；<br />
/**<br />
*CONSTANT_Utf8_info常量的tag标志<br />
*/<br />
private static final int CONSTANT_Utf8_info=1；<br />
/**<br />
*常量池中11种常量所占的长度，CONSTANT_Utf8_info型常量除外，因为它不是定长的<br />
*/<br />
private static final int[]CONSTANT_ITEM_LENGTH={-1，-1，-1，5，5，9，9，3，3，5，5，5，5}；<br />
private static final int u1=1；<br />
private static final int u2=2；<br />
private byte[]classByte；<br />
public ClassModifier（byte[]classByte）{<br />
this.classByte=classByte；<br />
}/<br />
**<br />
*修改常量池中CONSTANT_Utf8_info常量的内容<br />
*@param oldStr修改前的字符串<br />
*@param newStr修改后的字符串<br />
*@return修改结果<br />
*/<br />
public byte[]modifyUTF8Constant（String oldStr,String newStr）{<br />
int cpc=getConstantPoolCount（）；<br />
int offset=CONSTANT_POOL_COUNT_INDEX+u2；<br />
for（int i=0；i＜cpc；i++）{<br />
int tag=ByteUtils.bytes2Int（classByte,offset,u1）；<br />
if（tag==CONSTANT_Utf8_info）{<br />
int len=ByteUtils.bytes2Int（classByte,offset+u1，u2）；<br />
offset+=（u1+u2）；<br />
String str=ByteUtils.bytes2String（classByte,offset,len）；<br />
if（str.equalsIgnoreCase（oldStr））{<br />
byte[]strBytes=ByteUtils.string2Bytes（newStr）；<br />
byte[]strLen=ByteUtils.int2Bytes（newStr.length（），u2）；<br />
classByte=ByteUtils.bytesReplace（classByte,offset-u2，u2，strLen）；<br />
classByte=ByteUtils.bytesReplace（classByte,offset,len,strBytes）；<br />
return classByte；<br />
}else{<br />
offset+=len；<br />
}}<br />
else{<br />
offset+=CONSTANT_ITEM_LENGTH[tag]；<br />
}}r<br />
eturn classByte；<br />
}/<br />
**<br />
*获取常量池中常量的数量<br />
*@return常量池数量<br />
*/<br />
public int getConstantPoolCount（）{<br />
return ByteUtils.bytes2Int（classByte,CONSTANT_POOL_COUNT_INDEX,u2）；<br />
}} 代<br />
码清单9-5 ByteUtils的实现<br />
/**<br />
*Bytes数组处理工具<br />
*@author<br />
*/<br />
public class ByteUtils{<br />
public static int bytes2Int（byte[]b,int start,int len）{<br />
int sum=0；<br />
int end=start+len；<br />
for（int i=start；i＜end；i++）{<br />
int n=（（int）b[i]）＆0xff；<br />
n＜＜=（--len）*8；<br />
sum=n+sum；<br />
}r<br />
eturn sum；<br />
}p<br />
ublic static byte[]int2Bytes（int value,int len）{<br />
byte[]b=new byte[len]；<br />
for（int i=0；i＜len；i++）{<br />
b[len-i-1]=（byte）（（value＞＞8*i）＆0xff）；<br />
}r<br />
eturn b；<br />
}p<br />
ublic static String bytes2String（byte[]b,int start,int len）{<br />
return new String（b,start,len）；<br />
}p<br />
ublic static byte[]string2Bytes（String str）{<br />
return str.getBytes（）；<br />
}p<br />
ublic static byte[]bytesReplace（byte[]originalBytes,int offset,int len,byte[]replaceBytes）{<br />
byte[]newBytes=new byte[originalBytes.length+（replaceBytes.length-len）]；<br />
System.arraycopy（originalBytes，0，newBytes，0，offset）；<br />
System.arraycopy（replaceBytes，0，newBytes,offset,replaceBytes.length）；<br />
System.arraycopy（originalBytes,offset+len,newBytes,offset+replaceBytes.length,originalBytes.length-offset-len）；<br />
return newBytes；<br />
}} 经<br />
过ClassModifier处理后的byte[]数组才会传给HotSwapClassLoader.loadByte（）方法进<br />
行类加载，byte[]数组在这里替换符号引用之后，与客户端直接在Java代码中引用HackSystem<br />
类再编译生成的Class是完全一样的。 这样的实现既避免了客户端编写临时执行代码时要依赖<br />
特定的类（不然无法引入HackSystem），又避免了服务端修改标准输出后影响到其他程序的<br />
输出。 下面我们来看看代码清单9-4和代码清单9-5。<br />
最后一个类就是前面提到过的用来代替java.lang.System的HackSystem，这个类中的方法<br />
看起来不少，但其实除了把out和err两个静态变量改成使用ByteArrayOutputStream作为打印目<br />
标的同一个PrintStream对象，以及增加了读取、 清理ByteArrayOutputStream中内容的<br />
getBufferString（）和clearBuffer（）方法外，就再没有其他新鲜的内容了。 其余的方法全部<br />
都来自于System类的public方法，方法名字、 参数、 返回值都完全一样，并且实现也是直接<br />
转调了System类的对应方法而已。 保留这些方法的目的，是为了在Sytem被替换成HackSystem<br />
之后，执行代码中调用的System的其余方法仍然可以继续使用，HackSystem的实现如代码清<br />
单9-6所示。<br />
代码清单9-6 HackSystem的实现<br />
/**<br />
*为JavaClass劫持java.lang.System提供支持<br />
*除了out和err外，其余的都直接转发给System处理<br />
**<br />
@author zzm<br />
*/<br />
public class HackSystem{<br />
public final static InputStream in=System.in；<br />
private static ByteArrayOutputStream buffer=new ByteArrayOutputStream（）；<br />
public final static PrintStream out=new PrintStream（buffer）；<br />
public final static PrintStream err=out；<br />
public static String getBufferString（）{<br />
return buffer.toString（）；<br />
}p<br />
ublic static void clearBuffer（）{<br />
buffer.reset（）；<br />
}p<br />
ublic static void setSecurityManager（final SecurityManager s）{<br />
System.setSecurityManager（s）；<br />
}p<br />
ublic static SecurityManager getSecurityManager（）{<br />
return System.getSecurityManager（）；<br />
}p<br />
ublic static long currentTimeMillis（）{<br />
return System.currentTimeMillis（）；<br />
}p<br />
ublic static void arraycopy（Object src,int srcPos,Object dest,int destPos,int length）{<br />
System.arraycopy（src,srcPos,dest,destPos,length）；<br />
}p<br />
ublic static int identityHashCode（Object x）{<br />
return System.identityHashCode（x）；<br />
}/<br />
/下面所有的方法都与java.lang.System的名称一样<br />
//实现都是字节转调System的对应方法<br />
//因版面原因，省略了其他方法<br />
} 至<br />
此，4个支持类已经讲解完毕，我们来看看最后一个类JavaClassExecuter，它是提供给<br />
外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作。 JavaClassExecuter只有<br />
一个execute（）方法，用输入的符合Class文件格式的byte[]数组替换java.lang.System的符号引<br />
用后，使用HotSwapClassLoader加载生成一个Class对象，由于每次执行execute（）方法都会<br />
生成一个新的类加载器实例，因此同一个类可以实现重复加载。 然后，反射调用这个Class对<br />
象的main（）方法，如果期间出现任何异常，将异常信息打印到HackSystem.out中，最后把缓<br />
冲区中的信息作为方法的结果返回。 JavaClassExecuter的实现代码如代码清单9-7所示。<br />
代码清单9-7 JavaClassExecuter的实现<br />
/**<br />
*JavaClass执行工具<br />
**<br />
@author zzm<br />
*/<br />
public class JavaClassExecuter{<br />
/**<br />
*执行外部传过来的代表一个Java类的byte数组＜br＞<br />
*将输入类的byte数组中代表java.lang.System的CONSTANT_Utf8_info常量修改为劫持后的HackSystem类<br />
*执行方法为该类的static main（String[]args）方法，输出结果为该类向System.out/err输出的信息<br />
*@param classByte代表一个Java类的byte数组<br />
*@return执行结果<br />
*/<br />
public static String execute（byte[]classByte）{<br />
HackSystem.clearBuffer（）；<br />
ClassModifier cm=new ClassModifier（classByte）；<br />
byte[]modiBytes=cm.modifyUTF8Constant（"java/lang/System"，"org/fenixsoft/classloading/execute/HackSystem"）；<br />
HotSwapClassLoader loader=new HotSwapClassLoader（）；<br />
Class clazz=loader.loadByte（modiBytes）；<br />
try{<br />
Method method=clazz.getMethod（"main"，new Class[]{String[].class}）；<br />
method.invoke（null,new String[]{null}）；<br />
}catch（Throwable e）{<br />
e.printStackTrace（HackSystem.out）；<br />
}r<br />
eturn HackSystem.getBufferString（）；<br />
}}<br />
9.3.4 验证<br />
远程执行功能的编码到此就完成了，接下来就要检验一下我们的劳动成果了。 如果只是<br />
测试的话，那么可以任意写一个Java类，内容无所谓，只要向System.out输出信息即可，取名<br />
为TestClass，同时放到服务器C盘的根目录中。 然后，建立一个JSP文件并加入如代码清单9-<br />
8所示的内容，就可以在浏览器中看到这个类的运行结果了。<br />
代码清单9-8 测试JSP<br />
＜%@page import="java.lang.*"%＞<br />
＜%@page import="java.io.*"%＞<br />
＜%@page import="org.fenixsoft.classloading.execute.*"%＞<br />
＜%<br />
InputStream is=new FileInputStream（"c：/TestClass.class"）；<br />
byte[]b=new byte[is.available（）]；<br />
is.read（b）；<br />
is.close（）；<br />
out.println（"＜textarea style='width：1000；height=800'＞"）；<br />
out.println（JavaClassExecuter.execute（b））；<br />
out.println（"＜/textarea＞"）；<br />
%＞<br />
当然，上面的做法只是用于测试和演示，实际使用这个JavaExecuter执行器的时候，如<br />
果还要手工复制一个Class文件到服务器上就没有什么意义了。 笔者给这个执行器写了一<br />
个“外壳”，是一个Eclipse插件，可以把Java文件编译后传输到服务器中，然后把执行器的返<br />
回结果输出到Eclipse的Console窗口里，这样就可以在有灵感的时候随时写几行调试代码，<br />
放到测试环境的服务器上立即运行了。 虽然实现简单，但效果很不错，对调试问题也非常有<br />
用，如图9-4所示。<br />
图 9-4 JavaClassExecuter的使用<br />
9.4 本章小结<br />
本书第6～9章介绍了Class文件格式、 类加载及虚拟机执行引擎几部分内容，这些内容是<br />
虚拟机中必不可少的组成部分，只有了解了虚拟机如何执行程序，才能更好地理解怎样写出<br />
优秀的代码。<br />
关于虚拟机执行子系统的介绍到此就结束了，通过这4章的讲解，我们描绘了一个虚拟<br />
机应该怎样运行Class文件的概念模型。 对于具体到某个虚拟机的实现，为了使实现简单、 清<br />
晰，或者为了更快的运行速度，在虚拟机内部的运作跟概念模型可能会有非常大的差异，但<br />
从最终的执行结果来看应该是一致的。 从第10章开始，我们将探索虚拟机在语法和运行性能<br />
上是如何对程序编写做出各种优化的。<br />
 </p>
