先序遍历：

递归定义：
若二叉树为空，则遍历结束；否则
⑴ 访问根结点；
⑵ 先序遍历左子树(递归调用本算法)；
⑶ 先序遍历右子树(递归调用本算法)。

非递归算法：
设T是指向二叉树根结点的指针变量，非递归算法是：
若二叉树为空，则返回；否则，令p=T；
⑴ 访问p所指向的结点；
⑵ q=p->Rchild ，若q不为空，则q进栈；
⑶ p=p->Lchild ，若p不为空，转(1)，否则转(4)；
⑷ 退栈到p ，转(1)，直到栈空为止。

中序遍历：

递归定义：
若二叉树为空，则遍历结束；否则
⑴ 中序遍历左子树(递归调用本算法)；
⑵ 访问根结点；
⑶ 中序遍历右子树(递归调用本算法)。

非递归算法：
若二叉树为空，则返回；否则，令p=T
⑴ 若p不为空，p进栈， p=p->Lchild ；
⑵ 否则(即p为空)，退栈到p，访问p所指向的结点；
⑶ p=p->Rchild ，转(1)；
直到栈空为止。

后序遍历：

算法的递归定义是：
若二叉树为空，则遍历结束；否则
⑴ 后序遍历左子树(递归调用本算法)；
⑵ 后序遍历右子树(递归调用本算法) ；
⑶ 访问根结点 。

设T是指向根结点的指针变量，非递归算法是：
若二叉树为空，则返回；否则，令p=T；
⑴ 第一次经过根结点p，不访问：
p进栈S1 ， tag 赋值0，进栈S2，p=p->Lchild 。
⑵ 若p不为空，转(1)，否则，取状态标志值tag ：
⑶ 若tag=0：对栈S1，不访问，不出栈；修改S2栈顶元素值(tag赋值1) ，取S1栈顶元素的右子树，即p=S1[top]->Rchild ，转(1)；
⑷ 若tag=1：S1退栈，访问该结点；
直到栈空为止。



