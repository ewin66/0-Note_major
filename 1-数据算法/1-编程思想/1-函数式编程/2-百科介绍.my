<h1>函数式编程</h1>

<p>函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是&lambda;演算（lambda calculus），而且&lambda;演算的函数可以接受函数当作输入（参数）和输出（返回值）。<sup>&nbsp;[1]</sup></p>

<p>和指令式编程相比，函数式编程强调函数的计算比指令的执行重要。</p>

<p>和过程化编程相比，函数式编程里函数的计算可随时调用。</p>

<p>原&nbsp;&nbsp;&nbsp;&nbsp;理</p>

<p>将电脑运算视为函数的计算</p>

<p>基&nbsp;&nbsp;&nbsp;&nbsp;础</p>

<p>&lambda;演算</p>

<p>主要思想</p>

<p>把运算过程写成嵌套函数调用</p>

<h2>历史</h2>

<p>虽然 &lambda; 演算并非设计来于计算机上执行，但可视为第一个函数式编程语言。1980年代末期，Haskell发布企图集合很多函数式编程研究里的想法。<sup>&nbsp;[2]</sup></p>

<h2>定义</h2>

<p>简单说，&quot;函数式编程&quot;是一种&quot;编程范式&quot;（programming paradigm），也就是如何编写程序的方法论。</p>

<p>它属于&quot;结构化编程&quot;的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。<sup>&nbsp;[2]</sup></p>

<h2>例子</h2>

<p>函数式编程中最古老的例子莫过于1958年被创造出来的LISP了，透过 LISP，可以用精简的人力。较现代的例子包括Haskell、Clean、Erlang和Miranda等。<sup>&nbsp;[3]</sup></p>

<h2>特性</h2>

<p><strong>闭包和高阶函数</strong></p>

<p>函数编程支持函数作为第一类对象，有时称为闭包或者<a href="https://baike.baidu.com/item/%E4%BB%BF%E5%87%BD%E6%95%B0" target="_blank">仿函数</a>（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。与此类似，FP 语言支持高阶函数。高阶函数可以用另一个函数（间接地，用一个<a href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank">表达式</a>） 作为其输入参数，在某些情况下，它甚至返回一个函数作为其输出参数。这两种结构结合在一起使得可以用优雅的方式进行模块化编程，这是使用 FP 的最大好处。<sup>&nbsp;[4]</sup></p>

<p><strong>惰性计算</strong></p>

<p>除了高阶函数和<a href="https://baike.baidu.com/item/%E4%BB%BF%E5%87%BD%E6%95%B0" target="_blank">仿函数</a>（或闭包）的概念，FP 还引入了<a href="https://baike.baidu.com/item/%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97" target="_blank">惰性计算</a>的概念。在惰性计算中，<a href="https://baike.baidu.com/item/%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank">表达式</a>不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算使您可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。一个惰性计算的例子是生成无穷 Fibonacci 列表的函数，但是对第n个Fibonacci 数的计算相当于只是从可能的无穷列表中提取一项。</p>

<p><strong>递归</strong></p>

<p>FP 还有一个特点是用<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92" target="_blank">递归</a>做为控制流程的机制。例如，Lisp 处理的列表定义为在头元素后面有子列表，这种表示法使得它自己自然地对更小的子列表不断递归。</p>

<p>函数式编程具有五个鲜明的特点。</p>

<p><strong>函数是&quot;第一等公民&quot;</strong></p>

<p>所谓&quot;第一等公民&quot;（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>

<p>举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。</p>

<p>var print = function(i){ console.log(i);};<br />
　　[1,2,3].forEach(print);</p>

<p><strong>只用&quot;表达式&quot;，不用&quot;语句&quot;</strong></p>

<p>&quot;表达式&quot;（expression）是一个单纯的运算过程，总是有返回值；&quot;语句&quot;（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>

<p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。&quot;语句&quot;属于对系统的读写操作，所以就被排斥在外。</p>

<p>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p>

<p><strong>没有&quot;副作用&quot;</strong></p>

<p>所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>

<p>函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>

<p><strong>不修改状态</strong></p>

<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>

<p>在其他类型的语言中，变量往往用来保存&quot;状态&quot;（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的&quot;状态&quot;。</p>

<p><strong>引用透明性</strong></p>

<p>函数程序通常还加强<em>引用透明性</em>，即如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。这使您可以从形式上推断程序行为，因为表达式的意义只取决于其子表达式而不是计算顺序或者其他表达式的副作用。这有助于验证正确性、简化算法，甚至有助于找出优化它的方法。</p>

<p><strong>副作用</strong></p>

<p>副作用是修改系统状态的语言结构。因为 FP 语言不包含任何<a href="https://baike.baidu.com/item/%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5" target="_blank">赋值语句</a>，变量值一旦被指派就永远不会改变。而且，调用函数只会计算出结果 ── 不会出现其他效果。因此，FP 语言没有副作用。<sup>&nbsp;[5]</sup></p>

<h2>优点</h2>

<p><strong>1. 代码简洁，开发快速</strong></p>

<p>函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。</p>

<p>Paul Graham在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。</p>

<p>如果程序员每天所写的代码行数基本相同，这就意味着，&quot;C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。&quot;当然，这样的对比故意夸大了差异，但是&quot;在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。&quot;</p>

<p><strong>2. 接近自然语言，易于理解</strong></p>

<p>函数式编程的自由度很高，可以写出很接近自然语言的代码。</p>

<p>前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：</p>

<p>subtract(multiply(add(1,2), 3), 4)</p>

<p>对它进行变形，不难得到另一种写法：</p>

<p>add(1,2).multiply(3).subtract(4)</p>

<p>这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：</p>

<p>merge([1,2],[3,4]).sort().search(&quot;2&quot;)</p>

<p>因此，函数式编程的代码更容易理解。</p>

<p><strong>3. 更方便的代码管理</strong></p>

<p>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</p>

<p><strong>4. 易于&quot;并发编程&quot;</strong></p>

<p>函数式编程不需要考虑&quot;死锁&quot;（deadlock），因为它不修改变量，所以根本不存在&quot;锁&quot;线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署&quot;并发编程&quot;（concurrency）。</p>

<p>请看下面的代码：</p>

<p>var s1 = Op1();</p>

<p>var s2 = Op2();</p>

<p>var s3 = concat(s1, s2);</p>

<p>由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。</p>

<p>多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。</p>

<p><strong>5. 代码的热升级</strong></p>

<p>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。<a href="https://baike.baidu.com/item/Erlang" target="_blank">Erlang</a>语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。</p>

<h2>顾虑</h2>

<p>函数式编程常被认为严重耗费在CPU和存储器资源。主因有二：</p>

<ul>
	<li>
	<p>早期的函数式编程语言实现时并无考虑过效率问题。</p>
	</li>
	<li>
	<p>有些非函数式编程语言为求提升速度，不提供自动边界检查或自动垃圾回收等功能。</p>
	</li>
</ul>

<p><a href="https://baike.baidu.com/item/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC" target="_blank">惰性求值</a>亦为语言如<a href="https://baike.baidu.com/item/Haskell" target="_blank">Haskell</a>增加了额外的管理工作。</p>
