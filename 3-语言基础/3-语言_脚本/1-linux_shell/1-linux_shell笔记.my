<h1>linux_shell笔记</h1>

<h2><a href="http://www.runoob.com/try/runcode.php?filename=helloworld&amp;type=bash" target="blank">bash在线编辑</a></h2>

<h2>第一个shell脚本</h2>

<p>&nbsp;&nbsp; &nbsp;打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。</p>

<p>&nbsp;&nbsp; &nbsp;输入一些代码：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Hello World !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&ldquo;#!&rdquo; 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。</p>

<p>&nbsp;&nbsp; &nbsp;输入一些代码：<br />
&nbsp; &nbsp; &nbsp; &nbsp; cmd.sh:</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; #!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Hello World !&quot;<br />
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if [ $1 = &quot;java&quot; ]; then<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo this is java<br />
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;fi</p>

<p>&nbsp; &nbsp; &nbsp; &nbsp; 执行：cmd.sh java</p>

<h3>Shell有两种执行命令的方式</h3>

<p>&nbsp;&nbsp; &nbsp;交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。</p>

<p>&nbsp;&nbsp; &nbsp;批处理（Batch）：用户事先写一个Shell脚本(Script)，其中有很多条命令，让Shell一次把这些命令执行完，而不必一条一条地敲命令。</p>

<h3>运行Shell脚本有两种方法</h3>

<p>&nbsp;&nbsp; &nbsp;1&gt; 作为可执行程序</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;将上面的代码保存为test.sh，并 cd 到相应目录：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;chmod +x ./test.sh &nbsp;#使脚本具有执行权限<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;./test.sh &nbsp;#执行脚本<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意，一定要写成./test.sh，而不是test.sh。运行其它二进制的程序也一样，直接写test.sh，linux系统会去PATH里寻找有没有叫test.sh的，而只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里，你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;通过这种方式运行bash脚本，第一行一定要写对，好让系统查找到正确的解释器。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;这里的&quot;系统&quot;，其实就是shell这个应用程序（想象一下Windows Explorer），但我故意写成系统，是方便理解，既然这个系统就是指shell，那么一个使用/bin/sh作为解释器的脚本是不是可以省去第一行呢？是的。</p>

<p>&nbsp;&nbsp; &nbsp;2&gt; 作为解释器参数</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cd Desktop &nbsp;//先转到shell脚本(text.sh)所在的目录下。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/bin/sh test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/bin/php test.php<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>

<p>&nbsp;&nbsp; &nbsp;再看一个例子。下面的脚本使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Author : mozhiyan<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Copyright (c) http://see.xidian.edu.cn/cpp/linux/<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Script follows here:<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;What is your name?&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;read PERSON<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Hello, $PERSON&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;chmod +x ./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;What is your name?<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mozhiyan<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Hello, mozhiyan<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$</p>

<h2>Shell 变量.数据</h2>

<p>&nbsp;&nbsp; &nbsp;Shell变量：Shell变量的定义、删除变量、只读变量、变量类型</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Shell支持自定义变量。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;定义变量</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;定义变量时，变量名不加美元符号（$），如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;variableName=&quot;value&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;首个字符必须为字母（a-z，A-Z）。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;中间不能有空格，可以使用下划线（_）。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;不能使用标点符号。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;不能使用bash里的关键字（可用help命令查看保留关键字）。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;变量定义举例：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myUrl=&quot;http://see.xidian.edu.cn/cpp/linux/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myNum=100<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;使用变量</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;使用一个定义过的变量，只要在变量名前面加美元符号（$）即可，如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;your_name=&quot;mozhiyan&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo $your_name<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo ${your_name}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for skill in Ada Coffe Action Java&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;I am good at ${skill}Script&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果不给skill变量加花括号，写成echo &quot;I am good at $skillScript&quot;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;推荐给所有变量加上花括号，这是个好的编程习惯。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;重新定义变量</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;已定义的变量，可以被重新定义，如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myUrl=&quot;http://see.xidian.edu.cn/cpp/linux/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo ${myUrl}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo ${myUrl}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;这样写是合法的，但注意，第二次赋值的时候不能写 $myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;，使用变量的时候才加美元符（$）。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;只读变量</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;下面的例子尝试更改只读变量，结果报错：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myUrl=&quot;http://see.xidian.edu.cn/cpp/shell/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;readonly myUrl<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myUrl=&quot;http://see.xidian.edu.cn/cpp/danpianji/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本，结果如下：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/bin/sh: NAME: This variable is read only.</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;删除变量</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;使用 unset 命令可以删除变量。语法：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;unset variable_name<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;变量被删除后不能再次使用；unset 命令不能删除只读变量。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;myUrl=&quot;http://see.xidian.edu.cn/cpp/u/xitong/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;unset myUrl<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo $myUrl<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;上面的脚本没有任何输出。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;变量类型<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行shell时，会同时存在三种变量：</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1) 局部变量<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2) 环境变量<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3) shell变量<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>

<h2>Shell特殊变量</h2>

<p>例如：Shell $0, $#, $*, $@, $?, $$和命令行参数</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;前面已经讲到，变量名只能包含数字、字母和下划线，因为某些包含其他字符的变量有特殊含义，这样的变量被称为特殊变量。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如，$ 表示当前Shell进程的ID，即pid，看下面的代码：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$echo $$<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;29949</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;特殊变量列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;变量&nbsp;&nbsp; &nbsp;含义<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$0&nbsp;&nbsp; &nbsp;当前脚本的文件名<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$n&nbsp;&nbsp; &nbsp;传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$#&nbsp;&nbsp; &nbsp;传递给脚本或函数的参数个数。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$*&nbsp;&nbsp; &nbsp;传递给脚本或函数的所有参数。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$@&nbsp;&nbsp; &nbsp;传递给脚本或函数的所有参数。被双引号(&quot; &quot;)包含时，与 $* 稍有不同，下面将会讲到。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$?&nbsp;&nbsp; &nbsp;上个命令的退出状态，或函数的返回值。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$$&nbsp;&nbsp; &nbsp;当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;命令行参数</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;请看下面的脚本：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;File Name: $0&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;First Parameter : $1&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;First Parameter : $2&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Quoted Values: $@&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Quoted Values: $*&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Total Number of Parameters : $#&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh Zara Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File Name : ./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;First Parameter : Zara<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Second Parameter : Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Quoted Values: Zara Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Quoted Values: Zara Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Total Number of Parameters : 2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$* 和 $@ 的区别</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(&quot; &quot;)包含时，都以&quot;$1&quot; &quot;$2&quot; &hellip; &quot;$n&quot; 的形式输出所有参数。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;但是当它们被双引号(&quot; &quot;)包含时，&quot;$*&quot; 会将所有的参数作为一个整体，以&quot;$1 $2 &hellip; $n&quot;的形式输出所有参数；&quot;$@&quot; 会将各个参数分开，以&quot;$1&quot; &quot;$2&quot; &hellip; &quot;$n&quot; 的形式输出所有参数。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;下面的例子可以清楚的看到 $* 和 $@ 的区别：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;\$*=&quot; $*<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;\&quot;\$*\&quot;=&quot; &quot;$*&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;\$@=&quot; $@<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;\&quot;\$@\&quot;=&quot; &quot;$@&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;print each param from \$*&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for var in $*<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$var&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;print each param from \$@&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for var in $@<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$var&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;print each param from \&quot;\$*\&quot;&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for var in &quot;$*&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$var&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;print each param from \&quot;\$@\&quot;&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for var in &quot;$@&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;$var&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;执行 ./test.sh &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;，看到下面的结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$*= &nbsp;a b c d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&quot;$*&quot;= a b c d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$@= &nbsp;a b c d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&quot;$@&quot;= a b c d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print each param from $*<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;c<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print each param from $@<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;c<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print each param from &quot;$*&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a b c d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;print each param from &quot;$@&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;c<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;d<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;退出状态</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;不过，也有一些命令返回其他值，表示不同类型的错误。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;下面例子中，命令成功执行：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh Zara Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File Name : ./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;First Parameter : Zara<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Second Parameter : Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Quoted Values: Zara Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Quoted Values: Zara Ali<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Total Number of Parameters : 2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$echo $?<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$? 也可以表示函数的返回值，后续将会讲解。</p>

<h2>Shell字符串</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;单引号</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;str=&#39;this is a string&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;单引号字符串的限制：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;单引号字串中不能出现单引号（对单引号使用转义符后也不行）。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;双引号</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;your_name=&#39;qinjx&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;双引号的优点：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;双引号里可以有变量<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;双引号里可以出现转义字符<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;拼接字符串</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;your_name=&quot;qinjx&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;greeting=&quot;hello, &quot;$your_name&quot; !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;greeting_1=&quot;hello, ${your_name} !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo $greeting $greeting_1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;获取字符串长度</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;string=&quot;abcd&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo ${#string} #输出 4<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;提取子字符串</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;string=&quot;alibaba is a great company&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo ${string:1:4} #输出liba<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;查找子字符串</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;纯文本新窗口<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;string=&quot;alibaba is a great company&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo `expr index &quot;$string&quot; is`</p>

<h2>Shell数组：shell数组的定义、数组长度</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Shell在编程方面比Windows批处理强大很多，无论是在循环、运算。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似与C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;定义数组</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;在Shell中，用括号来表示数组，数组元素用&ldquo;空格&rdquo;符号分割开。定义数组的一般形式为：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;array_name=(value1 ... valuen)<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array_name=(value0 value1 value2 value3)<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;或者<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array_name=(<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;value0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;value1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;value2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;value3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;)</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;还可以单独定义数组的各个分量：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array_name[0]=value0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array_name[1]=value1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;array_name[2]=value2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;可以不使用连续的下标，而且下标的范围没有限制。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;读取数组</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;读取数组元素值的一般格式是：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;${array_name[index]}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;valuen=${array_name[2]}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[0]=&quot;Zara&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[1]=&quot;Qadir&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[2]=&quot;Mahnaz&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[3]=&quot;Ayan&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[4]=&quot;Daisy&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;First Index: ${NAME[0]}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Second Index: ${NAME[1]}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本，输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;First Index: Zara<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Second Index: Qadir<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;使用@ 或 * 可以获取数组中的所有元素，例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;${array_name[*]}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;${array_name[@]}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[0]=&quot;Zara&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[1]=&quot;Qadir&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[2]=&quot;Mahnaz&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[3]=&quot;Ayan&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NAME[4]=&quot;Daisy&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;First Method: ${NAME[*]}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Second Method: ${NAME[@]}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本，输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;First Method: Zara Qadir Mahnaz Ayan Daisy<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Second Method: Zara Qadir Mahnaz Ayan Daisy<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;获取数组的长度</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;获取数组长度的方法与获取字符串长度的方法相同，例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;纯文本新窗口<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 取得数组元素的个数<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;length=${#array_name[@]}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 或者<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;length=${#array_name[*]}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 取得数组单个元素的长度<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lengthn=${#array_name[n]}</p>

<h2>Shell 结构语句</h2>

<p>&nbsp;&nbsp; &nbsp;Shell运算符：Shell算数运算符、关系运算符、布尔运算符、字符串运算符等</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Bash 支持很多运算符，包括算数运算符、关系运算符、布尔运算符、字符串运算符和文件测试运算符。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如，两个数相加：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;val=`expr 2 + 2`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Total value : $val&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Total value : 4<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;两点注意：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;算术运算符</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;先来看一个使用算术运算符的例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=20<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;val=`expr $a + $b`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;a + b : $val&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;val=`expr $a - $b`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;a - b : $val&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;val=`expr $a \* $b`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;a * b : $val&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;val=`expr $b / $a`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;b / a : $val&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;val=`expr $b % $a`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;b % a : $val&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a == $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a != $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a + b : 30<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a - b : -10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a * b : 200<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b / a : 2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b % a : 0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;乘号(*)前边必须加反斜杠(\)才能实现乘法运算；<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if...then...fi 是条件语句，后续将会讲解。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;算术运算符列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运算符&nbsp;&nbsp; &nbsp;说明&nbsp;&nbsp; &nbsp;举例<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;+&nbsp;&nbsp; &nbsp;加法&nbsp;&nbsp; &nbsp;`expr $a + $b` 结果为 30。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-&nbsp;&nbsp; &nbsp;减法&nbsp;&nbsp; &nbsp;`expr $a - $b` 结果为 10。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*&nbsp;&nbsp; &nbsp;乘法&nbsp;&nbsp; &nbsp;`expr $a \* $b` 结果为 &nbsp;200。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/&nbsp;&nbsp; &nbsp;除法&nbsp;&nbsp; &nbsp;`expr $b / $a` 结果为 2。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;%&nbsp;&nbsp; &nbsp;取余&nbsp;&nbsp; &nbsp;`expr $b % $a` 结果为 0。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;=&nbsp;&nbsp; &nbsp;赋值&nbsp;&nbsp; &nbsp;a=$b 将把变量 b 的值赋给 a。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;==&nbsp;&nbsp; &nbsp;相等。用于比较两个数字，相同则返回 true。&nbsp;&nbsp; &nbsp;[ $a == $b ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!=&nbsp;&nbsp; &nbsp;不相等。用于比较两个数字，不相同则返回 true。&nbsp;&nbsp; &nbsp;[ $a != $b ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;关系运算符</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;先来看一个关系运算符的例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=20<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -eq $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -eq $b : a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -eq $b: a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -ne $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -ne $b: a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -ne $b : a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -gt $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -gt $b: a is greater than b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -gt $b: a is not greater than b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -lt $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt $b: a is less than b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt $b: a is not less than b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -ge $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -ge $b: a is greater or &nbsp;equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -ge $b: a is not greater or equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -le $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -le $b: a is less or &nbsp;equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -le $b: a is not less or equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -eq 20: a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -ne 20: a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -gt 20: a is not greater than b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -lt 20: a is less than b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -ge 20: a is not greater or equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -le 20: a is less or &nbsp;equal to b</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;关系运算符列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运算符&nbsp;&nbsp; &nbsp;说明&nbsp;&nbsp; &nbsp;举例<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-eq&nbsp;&nbsp; &nbsp;检测两个数是否相等，相等返回 true。&nbsp;&nbsp; &nbsp;[ $a -eq $b ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-ne&nbsp;&nbsp; &nbsp;检测两个数是否相等，不相等返回 true。&nbsp;&nbsp; &nbsp;[ $a -ne $b ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-gt&nbsp;&nbsp; &nbsp;检测左边的数是否大于右边的，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ $a -gt $b ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-lt&nbsp;&nbsp; &nbsp;检测左边的数是否小于右边的，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ $a -lt $b ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-ge&nbsp;&nbsp; &nbsp;检测左边的数是否大等于右边的，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ $a -ge $b ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-le&nbsp;&nbsp; &nbsp;检测左边的数是否小于等于右边的，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ $a -le $b ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;布尔运算符</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;先来看一个布尔运算符的例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=20<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a != $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a != $b : a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a != $b: a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -lt 100 -a $b -gt 15 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt 100 -a $b -gt 15 : returns true&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt 100 -a $b -gt 15 : returns false&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -lt 100 -o $b -gt 100 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt 100 -o $b -gt 100 : returns true&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt 100 -o $b -gt 100 : returns false&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a -lt 5 -o $b -gt 100 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt 100 -o $b -gt 100 : returns true&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a -lt 100 -o $b -gt 100 : returns false&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 != 20 : a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -lt 100 -a 20 -gt 15 : returns true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -lt 100 -o 20 -gt 100 : returns true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;10 -lt 5 -o 20 -gt 100 : returns false</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;布尔运算符列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运算符&nbsp;&nbsp; &nbsp;说明&nbsp;&nbsp; &nbsp;举例<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!&nbsp;&nbsp; &nbsp;非运算，表达式为 true 则返回 false，否则返回 true。&nbsp;&nbsp; &nbsp;[ ! false ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-o&nbsp;&nbsp; &nbsp;或运算，有一个表达式为 true 则返回 true。&nbsp;&nbsp; &nbsp;[ $a -lt 20 -o $b -gt 100 ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-a&nbsp;&nbsp; &nbsp;与运算，两个表达式都为 true 才返回 true。&nbsp;&nbsp; &nbsp;[ $a -lt 20 -a $b -gt 100 ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;字符串运算符</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;先来看一个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=&quot;abc&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=&quot;efg&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a = $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a = $b : a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a = $b: a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a != $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a != $b : a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a != $b: a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -z $a ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;-z $a : string length is zero&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;-z $a : string length is not zero&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -n $a ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;-n $a : string length is not zero&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;-n $a : string length is zero&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a : string is not empty&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;$a : string is empty&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;abc = efg: a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;abc != efg : a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-z abc : string length is not zero<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-n abc : string length is not zero<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;abc : string is not empty</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;字符串运算符列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运算符&nbsp;&nbsp; &nbsp;说明&nbsp;&nbsp; &nbsp;举例<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;=&nbsp;&nbsp; &nbsp;检测两个字符串是否相等，相等返回 true。&nbsp;&nbsp; &nbsp;[ $a = $b ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;!=&nbsp;&nbsp; &nbsp;检测两个字符串是否相等，不相等返回 true。&nbsp;&nbsp; &nbsp;[ $a != $b ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-z&nbsp;&nbsp; &nbsp;检测字符串长度是否为0，为0返回 true。&nbsp;&nbsp; &nbsp;[ -z $a ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-n&nbsp;&nbsp; &nbsp;检测字符串长度是否为0，不为0返回 true。&nbsp;&nbsp; &nbsp;[ -z $a ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;str&nbsp;&nbsp; &nbsp;检测字符串是否为空，不为空返回 true。&nbsp;&nbsp; &nbsp;[ $a ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;文件测试运算符</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;文件测试运算符用于检测 Unix 文件的各种属性。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如，变量 file 表示文件&ldquo;/var/www/tutorialspoint/unix/test.sh&rdquo;，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;file=&quot;/var/www/tutorialspoint/unix/test.sh&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -r $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File has read access&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File does not have read access&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -w $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File has write permission&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File does not have write permission&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -x $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File has execute permission&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File does not have execute permission&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -f $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File is an ordinary file&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;This is sepcial file&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -d $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File is a directory&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;This is not a directory&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -s $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File size is zero&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File size is not zero&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ -e $file ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File exists&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;File does not exist&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File has read access<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File has write permission<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File has execute permission<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File is an ordinary file<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;This is not a directory<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File size is zero<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File exists</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;文件测试运算符列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;操作符&nbsp;&nbsp; &nbsp;说明&nbsp;&nbsp; &nbsp;举例<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-b file&nbsp;&nbsp; &nbsp;检测文件是否是块设备文件，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -b $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-c file&nbsp;&nbsp; &nbsp;检测文件是否是字符设备文件，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -b $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-d file&nbsp;&nbsp; &nbsp;检测文件是否是目录，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -d $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-f file&nbsp;&nbsp; &nbsp;检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -f $file ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-g file&nbsp;&nbsp; &nbsp;检测文件是否设置了 SGID 位，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -g $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-k file&nbsp;&nbsp; &nbsp;检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -k $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-p file&nbsp;&nbsp; &nbsp;检测文件是否是具名管道，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -p $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-u file&nbsp;&nbsp; &nbsp;检测文件是否设置了 SUID 位，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -u $file ] 返回 false。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-r file&nbsp;&nbsp; &nbsp;检测文件是否可读，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -r $file ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-w file&nbsp;&nbsp; &nbsp;检测文件是否可写，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -w $file ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-x file&nbsp;&nbsp; &nbsp;检测文件是否可执行，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -x $file ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-s file&nbsp;&nbsp; &nbsp;检测文件是否为空（文件大小是否大于0），不为空返回 true。&nbsp;&nbsp; &nbsp;[ -s $file ] 返回 true。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-e file&nbsp;&nbsp; &nbsp;检测文件（包括目录）是否存在，如果是，则返回 true。&nbsp;&nbsp; &nbsp;[ -e $file ] 返回 true。</p>

<h2>Shell echo命令</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。命令格式：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo arg<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;您可以使用echo实现更复杂的输出格式控制。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示转义字符</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;\&quot;It is a test\&quot;&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;结果将是：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&quot;It is a test&quot;</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;双引号也可以省略。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示变量</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;name=&quot;OK&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;$name It is a test&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;结果将是：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;OK It is a test</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;同样双引号也可以省略。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果变量与其它字符相连的话，需要使用大括号（{ }）：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;mouth=8<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;${mouth}-1-2009&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;结果将是：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;8-1-2009<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示换行</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;OK!\n&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;It is a test&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;OK!<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;It is a test<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示不换行</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;OK!\c&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;It is a test&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;OK!It si a test<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示结果重定向至文件</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;It is a test&quot; &gt; myfile<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;原样输出字符串</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;若需要原样输出字符串（不进行转义），请使用单引号。例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &#39;$name\&quot;&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示命令执行结果</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo `date`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;结果将显示当前日期</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;从上面可看出，双引号可有可无，单引号主要用在原样输出中。</p>

<h2>shell printf命令：格式化输出语句</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如同 echo 命令，printf 命令也可以输出简单的字符串：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$printf &quot;Hello, Shell\n&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Hello, Shell<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf 不像 echo 那样会自动换行，必须显式添加换行符(\n)。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf 命令的语法：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf &nbsp;format-string &nbsp;[arguments...]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;format-string 为格式控制字符串，arguments 为参数列表。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf()在C语言入门教程中已经讲到，功能和用法与 printf 命令类似，请查看：C语言格式输出函数printf()详解</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;这里仅说明与C语言printf()函数的不同：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;printf 命令不用加括号<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;format-string 可以没有引号，但最好加上，单引号双引号均可。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;arguments 使用空格分隔，不用逗号。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;请看下面的例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# format-string为双引号<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf &quot;%d %s\n&quot; 1 &quot;abc&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1 abc<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 单引号与双引号效果一样&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf &#39;%d %s\n&#39; 1 &quot;abc&quot;&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1 abc<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 没有引号也可以输出<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf %s abcdef<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;abcdef<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf %s abc def<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;abcdef<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf &quot;%s\n&quot; abc def<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;abc<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;def<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf &quot;%s %s %s\n&quot; a b c d e f g h i j<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a b c<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;d e f<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;g h i<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;j<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf &quot;%s and %d \n&quot;&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;and 0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 如果以 %d 的格式来显示字符串，那么会有警告，提示无效的数字，此时默认置为 0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ printf &quot;The first program always prints&#39;%s,%d\n&#39;&quot; Hello Shell<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-bash: printf: Shell: invalid number<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The first program always prints &#39;Hello,0&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意，根据POSIX标准，浮点格式%e、%E、%f、%g与%G是&ldquo;不需要被支持&rdquo;。这是因为awk支持浮点预算，且有它自己的printf语句。这样Shell程序中需要将浮点数值进行格式化的打印时，可使用小型的awk程序实现。然而，内建于bash、ksh93和zsh中的printf命令都支持浮点格式。</p>

<h2>Shell if else语句</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if 语句通过关系运算符判断表达式的真假来决定执行哪个分支。Shell 有三种 if ... else 语句：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... fi 语句；<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... else ... fi 语句；<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... elif ... else ... fi 语句。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1) if ... else 语句</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... else 语句的语法：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ expression ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if expression is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果 expression 返回 true，then 后边的语句将会被执行；如果返回 false，不会执行任何语句。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写，后面也会遇见。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意：expression 和方括号([ ])之间必须有空格，否则会有语法错误。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=20<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a == $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a != $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2) if ... else ... fi 语句</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... else ... fi 语句的语法：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ expression ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if expression is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if expression is not true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果 expression 返回 true，那么 then 后边的语句将会被执行；否则，执行 else 后边的语句。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=20<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a == $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is not equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;执行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a is not equal to b<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3) if ... elif ... fi 语句</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... elif ... fi 语句可以对多个条件进行判断，语法为：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ expression 1 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if expression 1 is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;elif [ expression 2 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if expression 2 is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;elif [ expression 3 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if expression 3 is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if no expression is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;哪一个 expression 的值为 true，就执行哪个 expression 后面的语句；如果都为 false，那么不执行任何语句。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;b=20<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if [ $a == $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is equal to b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;elif [ $a -gt $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is greater than b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;elif [ $a -lt $b ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;a is less than b&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;None of the condition met&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a is less than b</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... else 语句也可以写成一行，以命令的方式来运行，像这样：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if test $[2*3] -eq $[1+5]; then echo &#39;The two numbers are equal!&#39;; fi;</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ... else 语句也经常与 test 命令结合使用，如下所示：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;num1=$[2*3]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;num2=$[1+5]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if test $[num1] -eq $[num2]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &#39;The two numbers are equal!&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &#39;The two numbers are not equal!&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The two numbers are equal!<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;test 命令用于检查某个条件是否成立，与方括号([ ])类似。</p>

<h2>Shell case esac语句</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case ... esac 与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case 语句匹配一个值或一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case 值 in<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;模式1)<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;模式2）<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;*)<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;esac<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case工作方式如上所示。取值后面必须为关键字 in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。;; 与其他语言中的 break 类似，意思是跳到整个 case 语句的最后。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;下面的脚本提示输入1到4，与每一种模式进行匹配：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &#39;Input a number between 1 to 4&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &#39;Your number is:\c&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;read aNum<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case $aNum in<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1) &nbsp;echo &#39;You select 1&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2) &nbsp;echo &#39;You select 2&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3) &nbsp;echo &#39;You select 3&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4) &nbsp;echo &#39;You select 4&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;*) &nbsp;echo &#39;You do not select a number between 1 to 4&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;esac<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;输入不同的内容，会有不同的结果，例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Input a number between 1 to 4<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Your number is:3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;You select 3</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;再举一个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;option=&quot;${1}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;case ${option} in<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; -f) FILE=&quot;${2}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;File name is $FILE&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; -d) DIR=&quot;${2}&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Dir name is $DIR&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; *)&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;`basename ${0}`:usage: [-f file] | [-d directory]&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;exit 1 # Command to come out of the program with status 1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;esac<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;test.sh: usage: [ -f filename ] | [ -d directory ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ ./test.sh -f index.htm<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ vi test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ ./test.sh -f index.htm<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;File name is index.htm<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$ ./test.sh -d unix<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Dir name is unix<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$</p>

<h2>Shell for循环</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;与其他编程语言类似，Shell支持for循环。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for循环一般格式为：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for 变量 in 列表<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;command2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;...<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;commandN<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;列表是一组值（数字、字符串等）组成的序列，每个值通过空格分隔。每循环一次，就将列表中的下一个值赋给变量。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;in 列表是可选的，如果不用它，for 循环使用命令行的位置参数。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如，顺序输出当前列表中的数字：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for loop in 1 2 3 4 5<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The value is: $loop&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value is: 1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value is: 2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value is: 3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value is: 4<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value is: 5</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;顺序输出字符串中的字符：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for str in &#39;This is a string&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo $str<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;This is a string</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;显示主目录下以 .bash 开头的文件：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for FILE in $HOME/.bash*<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo $FILE<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/root/.bash_history<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/root/.bash_logout<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/root/.bash_profile<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;/root/.bashrc</p>

<h2>Shell while循环</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while command<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed if command is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;命令执行完毕，控制返回循环顶部，从头开始直至测试条件为假。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;以下是一个基本的while循环，测试条件是：如果COUNTER小于5，那么返回 true。COUNTER从0开始，每次循环处理时，COUNTER加1。运行上述脚本，返回数字1到5，然后终止。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;COUNTER=0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while [ $COUNTER -lt 5 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;COUNTER=&#39;expr $COUNTER+1&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo $COUNTER<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本，输出：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;4<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;5</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按&lt;Ctrl-D&gt;结束循环。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &#39;type &lt;CTRL-D&gt; to terminate&#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo -n &#39;enter your most liked film: &#39;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while read FILM<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Yeah! great film the $FILM&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本，输出类似下面：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;type &lt;CTRL-D&gt; to terminate<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;enter your most liked film: Sound of Music<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Yeah! great film the Sound of Music</p>

<h2>Shell until循环</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般while循环优于until循环，但在某些时候，也只是极少数情况下，until 循环更加有用。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;until 循环格式为：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;until command<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Statement(s) to be executed until command is true<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;command 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如，使用 until 命令输出 0 ~ 9 的数字：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a=0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;until [ ! $a -lt 10 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo $a<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; a=`expr $a + 1`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;4<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;5<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;6<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;7<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;8<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;9</p>

<p>&nbsp;&nbsp; &nbsp;Shell break和continue命令</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，像大多数编程语言一样，Shell也使用 break 和 continue 来跳出循环。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break命令</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break命令允许跳出所有循环（终止执行后面的所有循环）。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，就要使用break命令。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while :<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo -n &quot;Input a number between 1 to 5: &quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;read aNum<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;case $aNum in<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1|2|3|4|5) echo &quot;Your number is $aNum!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*) echo &quot;You do not select a number between 1 to 5, game is over!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;break<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;esac<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;在嵌套循环中，break 命令后面还可以跟一个整数，表示跳出第几层循环。例如：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;break n<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;表示跳出第 n 层循环。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;下面是一个嵌套循环的例子，如果 var1 等于 2，并且 var2 等于 0，就跳出循环：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for var1 in 1 2 3<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; for var2 in 0 5<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if [ $var1 -eq 2 -a $var2 -eq 0 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break 2<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; echo &quot;$var1 $var2&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如上，break 2 表示直接跳出外层循环。运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1 0<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;1 5<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue命令</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;对上面的例子进行修改：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while :<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo -n &quot;Input a number between 1 to 5: &quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;read aNum<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;case $aNum in<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1|2|3|4|5) echo &quot;Your number is $aNum!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*) echo &quot;You do not select a number between 1 to 5!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Game is over!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;esac<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;Game is over!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;永远不会被执行。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;同样，continue 后面也可以跟一个数字，表示跳出第几层循环。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;再看一个 continue 的例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;NUMS=&quot;1 2 3 4 5 6 7&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;for NUM in $NUMS<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;do<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Q=`expr $NUM % 2`<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; if [ $Q -eq 0 ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; then<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;echo &quot;Number is an even number!!&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; fi<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;Found odd number&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;done<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Found odd number<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Number is an even number!!<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Found odd number<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Number is an even number!!<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Found odd number<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Number is an even number!!<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Found odd number</p>

<h2>Shell 函数</h2>

<p>&nbsp;&nbsp; &nbsp;Shell函数：Shell函数返回值、删除函数、在终端调用函数</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;函数可以让我们将一个复杂功能划分成若干模块，让程序结构更加清晰，代码重复利用率更高。像其他编程语言一样，Shell 也支持函数。Shell 函数必须先定义后使用。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Shell 函数的定义格式如下：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function_name () {<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;list of commands<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;[ return value ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果你愿意，也可以在函数名前加上关键字 function：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;function function_name () {<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;list of commands<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;[ return value ]<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;函数返回值，可以显式增加return语句；如果不加，会将最后一条命令运行结果作为返回值。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：&ldquo;numeric argument required&rdquo;。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果一定要让函数返回字符串，那么可以先定义一个变量，用来接收函数的计算结果，脚本在需要的时候访问这个变量来获得函数返回值。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;先来看一个例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Define your function here<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Hello () {<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;Url is http://see.xidian.edu.cn/cpp/shell/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Invoke your function<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Hello<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$./test.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Hello World<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;调用函数只需要给出函数名，不需要加括号。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;再来看一个带有return语句的函数：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;funWithReturn(){<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The function is to get the sum of two numbers...&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo -n &quot;Input first number: &quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;read aNum<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo -n &quot;Input another number: &quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;read anotherNum<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The two numbers are $aNum and $anotherNum !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;return $(($aNum+$anotherNum))<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;funWithReturn<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Capture value returnd by last command<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;ret=$?<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo &quot;The sum of two numbers is $ret !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The function is to get the sum of two numbers...<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Input first number: 25<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Input another number: 50<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The two numbers are 25 and 50 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The sum of two numbers is 75 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;函数返回值在调用该函数后通过 $? 来获得。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;再来看一个函数嵌套的例子：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# Calling one function from another<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;number_one () {<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;Url_1 is http://see.xidian.edu.cn/cpp/shell/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; number_two<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;number_two () {<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; echo &quot;Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;number_one<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Url_1 is http://see.xidian.edu.cn/cpp/shell/<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Url_2 is http://see.xidian.edu.cn/cpp/u/xitong/<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;像删除变量一样，删除函数也可以使用 unset 命令，不过要加上 .f 选项，如下所示：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$unset .f function_name<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果你希望直接从终端调用函数，可以将函数定义在主目录下的 .profile 文件，这样每次登录后，在命令提示符后面输入函数名字就可以立即调用。</p>

<h2>Shell函数参数</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;带参数的函数示例：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;funWithParam(){<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The value of the first parameter is $1 !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The value of the second parameter is $2 !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The value of the tenth parameter is $10 !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The value of the tenth parameter is ${10} !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The value of the eleventh parameter is ${11} !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The amount of the parameters is $# !&quot; &nbsp;# 参数个数<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;echo &quot;The string of the parameters is $* !&quot; &nbsp;# 传递给函数的所有参数<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;funWithParam 1 2 3 4 5 6 7 8 9 34 73<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;运行脚本：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value of the first parameter is 1 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value of the second parameter is 2 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value of the tenth parameter is 10 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value of the tenth parameter is 34 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The value of the eleventh parameter is 73 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The amount of the parameters is 12 !<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;The string of the parameters is 1 2 3 4 5 6 7 8 9 34 73 !&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;另外，还有几个特殊变量用来处理参数，前面已经提到：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;特殊变量&nbsp;&nbsp; &nbsp;说明<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$#&nbsp;&nbsp; &nbsp;传递给函数的参数个数。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$*&nbsp;&nbsp; &nbsp;显示所有传递给函数的参数。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$@&nbsp;&nbsp; &nbsp;与$*相同，但是略有区别，请查看Shell特殊变量。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$?&nbsp;&nbsp; &nbsp;函数的返回值。</p>

<h2>Shell注释</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;以&ldquo;#&rdquo;开头的行就是注释，会被解释器忽略。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;sh里没有多行注释，只能每一行加一个#号。只能像这样：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#--------------------------------------------<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 这是一个自动打ipa的脚本，基于webfrogs的ipa-build书写：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# https://github.com/webfrogs/xcode_shell/blob/master/ipa-build<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 功能：自动为etao ios app打包，产出物为14个渠道的ipa包<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 特色：全自动打包，不需要输入任何参数<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#--------------------------------------------<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;##### 用户配置区 开始 #####<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 项目根目录，推荐将此脚本放在项目的根目录，这里就不用改了<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# 应用名，确保和Xcode里Product下的target_name.app名字一致<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;##### 用户配置区 结束 &nbsp;#####<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</p>

<h2>Shell文件包含</h2>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;像其他语言一样，Shell 也可以包含外部脚本，将外部脚本的内容合并到当前脚本。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Shell 中包含脚本可以使用：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;. filename<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;或<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;source filename<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;两种方式的效果相同，简单起见，一般使用点号(.)，但是注意点号(.)和文件名中间有一空格。</p>

<p>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;例如，创建两个脚本，一个是被调用脚本 subscript.sh，内容如下：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;url=&quot;http://see.xidian.edu.cn/cpp/view/2738.html&quot;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;一个是主文件 main.sh，内容如下：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;. ./subscript.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;echo $url<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;执行脚本：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$chomd +x main.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;./main.sh<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;http://see.xidian.edu.cn/cpp/view/2738.html<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;注意：被包含脚本不需要有执行权限。</p>

<p>Shell替换：Shell变量替换，命令替换，转义字符</p>

<p>&nbsp;&nbsp; &nbsp;如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。</p>

<p>&nbsp;&nbsp; &nbsp;举个例子：<br />
&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;a=10<br />
&nbsp;&nbsp; &nbsp;echo -e &quot;Value of a is $a \n&quot;<br />
&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;Value of a is 10<br />
&nbsp;&nbsp; &nbsp;这里 -e 表示对转义字符进行替换。如果不使用 -e 选项，将会原样输出：<br />
&nbsp;&nbsp; &nbsp;Value of a is 10\n</p>

<p>&nbsp;&nbsp; &nbsp;下面的转义字符都可以用在 echo 中：<br />
&nbsp;&nbsp; &nbsp;转义字符&nbsp;&nbsp; &nbsp;含义<br />
&nbsp;&nbsp; &nbsp;\\&nbsp;&nbsp; &nbsp;反斜杠<br />
&nbsp;&nbsp; &nbsp;\a&nbsp;&nbsp; &nbsp;警报，响铃<br />
&nbsp;&nbsp; &nbsp;\b&nbsp;&nbsp; &nbsp;退格（删除键）<br />
&nbsp;&nbsp; &nbsp;\f&nbsp;&nbsp; &nbsp;换页(FF)，将当前位置移到下页开头<br />
&nbsp;&nbsp; &nbsp;\n&nbsp;&nbsp; &nbsp;换行<br />
&nbsp;&nbsp; &nbsp;\r&nbsp;&nbsp; &nbsp;回车<br />
&nbsp;&nbsp; &nbsp;\t&nbsp;&nbsp; &nbsp;水平制表符（tab键）&nbsp;<br />
&nbsp;&nbsp; &nbsp;\v&nbsp;&nbsp; &nbsp;垂直制表符 可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。<br />
&nbsp;&nbsp; &nbsp;命令替换</p>

<p>&nbsp;&nbsp; &nbsp;命令替换是指Shell可以先执行命令，将输出结果暂时保存，在适当的地方输出。</p>

<p>&nbsp;&nbsp; &nbsp;命令替换的语法：<br />
&nbsp;&nbsp; &nbsp;`command`<br />
&nbsp;&nbsp; &nbsp;注意是反引号，不是单引号，这个键位于 Esc 键下方。</p>

<p>&nbsp;&nbsp; &nbsp;下面的例子中，将命令执行结果保存在变量中：<br />
&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;DATE=`date`<br />
&nbsp;&nbsp; &nbsp;echo &quot;Date is $DATE&quot;<br />
&nbsp;&nbsp; &nbsp;USERS=`who | wc -l`<br />
&nbsp;&nbsp; &nbsp;echo &quot;Logged in user are $USERS&quot;<br />
&nbsp;&nbsp; &nbsp;UP=`date ; uptime`<br />
&nbsp;&nbsp; &nbsp;echo &quot;Uptime is $UP&quot;<br />
&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;Date is Thu Jul &nbsp;2 03:59:57 MST 2009<br />
&nbsp;&nbsp; &nbsp;Logged in user are 1<br />
&nbsp;&nbsp; &nbsp;Uptime is Thu Jul &nbsp;2 03:59:57 MST 2009<br />
&nbsp;&nbsp; &nbsp;03:59:57 up 20 days, 14:03, &nbsp;1 user, &nbsp;load avg: 0.13, 0.07, 0.15<br />
&nbsp;&nbsp; &nbsp;变量替换</p>

<p>&nbsp;&nbsp; &nbsp;变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值</p>

<p>&nbsp;&nbsp; &nbsp;可以使用的变量替换形式：<br />
&nbsp;&nbsp; &nbsp;形式&nbsp;&nbsp; &nbsp;说明<br />
&nbsp;&nbsp; &nbsp;${var}&nbsp;&nbsp; &nbsp;变量本来的值<br />
&nbsp;&nbsp; &nbsp;${var:-word}&nbsp;&nbsp; &nbsp;如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。<br />
&nbsp;&nbsp; &nbsp;${var:=word}&nbsp;&nbsp; &nbsp;如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。<br />
&nbsp;&nbsp; &nbsp;${var:?message}&nbsp;&nbsp; &nbsp;如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。<br />
&nbsp;&nbsp; &nbsp;若此替换出现在Shell脚本中，那么脚本将停止运行。<br />
&nbsp;&nbsp; &nbsp;${var:+word}&nbsp;&nbsp; &nbsp;如果变量 var 被定义，那么返回 word，但不改变 var 的值。<br />
&nbsp;&nbsp; &nbsp;请看下面的例子：<br />
&nbsp;&nbsp; &nbsp;#!/bin/bash</p>

<p>&nbsp;&nbsp; &nbsp;echo ${var:-&quot;Variable is not set&quot;}<br />
&nbsp;&nbsp; &nbsp;echo &quot;1 - Value of var is ${var}&quot;</p>

<p>&nbsp;&nbsp; &nbsp;echo ${var:=&quot;Variable is not set&quot;}<br />
&nbsp;&nbsp; &nbsp;echo &quot;2 - Value of var is ${var}&quot;</p>

<p>&nbsp;&nbsp; &nbsp;unset var<br />
&nbsp;&nbsp; &nbsp;echo ${var:+&quot;This is default value&quot;}<br />
&nbsp;&nbsp; &nbsp;echo &quot;3 - Value of var is $var&quot;</p>

<p>&nbsp;&nbsp; &nbsp;var=&quot;Prefix&quot;<br />
&nbsp;&nbsp; &nbsp;echo ${var:+&quot;This is default value&quot;}<br />
&nbsp;&nbsp; &nbsp;echo &quot;4 - Value of var is $var&quot;</p>

<p>&nbsp;&nbsp; &nbsp;echo ${var:?&quot;Print this message&quot;}<br />
&nbsp;&nbsp; &nbsp;echo &quot;5 - Value of var is ${var}&quot;<br />
&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;Variable is not set<br />
&nbsp;&nbsp; &nbsp;1 - Value of var is<br />
&nbsp;&nbsp; &nbsp;Variable is not set<br />
&nbsp;&nbsp; &nbsp;2 - Value of var is Variable is not set<br />
&nbsp;&nbsp; &nbsp;3 - Value of var is<br />
&nbsp;&nbsp; &nbsp;This is default value<br />
&nbsp;&nbsp; &nbsp;4 - Value of var is Prefix<br />
&nbsp;&nbsp; &nbsp;Prefix<br />
&nbsp;&nbsp; &nbsp;5 - Value of var is Prefix</p>

<h2>Shell输入输出重定向：</h2>

<p>Shell Here Document，/dev/null文件</p>

<p>&nbsp;&nbsp; &nbsp;Unix 命令默认从标准输入设备(stdin)获取输入，将结果输出到标准输出设备(stdout)显示。一般情况下，标准输入设备就是键盘，标准输出设备就是终端，即显示器。<br />
&nbsp;&nbsp; &nbsp;输出重定向</p>

<p>&nbsp;&nbsp; &nbsp;命令的输出不仅可以是显示器，还可以很容易的转移向到文件，这被称为输出重定向。</p>

<p>&nbsp;&nbsp; &nbsp;命令输出重定向的语法为：<br />
&nbsp;&nbsp; &nbsp;$ command &gt; file<br />
&nbsp;&nbsp; &nbsp;这样，输出到显示器的内容就可以被重定向到文件。</p>

<p>&nbsp;&nbsp; &nbsp;例如，下面的命令在显示器上不会看到任何输出：<br />
&nbsp;&nbsp; &nbsp;$ who &gt; users<br />
&nbsp;&nbsp; &nbsp;打开 users 文件，可以看到下面的内容：<br />
&nbsp;&nbsp; &nbsp;$ cat users<br />
&nbsp;&nbsp; &nbsp;oko &nbsp; &nbsp; &nbsp; &nbsp; tty01 &nbsp; Sep 12 07:30<br />
&nbsp;&nbsp; &nbsp;ai &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tty15 &nbsp; Sep 12 13:32<br />
&nbsp;&nbsp; &nbsp;ruth &nbsp; &nbsp; &nbsp; &nbsp;tty21 &nbsp; Sep 12 10:10<br />
&nbsp;&nbsp; &nbsp;pat &nbsp; &nbsp; &nbsp; &nbsp; tty24 &nbsp; Sep 12 13:07<br />
&nbsp;&nbsp; &nbsp;steve &nbsp; &nbsp; &nbsp; tty25 &nbsp; Sep 12 13:03<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;输出重定向会覆盖文件内容，请看下面的例子：<br />
&nbsp;&nbsp; &nbsp;$ echo line 1 &gt; users<br />
&nbsp;&nbsp; &nbsp;$ cat users<br />
&nbsp;&nbsp; &nbsp;line 1<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：<br />
&nbsp;&nbsp; &nbsp;$ echo line 2 &gt;&gt; users<br />
&nbsp;&nbsp; &nbsp;$ cat users<br />
&nbsp;&nbsp; &nbsp;line 1<br />
&nbsp;&nbsp; &nbsp;line 2<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;输入重定向</p>

<p>&nbsp;&nbsp; &nbsp;和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：<br />
&nbsp;&nbsp; &nbsp;command &lt; file<br />
&nbsp;&nbsp; &nbsp;这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>

<p>&nbsp;&nbsp; &nbsp;注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p>

<p>&nbsp;&nbsp; &nbsp;例如，计算 users 文件中的行数，可以使用下面的命令：<br />
&nbsp;&nbsp; &nbsp;$ wc -l users<br />
&nbsp;&nbsp; &nbsp;2 users<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;也可以将输入重定向到 users 文件：<br />
&nbsp;&nbsp; &nbsp;$ wc -l &lt; users<br />
&nbsp;&nbsp; &nbsp;2<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。<br />
&nbsp;&nbsp; &nbsp;重定向深入讲解</p>

<p>&nbsp;&nbsp; &nbsp;一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：<br />
&nbsp;&nbsp; &nbsp;标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。<br />
&nbsp;&nbsp; &nbsp;标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。<br />
&nbsp;&nbsp; &nbsp;标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</p>

<p>&nbsp;&nbsp; &nbsp;默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>

<p>&nbsp;&nbsp; &nbsp;如果希望 stderr 重定向到 file，可以这样写：<br />
&nbsp;&nbsp; &nbsp;$command 2 &gt; file<br />
&nbsp;&nbsp; &nbsp;如果希望 stderr 追加到 file 文件末尾，可以这样写：<br />
&nbsp;&nbsp; &nbsp;$command 2 &gt;&gt; file<br />
&nbsp;&nbsp; &nbsp;2 表示标准错误文件(stderr)。</p>

<p>&nbsp;&nbsp; &nbsp;如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：<br />
&nbsp;&nbsp; &nbsp;$command &gt; file 2&gt;&amp;1<br />
&nbsp;&nbsp; &nbsp;或<br />
&nbsp;&nbsp; &nbsp;$command &gt;&gt; file 2&gt;&amp;1<br />
&nbsp;&nbsp; &nbsp;如果希望对 stdin 和 stdout 都重定向，可以这样写：<br />
&nbsp;&nbsp; &nbsp;$command &lt; file1 &gt;file2<br />
&nbsp;&nbsp; &nbsp;command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。&nbsp;</p>

<p>&nbsp;&nbsp; &nbsp;全部可用的重定向命令列表<br />
&nbsp;&nbsp; &nbsp;命令&nbsp;&nbsp; &nbsp;说明<br />
&nbsp;&nbsp; &nbsp;command &gt; file&nbsp;&nbsp; &nbsp;将输出重定向到 file。<br />
&nbsp;&nbsp; &nbsp;command &lt; file&nbsp;&nbsp; &nbsp;将输入重定向到 file。<br />
&nbsp;&nbsp; &nbsp;command &gt;&gt; file&nbsp;&nbsp; &nbsp;将输出以追加的方式重定向到 file。<br />
&nbsp;&nbsp; &nbsp;n &gt; file&nbsp;&nbsp; &nbsp;将文件描述符为 n 的文件重定向到 file。<br />
&nbsp;&nbsp; &nbsp;n &gt;&gt; file&nbsp;&nbsp; &nbsp;将文件描述符为 n 的文件以追加的方式重定向到 file。<br />
&nbsp;&nbsp; &nbsp;n &gt;&amp; m&nbsp;&nbsp; &nbsp;将输出文件 m 和 n 合并。<br />
&nbsp;&nbsp; &nbsp;n &lt;&amp; m&nbsp;&nbsp; &nbsp;将输入文件 m 和 n 合并。<br />
&nbsp;&nbsp; &nbsp;&lt;&lt; tag&nbsp;&nbsp; &nbsp;将开始标记 tag 和结束标记 tag 之间的内容作为输入。<br />
&nbsp;&nbsp; &nbsp;Here Document</p>

<p>&nbsp;&nbsp; &nbsp;Here Document 目前没有统一的翻译，这里暂译为&rdquo;嵌入文档&ldquo;。Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：<br />
&nbsp;&nbsp; &nbsp;command &lt;&lt; delimiter<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;document<br />
&nbsp;&nbsp; &nbsp;delimiter<br />
&nbsp;&nbsp; &nbsp;它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>

<p>&nbsp;&nbsp; &nbsp;注意：<br />
&nbsp;&nbsp; &nbsp;结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。<br />
&nbsp;&nbsp; &nbsp;开始的delimiter前后的空格会被忽略掉。</p>

<p>&nbsp;&nbsp; &nbsp;下面的例子，通过 wc -l 命令计算 document 的行数：<br />
&nbsp;&nbsp; &nbsp;$wc -l &lt;&lt; EOF<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;This is a simple lookup program<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;for good (and bad) restaurants<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;in Cape Town.<br />
&nbsp;&nbsp; &nbsp;EOF<br />
&nbsp;&nbsp; &nbsp;3<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;也可以 将 Here Document 用在脚本中，例如：<br />
&nbsp;&nbsp; &nbsp;#!/bin/bash<br />
&nbsp;&nbsp; &nbsp;cat &lt;&lt; EOF<br />
&nbsp;&nbsp; &nbsp;This is a simple lookup program<br />
&nbsp;&nbsp; &nbsp;for good (and bad) restaurants<br />
&nbsp;&nbsp; &nbsp;in Cape Town.<br />
&nbsp;&nbsp; &nbsp;EOF<br />
&nbsp;&nbsp; &nbsp;运行结果：<br />
&nbsp;&nbsp; &nbsp;This is a simple lookup program<br />
&nbsp;&nbsp; &nbsp;for good (and bad) restaurants<br />
&nbsp;&nbsp; &nbsp;in Cape Town.</p>

<p>&nbsp;&nbsp; &nbsp;下面的脚本通过 vi 编辑器将 document 保存到 test.txt 文件：<br />
&nbsp;&nbsp; &nbsp;#!/bin/sh<br />
&nbsp;&nbsp; &nbsp;filename=test.txt<br />
&nbsp;&nbsp; &nbsp;vi $filename &lt;&lt;EndOfCommands<br />
&nbsp;&nbsp; &nbsp;i<br />
&nbsp;&nbsp; &nbsp;This file was created automatically from<br />
&nbsp;&nbsp; &nbsp;a shell script<br />
&nbsp;&nbsp; &nbsp;^[<br />
&nbsp;&nbsp; &nbsp;ZZ<br />
&nbsp;&nbsp; &nbsp;EndOfCommands<br />
&nbsp;&nbsp; &nbsp;运行脚本：<br />
&nbsp;&nbsp; &nbsp;$ sh test.sh<br />
&nbsp;&nbsp; &nbsp;Vim: Warning: Input is not from a terminal<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;打开 test.txt，可以看到下面的内容：<br />
&nbsp;&nbsp; &nbsp;$ cat test.txt<br />
&nbsp;&nbsp; &nbsp;This file was created automatically from<br />
&nbsp;&nbsp; &nbsp;a shell script<br />
&nbsp;&nbsp; &nbsp;$<br />
&nbsp;&nbsp; &nbsp;/dev/null 文件</p>

<p>&nbsp;&nbsp; &nbsp;如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：<br />
&nbsp;&nbsp; &nbsp;$ command &gt; /dev/null<br />
&nbsp;&nbsp; &nbsp;/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&rdquo;禁止输出&ldquo;的效果。</p>

<p>&nbsp;&nbsp; &nbsp;如果希望屏蔽 stdout 和 stderr，可以这样写：<br />
&nbsp;&nbsp; &nbsp;纯文本新窗口<br />
&nbsp;&nbsp; &nbsp;$ command &gt; /dev/null 2&gt;&amp;1</p>
