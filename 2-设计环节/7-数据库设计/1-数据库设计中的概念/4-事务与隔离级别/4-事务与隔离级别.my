<h1>数据库事务与隔离级别</h1>

<h2>数据库事务定义</h2>

<p><a href="http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1" target="_blank">数据库事务</a>(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列<a href="http://baike.baidu.com/item/%E6%93%8D%E4%BD%9C/33052" target="_blank">操作</a>，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。</p>

<h2>数据库四大特性</h2>

<p>数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别。</p>

<p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性：</p>

<h3>⑴ 原子性（Atomicity）</h3>

<p>　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>

<h3>⑵ 一致性（Consistency）</h3>

<p>　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>

<p>　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>

<h3>⑶ 隔离性（Isolation）</h3>

<p>　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>

<p>　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>

<p>　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。</p>

<h3>⑷ 持久性（Durability）</h3>

<p>　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>

<p>　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>

<p>　　以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>

<h2>隔离级别及含义</h2>

<h3>事务隔离级别（transaction isolation levels）：</h3>

<p>隔离级别就是对对事务并发控制的等级。ANSI/ ISO SQL将其分为串行化（SERIALIZABLE）、可重复读（REPEATABLE READ）、读已提交（READ COMMITED）、读未提交（READ UNCOMMITED）四个等级。为了实现隔离级别通常<a href="http://lib.csdn.net/base/mysql" target="_blank" title="MySQL知识库">数据库</a>采用锁（Lock）。一般在编程的时候只需要设置隔离等级，至于具体采用什么锁则由数据库来设置。首先介绍四种等级，然后举例解释后面三个等级（可重复读、读已提交、读未提交）中会出现的并发问题。</p>

<h4>串行化（SERIALIZABLE）：</h4>

<p>所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）。对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询（如选取年龄在10到30之间的用户）的时候，需要获取范围锁（range lock）。如果不是基于锁实现并发控制的数据库，则检查到有违反串行操作的事务时，需要滚回该事务。</p>

<h4>可重复读（REPEATABLE READ）：</h4>

<p>所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。</p>

<h4>读已提交（READ COMMITED）：</h4>

<p>被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。该等级也是SQL Server默认的隔离等级。</p>

<h4>读未提交（READ UNCOMMITED）：</h4>

<p>这是最低的隔离等级，允许其他事务看到没有提交的数据。这种等级会导致脏读（Dirty Read）。</p>

<h3>数据库并发访问可能引起的问题</h3>

<h4>1. 脏读(事务没提交，提前读取)：</h4>

<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>

<h4>2. 不可重复读(两次读的不一致) ：</h4>

<p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。  </p>

<h4>3. 幻读 :</h4>

<p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。  </p>

<h4>4.第一类更新丢失(回滚丢失)： </h4>

<p>当2个事务更新相同的数据源，如果第一个事务被提交，而另外一个事务却被撤销，那么会连同第一个事务所做的跟新也被撤销。也就是说第一个事务做的跟新丢失了。 </p>

<h4>5.第二类更新丢失(覆盖丢失)： </h4>

<p>第二类更新丢失实在实际应用中经常遇到的并发问题，他和不可重复读本质上是同一类并发问题，通常他被看做不可重复读的特例：当2个或这个多个事务查询同样的记录然后各自基于最初的查询结果更新该行时，会造成第二类丢失更新。因为每个事务都不知道不知道其他事务的存在，最后一个事务对记录做的修改将覆盖其他事务对该记录做的已提交的跟新... </p>

<p> </p>

<h2>隔离级别与读错误关系</h2>

<table>
<tbody>
<tr>
<td>　隔离级别</td>
<td>可避免错误</td>
</tr>
<tr>
<td>　① Serializable (串行化)：</td>
<td>脏读、不可重复读、幻读</td>
</tr>
<tr>
<td>　② Repeatable read (可重复读)：</td>
<td>脏读、不可重复读</td>
</tr>
<tr>
<td>　③ Read committed (读已提交)：</td>
<td>脏读</td>
</tr>
<tr>
<td>　④ Read uncommitted (读未提交)：</td>
<td>最低级别，任何情况都无法保证。</td>
</tr>
</tbody>
</table>

<p> </p>

<h2>mysql和java的支持</h2>

<p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。</p>

<p>　　在MySQL数据库中查看当前事务的隔离级别：</p>

<pre>
select @@tx_isolation;</pre>

<p>　　在MySQL数据库中设置事务的隔离 级别：</p>

<pre>
set [glogal | session] transaction isolation level 隔离级别名称;

set tx_isolation=’隔离级别名称;’</pre>

<p>例1：查看当前事务的隔离级别：</p>

<p>　　<img alt="" src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202200007-1111796802.png" /></p>

<p>例2：将事务的隔离级别设置为Read uncommitted级别：</p>

<p>　　<img alt="" src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202224241-2101542210.png" /></p>

<p>或：</p>

<p>　　<img alt="" src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202245210-345198166.png" /></p>

<p>记住：设置数据库的隔离级别一定要是在开启事务之前！</p>

<p>　　如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：</p>

<p>　　<img alt="" src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202333460-377269897.png" /></p>

<p>在JDBC中设置隔离级别的部分代码：</p>

<p>　　<img alt="" src="http://images2015.cnblogs.com/blog/787876/201603/787876-20160313202355694-2106931487.png" /></p>

<p>　　后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p>

<p> </p>
