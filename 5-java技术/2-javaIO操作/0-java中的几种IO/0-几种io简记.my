<h1>Java｜网络IO之同步、异步、阻塞、非阻塞</h1>

<p>最近在看《大型分布式网站架构－设计与实践》这本书时，文中提到阻塞式IO，其实之前我在看一些书籍时也经常听到同步（synchronous） IO和异步（asynchronous） IO，阻塞（blocking） IO和非阻塞（non-blocking）IO这些词。</p>

<p>那么同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别呢？</p>

<p><strong>一、网络IO操作过程</strong></p>

<p>对于一个网络IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的过程process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：</p>

<blockquote>
<p>（1）等待数据准备 (Waiting for the data to be ready)</p>

<p>（2）将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>
</blockquote>

<p>记住这两点很重要，因为这些网络IO模型的区别就是在两个阶段上各有不同的情况。</p>

<p><strong>二、网络IO模型详细分析</strong></p>

<p>常见的网络IO模型有blocking IO（阻塞）、nonblocking IO（非阻塞）、IO multiplexing（IO多路复用）、signal driven IO（信号驱动）和asynchronous IO（异步），由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>

<p>我这里引用网络上一位博友的例子（做了一些修改）来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案：</p>

<p>2.1 blocking IO（阻塞）</p>

<p>我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。</p>

<p>女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。网络中IO阻塞如下图所示：</p>

<p><img src="https://upload-images.jianshu.io/upload_images/5219651-18046f9283e83e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/722/format/webp" /></p>

<p>blocking IO（阻塞）</p>

<p>当用户进程调用了recvfrom这个系统调用，内核就开始了IO的第一个阶段：准备数据。对于网络IO来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候内核就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当内核一直等到数据准备好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除block的状态，重新运行起来。</p>

<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>

<p>2.2 nonblocking IO（非阻塞）</p>

<p>我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。网络IO非阻塞如下图所示：</p>

<p><img src="https://upload-images.jianshu.io/upload_images/5219651-6d76b69e74eb5984.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp" /></p>

<p>nonblocking IO（非阻塞）</p>

<p>从图中可以看出，当用户进程发出read操作时，如果内核中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>

<p>所以，用户进程其实是需要不断的主动询问内核数据好了没有。</p>

<p>2.3 IO multiplexing（IO多路复用）</p>

<p>我一次性带了多个女友（女性朋友）都要在那里吃饭，然后我苦逼的在餐厅等着不断询问几个女友的饭是否有好了的，这时我的女友们就可以出去继续逛街，然后我一但发现某个女友的饭好了就打电话通知该女友来吃饭！</p>

<p><img src="https://upload-images.jianshu.io/upload_images/5219651-b67963ba863e5258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/663/format/webp" /></p>

<p>IO multiplexing（IO多路复用）</p>

<p>当用户进程调用了select，那么整个进程会被block，而同时，内核会&ldquo;监视&rdquo;所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。</p>

<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>

<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>

<p>2.4 asynchronous IO（异步）</p>

<p>女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p>

<p><img src="https://upload-images.jianshu.io/upload_images/5219651-1521e6476caec4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp" /></p>

<p>asynchronous IO（异步）</p>

<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个signal，告诉它read操作完成了。</p>

<p>到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题：blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪。</p>

<p><strong>三、<strong>阻塞与非阻塞</strong></strong></p>

<p>先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在内核还准备数据的情况下会立刻返回。</p>

<p>简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。详细区别如下图所示：</p>

<p><img src="https://upload-images.jianshu.io/upload_images/5219651-ffeb97607c6b2728.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/743/format/webp" /></p>

<p><strong><strong>阻塞与非阻塞</strong></strong></p>

<p><strong>四、<strong>同步与异步</strong></strong></p>

<p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。</p>

<blockquote>
<p>A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes;</p>

<p>同步I/O操作导致请求过程被阻塞直到我的I/O命令完成后才可执行；</p>

<p>An asynchronous I/O operation does not cause the requesting process to be blocked;</p>

<p>异步I/O操作不会导致请求进程被阻塞；</p>
</blockquote>

<p>两者的区别就在于synchronous IO做&rdquo;IO operation&rdquo;的时候会将process阻塞。</p>

<p>按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常&ldquo;狡猾&rdquo;的地方，定义中所指的&rdquo;IO operation&rdquo;是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果内核的数据没有准备好，这时候不会block进程。但是，当内核中数据准备好的时候，recvfrom会将数据从内核拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>

<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到内核发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>

<p>简单点说：同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。</p>

<p><strong>五、非阻塞!=异步</strong></p>

<p>非阻塞和异步不是等价的，经过上面的介绍，会发现non-blocking IO（非阻塞）和asynchronous IO（异步）的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（内核）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>

<p>这里的关键在于，一个要主动去调用recvfrom，asynchronous IO是被动等待通知。</p>

<hr />
<p>文中引用的博客链接我会放在评论里，感谢阅读。</p>

<p>下次讲讲同步阻塞的BIO、同步非阻塞的NIO、异步非阻塞的AIO。</p>
