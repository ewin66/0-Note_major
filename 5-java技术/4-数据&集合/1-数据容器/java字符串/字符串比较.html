字符串比较

在C++中，两个字符串比较的代码可以为： 
(string1==string2) 
但在java中，这个代码即使在两个字符串完全相同的情况下也会返回false 
Java中必须使用string1.equals(string2)来进行判断 

补充 

如果： 
string s1="Hello"; 
string s2="Hello"; 
则(s1==s2)=true; 
因为他们指向的同一个对象。

如果：
String s1=new String("Hello"); 
String s2=new String("Hello"); 
则(s1==s2)=false

如果把其他变量的值赋给s1和s2，即使内容相同，由于不是指向同一个对象，也会返回false。所以建议使用equals()，因为equals比较的才是真正的内容 
例如： 
String string1=new String( "aaa" ); 
String string2=new String( "aaa" ); 
这两个字符串当然应该是相等的。 
如果用表达式string1==string2，则该表达式的值为false 
如果用表达式string1.equals(string2)，则该表达式的值为true 
因此应该用string1.equals(string2)，在if语句中就是 
if(string1.equals(string2)==true) //字符串相等，……
string1==string2,是值相等,而且内存地址也相等,是完全的相等 
string1.equals(string2)为true,只是值相等
(上述出自：http://blog.csdn.net/ecitnet/archive/2007/09/20/1792615.aspx)


如果比较字符串的大小使用：str1.compareTo(String str2)


按字典顺序比较两个字符串。该比较基于字符串中各个字符的 Unicode 值。按字典顺序将此 String 对象表示的字符序列与参数字符串所表示的字符序列进行比较。如果按字典顺序此 String 对象位于参数字符串之前，则比较结果为一个负整数。如果按字典顺序此 String 对象位于参数字符串之后，则比较结果为一个正整数。如果这两个字符串相等，则结果为 0；compareTo 只在方法 equals(Object) 返回 true 时才返回 0。
这是字典排序的定义。如果这两个字符串不同，那么它们要么在某个索引处的字符不同（该索引对二者均为有效索引），要么长度不同，或者同时具备这两种情况。如果它们在一个或多个索引位置上的字符不同，假设 k 是这类索引的最小值；则在位置 k 上具有较小值的那个字符串（使用 < 运算符确定），其字典顺序在其他字符串之前。在这种情况下，compareTo 返回这两个字符串在位置 k 处两个char 值的差，即值：
this.charAt(k)-anotherString.charAt(k)

如果没有字符不同的索引位置，则较短字符串的字典顺序在较长字符串之前。在这种情况下，compareTo 返回这两个字符串长度的差，即值：
this.length()-anotherString.length()
