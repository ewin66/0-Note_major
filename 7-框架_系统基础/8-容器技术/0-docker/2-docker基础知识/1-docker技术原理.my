<h1>Docker技术原理</h1>

<h2>Docker相关的核心技术之cgroups：</h2>

<p>Linux系统中经常有个需求就是希望能限制某个或者某些进程进行资源分配。于是就出现了cgroups的概念，cgroups就是control group，在这个group中，有分配好的特定比例的cpu时间，IO时间，可用内存大小等。cgroups是将任意进程进行分组化管理的Linux内核功能。最初由google工程师提出，后来被整合进Linux内核中</p>

<p>cgroups中的重要概念是&ldquo;子系统&rdquo;，也就是资源控制器，每种子系统就是一个资源的分配器，比如cpu子系统是控制cpu时间分配。首先挂载子系统，然后才有control group的。比如先挂载memory子系统，然后在memory子系统中创建了一个cgroups节点，在这个节点中，将需要控制的进程id写入，并且将控制的属性写入，这就是完成了内存的资源限制</p>

<p>cgroups被Linux内核支持，有得天独厚的性能优势，发展势头迅猛，在很多领域可以取代虚拟化技术分割资源，cgroups默认有诸多资源组，可以限制几乎所有服务器上的资源：cpu、mem、iops、iobangwide、net、device、acess等</p>

<h2>Docker相关的核心技术之LXC：</h2>

<p>LXC是Linux containers的简称，是一种基于容器的操作系统层级的虚拟化技术。借助于namespace的隔离机制和cgroups限额功能，LXC提供了一套统一的API和工具来建立和管理container。LXC跟其他操作系统层级的虚拟化技术相比，最大的优势在于LXC被整合进了Linux内核，不用单独为内核打补丁</p>

<p>LXC旨在提供一个共享kernel的OS级虚拟化方法，在执行对不用重复加载kernel，且container的kernel与host共享，因此可以大大加快container的启动过程，并显著减少内存消耗，容器在提供隔离的同时，还通过共享这些资源节省开销，这意味着容器比真正的虚拟化的开销要小得多，在实际测试中，基于LXC的虚拟化方法的IO和CPU性能几乎接近baremetal的性能</p>

<p>显然容器所使用的这种类型的隔离总的来说非常强大，然后不是像运行在hypervisor上的虚拟化那么强壮仍具有争议性。如果内核停止，那么所有的容器就会停止运行</p>

<p>性能方面：LXC&gt;KVM&gt;XEN（由于LXC使用cgroup机制，其性能损坏基本为0。）</p>

<p>内存利用率：LXC&gt;KVM&gt;XEN（LXC只能虚拟化linux。）</p>

<p>隔离程度：XEN&gt;KVM&gt;LXC（由于LXC共用内核，内存利用率最高；其他两种方案每个虚机都需要单独的操作系统占用一部分内存空间。）</p>

<h2>Docker相关的核心技术之AUFS：</h2>

<p>AUFS是一个能透明覆盖一个或多个现有文件系统的层级文件系统，支持将不同目录挂载到同一个虚拟文件系统下，可以把不同的目录联合在一起，组成一个单一的目录。这种是一种虚拟的文件系统，文件系统不用格式化，直接挂载即可。</p>

<p>Docker一直在用AUFS作为容器的文件系统。当一个进程需要修改一个文件时，AUFS创建该文件的一个副本。AUFS可以把多层合并成文件系统的单层表示。这个过程称为写入复制（copy on write）</p>

<p>AUFS允许Docker把某些镜像作为容器的基础。例如，你可能有一个可以作为为很多不同容器的基础的centos系统镜像。多亏AUFS，只要一个centos镜像的副本就够了，这样既节省了存储和内存，也保证更快速的容器部署。</p>

<p>使用AUFS的另一个好处是Docker的版本容器镜像能力。每个新版本都是一个与之版本的简单差异改动，有效的保持镜像文件最小化。但这也意味着你总是要有一个记录该容器从一个版本到另一个版本改动的审计跟踪。</p>
