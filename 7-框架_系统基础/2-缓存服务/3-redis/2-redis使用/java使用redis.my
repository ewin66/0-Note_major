<h1>如何使用RedisTemplate访问Redis数据结构</h1>

<h2>Redis 数据结构简介</h2>

<p>Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为String（字符串）、List（列表）、Set（集合）、Hash（散列）和 Zset（有序集合）。</p>

<p>下面来对这5种数据结构类型作简单的介绍：</p>

<table>
	<thead>
		<tr>
			<th>结构类型</th>
			<th>结构存储的值</th>
			<th>结构的读写能力</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>String</td>
			<td>可以是字符串、整数或者浮点数</td>
			<td>对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement)</td>
		</tr>
		<tr>
			<td>List</td>
			<td>一个链表，链表上的每个节点都包含了一个字符串</td>
			<td>从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素</td>
		</tr>
		<tr>
			<td>Set</td>
			<td>包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同</td>
			<td>添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素</td>
		</tr>
		<tr>
			<td>Hash</td>
			<td>包含键值对的无序散列表</td>
			<td>添加、获取、移除单个键值对；获取所有键值对</td>
		</tr>
		<tr>
			<td>Zset</td>
			<td>字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定</td>
			<td>添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素</td>
		</tr>
	</tbody>
</table>

<p>Redis 5种数据结构的概念大致介绍到这边，下面将结合Spring封装的RedisTemplate来对这5种数据结构的运用进行演示</p>

<h2>RedisTemplate介绍</h2>

<p>spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api。</p>

<p><strong>RedisTemplate在spring代码中的结构如下：</strong></p>

<pre>
<code>org.springframework.data.redis.core
Class RedisTemplate&lt;K,V&gt;
java.lang.Object
    org.springframework.data.redis.core.RedisAccessor
        org.springframework.data.redis.core.RedisTemplate&lt;K,V&gt;</code></pre>

<p>Type Parameters:<br />
K</p>

<ul>
	<li>the Redis key type against which the template works (usually a String)<br />
	模板中的Redis key的类型（通常为String）如：RedisTemplate&lt;String, Object&gt;<br />
	注意：<strong>如果没特殊情况，切勿定义成RedisTemplate&lt;Object, Object&gt;</strong>，否则根据里氏替换原则，使用的时候会造成类型错误 。<br />
	V</li>
	<li>the Redis value type against which the template works<br />
	模板中的Redis value的类型</li>
</ul>

<h3>RedisTemplate中定义了对5种数据结构操作</h3>

<pre>
<code>redisTemplate.opsForValue();//操作字符串
redisTemplate.opsForHash();//操作hash
redisTemplate.opsForList();//操作list
redisTemplate.opsForSet();//操作set
redisTemplate.opsForZSet();//操作有序set</code></pre>

<h2>StringRedisTemplate与RedisTemplate</h2>

<ul>
	<li>
	<p>两者的关系是StringRedisTemplate继承RedisTemplate。</p>
	</li>
	<li>
	<p>两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。</p>
	</li>
	<li>
	<p>SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。</p>

	<p>StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。</p>

	<p>RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p>
	</li>
</ul>

<p><strong>RedisTemplate配置如下：</strong></p>

<pre>
<code>@Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)
    {
        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
        template.setConnectionFactory(redisConnectionFactory);
        template.setKeySerializer(jackson2JsonRedisSerializer);
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashKeySerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }</code></pre>

<h2>Redis的String数据结构 （推荐使用StringRedisTemplate）</h2>

<p><strong>注意：如果使用RedisTemplate需要更改序列化方式</strong></p>

<pre>
<code>RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();
        template.setKeySerializer(stringSerializer );
        template.setValueSerializer(stringSerializer );
        template.setHashKeySerializer(stringSerializer );
        template.setHashValueSerializer(stringSerializer );</code></pre>

<p>public interface ValueOperations&lt;K,V&gt;<br />
Redis operations for simple (or in Redis terminology &#39;string&#39;) values.<br />
ValueOperations可以对String数据结构进行操作：</p>

<ul>
	<li>
	<p>set void set(K key, V value);</p>

	<pre>
<code>使用：redisTemplate.opsForValue().set(&quot;name&quot;,&quot;tom&quot;);
结果：redisTemplate.opsForValue().get(&quot;name&quot;)  输出结果为tom</code></pre>
	</li>
	<li>
	<p>set void set(K key, V value, long timeout, TimeUnit unit);</p>

	<pre>
<code>使用：redisTemplate.opsForValue().set(&quot;name&quot;,&quot;tom&quot;,10, TimeUnit.SECONDS);
结果：redisTemplate.opsForValue().get(&quot;name&quot;)由于设置的是10秒失效，十秒之内查询有结果，十秒之后返回为null</code></pre>
	</li>
	<li>
	<p>set void set(K key, V value, long offset);<br />
	该方法是用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始</p>

	<pre>
<code>使用：template.opsForValue().set(&quot;key&quot;,&quot;hello world&quot;);
      template.opsForValue().set(&quot;key&quot;,&quot;redis&quot;, 6);
      System.out.println(&quot;***************&quot;+template.opsForValue().get(&quot;key&quot;));
结果：***************hello redis</code></pre>
	</li>
	<li>
	<p>setIfAbsent Boolean setIfAbsent(K key, V value);</p>
	</li>
</ul>

<pre>
<code>使用：System.out.println(template.opsForValue().setIfAbsent(&quot;multi1&quot;,&quot;multi1&quot;));//false  multi1之前已经存在
        System.out.println(template.opsForValue().setIfAbsent(&quot;multi111&quot;,&quot;multi111&quot;));//true  multi111之前不存在
结果：false
true</code></pre>

<ul>
	<li>
	<p>multiSet void multiSet(Map&lt;? extends K, ? extends V&gt; m);<br />
	为多个键分别设置它们的值</p>

	<pre>
<code>使用：Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
      maps.put(&quot;multi1&quot;,&quot;multi1&quot;);
      maps.put(&quot;multi2&quot;,&quot;multi2&quot;);
      maps.put(&quot;multi3&quot;,&quot;multi3&quot;);
      template.opsForValue().multiSet(maps);
      List&lt;String&gt; keys = new ArrayList&lt;String&gt;();
      keys.add(&quot;multi1&quot;);
      keys.add(&quot;multi2&quot;);
      keys.add(&quot;multi3&quot;);
      System.out.println(template.opsForValue().multiGet(keys));
结果：[multi1, multi2, multi3]</code></pre>
	</li>
	<li>
	<p>multiSetIfAbsent Boolean multiSetIfAbsent(Map&lt;? extends K, ? extends V&gt; m);<br />
	为多个键分别设置它们的值，如果存在则返回false，不存在返回true</p>

	<pre>
<code>使用：Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
      maps.put(&quot;multi11&quot;,&quot;multi11&quot;);
      maps.put(&quot;multi22&quot;,&quot;multi22&quot;);
      maps.put(&quot;multi33&quot;,&quot;multi33&quot;);
      Map&lt;String,String&gt; maps2 = new HashMap&lt;String, String&gt;();
      maps2.put(&quot;multi1&quot;,&quot;multi1&quot;);
      maps2.put(&quot;multi2&quot;,&quot;multi2&quot;);
      maps2.put(&quot;multi3&quot;,&quot;multi3&quot;);
      System.out.println(template.opsForValue().multiSetIfAbsent(maps));
      System.out.println(template.opsForValue().multiSetIfAbsent(maps2));
结果：true
false</code></pre>
	</li>
	<li>
	<p>get V get(Object key);</p>

	<pre>
<code>使用：template.opsForValue().set(&quot;key&quot;,&quot;hello world&quot;);
      System.out.println(&quot;***************&quot;+template.opsForValue().get(&quot;key&quot;));
结果：***************hello world</code></pre>
	</li>
	<li>
	<p>getAndSet V getAndSet(K key, V value);<br />
	设置键的字符串值并返回其旧值</p>

	<pre>
<code>使用：template.opsForValue().set(&quot;getSetTest&quot;,&quot;test&quot;);
      System.out.println(template.opsForValue().getAndSet(&quot;getSetTest&quot;,&quot;test2&quot;));
结果：test</code></pre>
	</li>
	<li>
	<p>multiGet List&lt;V&gt; multiGet(Collection&lt;K&gt; keys);<br />
	为多个键分别取出它们的值</p>

	<pre>
<code>使用：Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
      maps.put(&quot;multi1&quot;,&quot;multi1&quot;);
      maps.put(&quot;multi2&quot;,&quot;multi2&quot;);
      maps.put(&quot;multi3&quot;,&quot;multi3&quot;);
      template.opsForValue().multiSet(maps);
      List&lt;String&gt; keys = new ArrayList&lt;String&gt;();
      keys.add(&quot;multi1&quot;);
      keys.add(&quot;multi2&quot;);
      keys.add(&quot;multi3&quot;);
      System.out.println(template.opsForValue().multiGet(keys));
结果：[multi1, multi2, multi3]</code></pre>
	</li>
	<li>
	<p>increment Long increment(K key, long delta);<br />
	支持整数</p>

	<pre>
<code>使用：template.opsForValue().increment(&quot;increlong&quot;,1);
      System.out.println(&quot;***************&quot;+template.opsForValue().get(&quot;increlong&quot;));
结果：***************1</code></pre>
	</li>
	<li>
	<p>increment Double increment(K key, double delta);<br />
	也支持浮点数</p>

	<pre>
<code>使用：template.opsForValue().increment(&quot;increlong&quot;,1.2);
      System.out.println(&quot;***************&quot;+template.opsForValue().get(&quot;increlong&quot;));
结果：***************2.2</code></pre>
	</li>
	<li>
	<p>append Integer append(K key, String value);<br />
	如果key已经存在并且是一个字符串，则该命令将该值追加到字符串的末尾。如果键不存在，则它被创建并设置为空字符串，因此APPEND在这种特殊情况下将类似于SET。</p>

	<pre>
<code>使用：template.opsForValue().append(&quot;appendTest&quot;,&quot;Hello&quot;);
      System.out.println(template.opsForValue().get(&quot;appendTest&quot;));
      template.opsForValue().append(&quot;appendTest&quot;,&quot;world&quot;);
      System.out.println(template.opsForValue().get(&quot;appendTest&quot;));
结果：Hello
      Helloworld</code></pre>
	</li>
	<li>
	<p>get String get(K key, long start, long end);<br />
	截取key所对应的value字符串</p>

	<pre>
<code>使用：appendTest对应的value为Helloworld
System.out.println(&quot;*********&quot;+template.opsForValue().get(&quot;appendTest&quot;,0,5));
结果：*********Hellow
使用：System.out.println(&quot;*********&quot;+template.opsForValue().get(&quot;appendTest&quot;,0,-1));
结果：*********Helloworld
使用：System.out.println(&quot;*********&quot;+template.opsForValue().get(&quot;appendTest&quot;,-3,-1));
结果：*********rld</code></pre>
	</li>
	<li>
	<p>size Long size(K key);<br />
	返回key所对应的value值得长度</p>

	<pre>
<code>使用：template.opsForValue().set(&quot;key&quot;,&quot;hello world&quot;);
  System.out.println(&quot;***************&quot;+template.opsForValue().size(&quot;key&quot;));
结果：***************11</code></pre>
	</li>
	<li>
	<p>setBit Boolean setBit(K key, long offset, boolean value);<br />
	对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)<br />
	key键对应的值value对应的ascii码,在offset的位置(从左向右数)变为value</p>

	<pre>
<code>使用：template.opsForValue().set(&quot;bitTest&quot;,&quot;a&quot;);
      // &#39;a&#39; 的ASCII码是 97。转换为二进制是：01100001
      // &#39;b&#39; 的ASCII码是 98  转换为二进制是：01100010
      // &#39;c&#39; 的ASCII码是 99  转换为二进制是：01100011
      //因为二进制只有0和1，在setbit中true为1，false为0，因此我要变为&#39;b&#39;的话第六位设置为1，第七位设置为0
      template.opsForValue().setBit(&quot;bitTest&quot;,6, true);
      template.opsForValue().setBit(&quot;bitTest&quot;,7, false);
      System.out.println(template.opsForValue().get(&quot;bitTest&quot;));
结果：b</code></pre>
	</li>
	<li>
	<p>getBit Boolean getBit(K key, long offset);<br />
	获取键对应值的ascii码的在offset处位值</p>

	<pre>
<code>使用：System.out.println(template.opsForValue().getBit(&quot;bitTest&quot;,7));
结果：false</code></pre>
	</li>
</ul>

<h2>Redis的List数据结构</h2>

<p><strong>这边我们把RedisTemplate序列化方式改回之前的</strong></p>

<pre>
<code>Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
       template.setKeySerializer(jackson2JsonRedisSerializer);
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.setHashKeySerializer(jackson2JsonRedisSerializer);
        template.setHashValueSerializer(jackson2JsonRedisSerializer);</code></pre>

<p>public interface ListOperations&lt;K,V&gt;<br />
Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）<br />
ListOperations专门操作list列表：</p>

<ul>
	<li>
	<p>List&lt;V&gt; range(K key, long start, long end);<br />
	返回存储在键中的列表的指定元素。偏移开始和停止是基于零的索引，其中0是列表的第一个元素（列表的头部），1是下一个元素</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
结果:[c#, c++, python, java, c#, c#]</code></pre>
	</li>
	<li>
	<p>void trim(K key, long start, long end);<br />
	修剪现有列表，使其只包含指定的指定范围的元素，起始和停止都是基于0的索引</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
template.opsForList().trim(&quot;list&quot;,1,-1);//裁剪第一个元素
System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
结果:[c#, c++, python, java, c#, c#]
[c++, python, java, c#, c#]</code></pre>
	</li>
	<li>
	<p>Long size(K key);<br />
	返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。当key存储的值不是列表时返回错误。</p>

	<pre>
<code>使用：System.out.println(template.opsForList().size(&quot;list&quot;));
结果:6</code></pre>
	</li>
	<li>
	<p>Long leftPush(K key, V value);<br />
	将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从左边插入）</p>

	<pre>
<code>使用：template.opsForList().leftPush(&quot;list&quot;,&quot;java&quot;);
      template.opsForList().leftPush(&quot;list&quot;,&quot;python&quot;);
      template.opsForList().leftPush(&quot;list&quot;,&quot;c++&quot;);
结果:返回的结果为推送操作后的列表的长度
1
2
3</code></pre>
	</li>
	<li>
	<p>Long leftPushAll(K key, V... values);<br />
	批量把一个数组插入到列表中</p>

	<pre>
<code>使用：String[] stringarrays = new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;};
      template.opsForList().leftPushAll(&quot;listarray&quot;,stringarrays);
      System.out.println(template.opsForList().range(&quot;listarray&quot;,0,-1));
结果:[3, 2, 1]</code></pre>
	</li>
	<li>
	<p>Long leftPushAll(K key, Collection&lt;V&gt; values);<br />
	批量把一个集合插入到列表中</p>

	<pre>
<code>使用：List&lt;Object&gt; strings = new ArrayList&lt;Object&gt;();
      strings.add(&quot;1&quot;);
      strings.add(&quot;2&quot;);
      strings.add(&quot;3&quot;);
      template.opsForList().leftPushAll(&quot;listcollection4&quot;, strings);
      System.out.println(template.opsForList().range(&quot;listcollection4&quot;,0,-1));
结果:[3, 2, 1]</code></pre>
	</li>
	<li>
	<p>Long leftPushIfPresent(K key, V value);<br />
	只有存在key对应的列表才能将这个value值插入到key所对应的列表中</p>

	<pre>
<code>使用：System.out.println(template.opsForList().leftPushIfPresent(&quot;leftPushIfPresent&quot;,&quot;aa&quot;));
      System.out.println(template.opsForList().leftPushIfPresent(&quot;leftPushIfPresent&quot;,&quot;bb&quot;));
==========分割线===========
System.out.println(template.opsForList().leftPush(&quot;leftPushIfPresent&quot;,&quot;aa&quot;));
      System.out.println(template.opsForList().leftPushIfPresent(&quot;leftPushIfPresent&quot;,&quot;bb&quot;));
结果:
0
0
==========分割线===========
1
2</code></pre>
	</li>
	<li>
	<p>Long leftPush(K key, V pivot, V value);<br />
	把value值放到key对应列表中pivot值的左面，如果pivot值存在的话</p>

	<pre>
<code>使用：template.opsForList().leftPush(&quot;list&quot;,&quot;java&quot;,&quot;oc&quot;);
      System.out.print(template.opsForList().range(&quot;list&quot;,0,-1));
结果：[c++, python, oc, java, c#, c#]</code></pre>
	</li>
	<li>
	<p>Long rightPush(K key, V value);<br />
	将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从右边插入）</p>

	<pre>
<code>使用：template.opsForList().rightPush(&quot;listRight&quot;,&quot;java&quot;);
      template.opsForList().rightPush(&quot;listRight&quot;,&quot;python&quot;);
      template.opsForList().rightPush(&quot;listRight&quot;,&quot;c++&quot;);
结果:
1
2
3</code></pre>
	</li>
	<li>
	<p>Long rightPushAll(K key, V... values);</p>

	<pre>
<code>使用：String[] stringarrays = new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;};
      template.opsForList().rightPushAll(&quot;listarrayright&quot;,stringarrays);
      System.out.println(template.opsForList().range(&quot;listarrayright&quot;,0,-1));
结果:[1, 2, 3]</code></pre>
	</li>
	<li>
	<p>Long rightPushAll(K key, Collection&lt;V&gt; values);</p>

	<pre>
<code>使用：List&lt;Object&gt; strings = new ArrayList&lt;Object&gt;();
      strings.add(&quot;1&quot;);
      strings.add(&quot;2&quot;);
      strings.add(&quot;3&quot;);
      template.opsForList().rightPushAll(&quot;listcollectionright&quot;, strings);
      System.out.println(template.opsForList().range(&quot;listcollectionright&quot;,0,-1));
结果:[1, 2, 3]</code></pre>
	</li>
	<li>
	<p>Long rightPushIfPresent(K key, V value);<br />
	只有存在key对应的列表才能将这个value值插入到key所对应的列表中</p>

	<pre>
<code>使用：System.out.println(template.opsForList().rightPushIfPresent(&quot;rightPushIfPresent&quot;,&quot;aa&quot;));
      System.out.println(template.opsForList().rightPushIfPresent(&quot;rightPushIfPresent&quot;,&quot;bb&quot;));
      System.out.println(&quot;==========分割线===========&quot;);
      System.out.println(template.opsForList().rightPush(&quot;rightPushIfPresent&quot;,&quot;aa&quot;));
      System.out.println(template.opsForList().rightPushIfPresent(&quot;rightPushIfPresent&quot;,&quot;bb&quot;));
结果:0
0
==========分割线===========
1
2</code></pre>
	</li>
	<li>
	<p>Long rightPush(K key, V pivot, V value);<br />
	把value值放到key对应列表中pivot值的右面，如果pivot值存在的话</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
      template.opsForList().rightPush(&quot;listRight&quot;,&quot;python&quot;,&quot;oc&quot;);
      System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
结果:[java, python, c++]
[java, python, oc, c++]</code></pre>
	</li>
	<li>
	<p>void set(K key, long index, V value);<br />
	在列表中index的位置设置value值</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
      template.opsForList().set(&quot;listRight&quot;,1,&quot;setValue&quot;);
      System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
结果:[java, python, oc, c++]
[java, setValue, oc, c++]</code></pre>
	</li>
	<li>
	<p>Long remove(K key, long count, Object value);<br />
	从存储在键中的列表中删除等于值的元素的第一个计数事件。<br />
	计数参数以下列方式影响操作：<br />
	count&gt; 0：删除等于从头到尾移动的值的元素。<br />
	count &lt;0：删除等于从尾到头移动的值的元素。<br />
	count = 0：删除等于value的所有元素。</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
      template.opsForList().remove(&quot;listRight&quot;,1,&quot;setValue&quot;);//将删除列表中存储的列表中第一次次出现的&ldquo;setValue&rdquo;。
      System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
结果:[java, setValue, oc, c++]
[java, oc, c++]</code></pre>
	</li>
	<li>
	<p>V index(K key, long index);<br />
	根据下表获取列表中的值，下标是从0开始的</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;listRight&quot;,0,-1));
System.out.println(template.opsForList().index(&quot;listRight&quot;,2));
结果:[java, oc, c++]
c++</code></pre>
	</li>
	<li>
	<p>V leftPop(K key);<br />
	弹出最左边的元素，弹出之后该值在列表中将不复存在</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
      System.out.println(template.opsForList().leftPop(&quot;list&quot;));
      System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
结果:
[c++, python, oc, java, c#, c#]
c++
[python, oc, java, c#, c#]</code></pre>
	</li>
	<li>
	<p>V leftPop(K key, long timeout, TimeUnit unit);<br />
	移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>

	<pre>
<code>使用：用法与 leftPop(K key);一样</code></pre>
	</li>
	<li>
	<p>V rightPop(K key);<br />
	弹出最右边的元素，弹出之后该值在列表中将不复存在</p>

	<pre>
<code>使用：    System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
      System.out.println(template.opsForList().rightPop(&quot;list&quot;));
      System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
结果:[python, oc, java, c#, c#]
c#
[python, oc, java, c#]</code></pre>
	</li>
	<li>
	<p>V rightPop(K key, long timeout, TimeUnit unit);<br />
	移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>

	<pre>
<code>使用：用法与 rightPop(K key);一样</code></pre>
	</li>
	<li>
	<p>V rightPopAndLeftPush(K sourceKey, K destinationKey);<br />
	用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回。</p>

	<pre>
<code>使用：System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
template.opsForList().rightPopAndLeftPush(&quot;list&quot;,&quot;rightPopAndLeftPush&quot;);
  System.out.println(template.opsForList().range(&quot;list&quot;,0,-1));
  System.out.println(template.opsForList().range(&quot;rightPopAndLeftPush&quot;,0,-1));
结果:[oc, java,c#]
[oc, java]
[c#]</code></pre>
	</li>
	<li>
	<p>V rightPopAndLeftPush(K sourceKey, K destinationKey, long timeout, TimeUnit unit);<br />
	用于移除列表的最后一个元素，并将该元素添加到另一个列表并返回，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>

	<pre>
<code>使用：用法与rightPopAndLeftPush(K sourceKey, K destinationKey)一样</code></pre>
	</li>
</ul>

<h2>Redis的Hash数据机构</h2>

<p>Redis的散列可以让用户将多个键值对存储到一个Redis键里面。<br />
public interface HashOperations&lt;H,HK,HV&gt;<br />
HashOperations提供一系列方法操作hash：</p>

<pre>
<code>初始数据:
//template.opsForHash().put(&quot;redisHash&quot;,&quot;name&quot;,&quot;tom&quot;);
        //template.opsForHash().put(&quot;redisHash&quot;,&quot;age&quot;,26);
        //template.opsForHash().put(&quot;redisHash&quot;,&quot;class&quot;,&quot;6&quot;);

//Map&lt;String,Object&gt; testMap = new HashMap();
        //testMap.put(&quot;name&quot;,&quot;jack&quot;);
        //testMap.put(&quot;age&quot;,27);
        //testMap.put(&quot;class&quot;,&quot;1&quot;);
        //template.opsForHash().putAll(&quot;redisHash1&quot;,testMap);</code></pre>

<ul>
	<li>
	<p>Long delete(H key, Object... hashKeys);<br />
	删除给定的哈希hashKeys</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().delete(&quot;redisHash&quot;,&quot;name&quot;));
      System.out.println(template.opsForHash().entries(&quot;redisHash&quot;));
结果：1
{class=6, age=28.1}</code></pre>
	</li>
	<li>
	<p>Boolean hasKey(H key, Object hashKey);<br />
	确定哈希hashKey是否存在</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().hasKey(&quot;redisHash&quot;,&quot;age&quot;));
      System.out.println(template.opsForHash().hasKey(&quot;redisHash&quot;,&quot;ttt&quot;));
结果：true
false</code></pre>
	</li>
	<li>
	<p>HV get(H key, Object hashKey);<br />
	从键中的哈希获取给定hashKey的值</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().get(&quot;redisHash&quot;,&quot;age&quot;));
结果：26</code></pre>
	</li>
	<li>
	<p>List&lt;HV&gt; multiGet(H key, Collection&lt;HK&gt; hashKeys);<br />
	从哈希中获取给定hashKey的值</p>

	<pre>
<code>使用：List&lt;Object&gt; kes = new ArrayList&lt;Object&gt;();
      kes.add(&quot;name&quot;);
      kes.add(&quot;age&quot;);
      System.out.println(template.opsForHash().multiGet(&quot;redisHash&quot;,kes));
结果：[jack, 28.1]</code></pre>
	</li>
	<li>
	<p>Long increment(H key, HK hashKey, long delta);<br />
	通过给定的delta增加散列hashKey的值（整型）</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().get(&quot;redisHash&quot;,&quot;age&quot;));
  System.out.println(template.opsForHash().increment(&quot;redisHash&quot;,&quot;age&quot;,1));
结果：26
27</code></pre>
	</li>
	<li>
	<p>Double increment(H key, HK hashKey, double delta);<br />
	通过给定的delta增加散列hashKey的值（浮点数）</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().get(&quot;redisHash&quot;,&quot;age&quot;));
  System.out.println(template.opsForHash().increment(&quot;redisHash&quot;,&quot;age&quot;,1.1));
结果：27
28.1</code></pre>
	</li>
	<li>
	<p>Set&lt;HK&gt; keys(H key);<br />
	获取key所对应的散列表的key</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().keys(&quot;redisHash1&quot;));
//redisHash1所对应的散列表为{class=1, name=jack, age=27}
结果：[name, class, age]</code></pre>
	</li>
	<li>
	<p>Long size(H key);<br />
	获取key所对应的散列表的大小个数</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().size(&quot;redisHash1&quot;));
//redisHash1所对应的散列表为{class=1, name=jack, age=27}
结果：3</code></pre>
	</li>
	<li>
	<p>void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m);<br />
	使用m中提供的多个散列字段设置到key对应的散列表中</p>

	<pre>
<code>使用：Map&lt;String,Object&gt; testMap = new HashMap();
      testMap.put(&quot;name&quot;,&quot;jack&quot;);
      testMap.put(&quot;age&quot;,27);
      testMap.put(&quot;class&quot;,&quot;1&quot;);
      template.opsForHash().putAll(&quot;redisHash1&quot;,testMap);
      System.out.println(template.opsForHash().entries(&quot;redisHash1&quot;));
结果：{class=1, name=jack, age=27}</code></pre>
	</li>
	<li>
	<p>void put(H key, HK hashKey, HV value);<br />
	设置散列hashKey的值</p>

	<pre>
<code>使用：template.opsForHash().put(&quot;redisHash&quot;,&quot;name&quot;,&quot;tom&quot;);
      template.opsForHash().put(&quot;redisHash&quot;,&quot;age&quot;,26);
      template.opsForHash().put(&quot;redisHash&quot;,&quot;class&quot;,&quot;6&quot;);
System.out.println(template.opsForHash().entries(&quot;redisHash&quot;));
结果：{age=26, class=6, name=tom}</code></pre>
	</li>
	<li>
	<p>Boolean putIfAbsent(H key, HK hashKey, HV value);<br />
	仅当hashKey不存在时才设置散列hashKey的值。</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().putIfAbsent(&quot;redisHash&quot;,&quot;age&quot;,30));
System.out.println(template.opsForHash().putIfAbsent(&quot;redisHash&quot;,&quot;kkk&quot;,&quot;kkk&quot;));
结果：false
true</code></pre>
	</li>
	<li>
	<p>List&lt;HV&gt; values(H key);<br />
	获取整个哈希存储的值根据密钥</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().values(&quot;redisHash&quot;));
结果：[tom, 26, 6]</code></pre>
	</li>
	<li>
	<p>Map&lt;HK, HV&gt; entries(H key);<br />
	获取整个哈希存储根据密钥</p>

	<pre>
<code>使用：System.out.println(template.opsForHash().entries(&quot;redisHash&quot;));
结果：{age=26, class=6, name=tom}</code></pre>
	</li>
	<li>
	<p>Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; scan(H key, ScanOptions options);<br />
	使用Cursor在key的hash中迭代，相当于迭代器。</p>

	<pre>
<code>使用：Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; curosr = template.opsForHash().scan(&quot;redisHash&quot;, ScanOptions.ScanOptions.NONE);
      while(curosr.hasNext()){
          Map.Entry&lt;Object, Object&gt; entry = curosr.next();
          System.out.println(entry.getKey()+&quot;:&quot;+entry.getValue());
      }
结果：age:28.1
class:6
kkk:kkk</code></pre>
	</li>
</ul>

<h2>Redis的Set数据结构</h2>

<p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br />
Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。<br />
public interface SetOperations&lt;K,V&gt;<br />
SetOperations提供了对无序集合的一系列操作：</p>

<ul>
	<li>
	<p>Long add(K key, V... values);<br />
	无序集合中添加元素，返回添加个数<br />
	也可以直接在add里面添加多个值 如：template.opsForSet().add(&quot;setTest&quot;,&quot;aaa&quot;,&quot;bbb&quot;)</p>

	<pre>
<code>使用：String[] strarrays = new String[]{&quot;strarr1&quot;,&quot;sgtarr2&quot;};
      System.out.println(template.opsForSet().add(&quot;setTest&quot;, strarrays));
结果：2</code></pre>
	</li>
	<li>
	<p>Long remove(K key, Object... values);<br />
	移除集合中一个或多个成员</p>

	<pre>
<code>使用：String[] strarrays = new String[]{&quot;strarr1&quot;,&quot;sgtarr2&quot;};
System.out.println(template.opsForSet().remove(&quot;setTest&quot;,strarrays));
结果：2</code></pre>
	</li>
	<li>
	<p>V pop(K key);<br />
	移除并返回集合中的一个随机元素</p>

	<pre>
<code>使用：System.out.println(template.opsForSet().pop(&quot;setTest&quot;));
System.out.println(template.opsForSet().members(&quot;setTest&quot;));
结果：bbb
[aaa, ccc]</code></pre>
	</li>
	<li>
	<p>Boolean move(K key, V value, K destKey);<br />
	将 member 元素从 source 集合移动到 destination 集合</p>

	<pre>
<code>使用：template.opsForSet().move(&quot;setTest&quot;,&quot;aaa&quot;,&quot;setTest2&quot;);
      System.out.println(template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(template.opsForSet().members(&quot;setTest2&quot;));
结果：[ccc]
[aaa]</code></pre>
	</li>
	<li>
	<p>Long size(K key);<br />
	无序集合的大小长度</p>

	<pre>
<code>使用：System.out.println(template.opsForSet().size(&quot;setTest&quot;));
结果：1</code></pre>
	</li>
	<li>
	<p>Boolean isMember(K key, Object o);<br />
	判断 member 元素是否是集合 key 的成员</p>

	<pre>
<code>使用：System.out.println(template.opsForSet().isMember(&quot;setTest&quot;,&quot;ccc&quot;));
      System.out.println(template.opsForSet().isMember(&quot;setTest&quot;,&quot;asd&quot;));
结果：true
false</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; intersect(K key, K otherKey);<br />
	key对应的无序集合与otherKey对应的无序集合求交集</p>

	<pre>
<code>使用：System.out.println(template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(template.opsForSet().intersect(&quot;setTest&quot;,&quot;setTest2&quot;));
结果：[aaa, ccc]
[aaa]
[aaa]</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys);<br />
	key对应的无序集合与多个otherKey对应的无序集合求交集</p>
	</li>
</ul>

<pre>
<code>使用：System.out.println(template.opsForSet().members(&quot;setTest&quot;));
        System.out.println(template.opsForSet().members(&quot;setTest2&quot;));
        System.out.println(template.opsForSet().members(&quot;setTest3&quot;));
        List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();
        strlist.add(&quot;setTest2&quot;);
        strlist.add(&quot;setTest3&quot;);
        System.out.println(template.opsForSet().intersect(&quot;setTest&quot;,strlist));
结果：[aaa, ccc]
[aaa]
[ccc, aaa]
[aaa]</code></pre>

<ul>
	<li>
	<p>Long intersectAndStore(K key, K otherKey, K destKey);<br />
	key无序集合与otherkey无序集合的交集存储到destKey无序集合中</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
System.out.println(template.opsForSet().intersectAndStore(&quot;setTest&quot;,&quot;setTest2&quot;,&quot;destKey1&quot;));
System.out.println(template.opsForSet().members(&quot;destKey1&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
2
[aaa, ccc]</code></pre>
	</li>
	<li>
	<p>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);<br />
	key对应的无序集合与多个otherKey对应的无序集合求交集存储到destKey无序集合中</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(&quot;setTest3:&quot; + template.opsForSet().members(&quot;setTest3&quot;));
      List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();
      strlist.add(&quot;setTest2&quot;);
      strlist.add(&quot;setTest3&quot;);
      System.out.println(template.opsForSet().intersectAndStore(&quot;setTest&quot;,strlist,&quot;destKey2&quot;));
      System.out.println(template.opsForSet().members(&quot;destKey2&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
setTest3:[ccc, aaa]
2
[aaa, ccc]</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; union(K key, K otherKey);<br />
	key无序集合与otherKey无序集合的并集</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(template.opsForSet().union(&quot;setTest&quot;,&quot;setTest2&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
[ccc, aaa, ddd, bbb]</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys);<br />
	key无序集合与多个otherKey无序集合的并集</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(&quot;setTest3:&quot; + template.opsForSet().members(&quot;setTest3&quot;));
      List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();
      strlist.add(&quot;setTest2&quot;);
      strlist.add(&quot;setTest3&quot;);
      System.out.println(template.opsForSet().union(&quot;setTest&quot;,strlist));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
setTest3:[xxx, ccc, aaa]
[ddd, xxx, bbb, aaa, ccc]</code></pre>
	</li>
	<li>
	<p>Long unionAndStore(K key, K otherKey, K destKey);<br />
	key无序集合与otherkey无序集合的并集存储到destKey无序集合中</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(template.opsForSet().unionAndStore(&quot;setTest&quot;,&quot;setTest2&quot;,&quot;unionAndStoreTest1&quot;));
      System.out.println(&quot;unionAndStoreTest1:&quot; + template.opsForSet().members(&quot;unionAndStoreTest1&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
4
unionAndStoreTest1:[ccc, aaa, ddd, bbb]</code></pre>
	</li>
	<li>
	<p>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);<br />
	key无序集合与多个otherkey无序集合的并集存储到destKey无序集合中</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(&quot;setTest3:&quot; + template.opsForSet().members(&quot;setTest3&quot;));
      List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();
      strlist.add(&quot;setTest2&quot;);
      strlist.add(&quot;setTest3&quot;);
      System.out.println(template.opsForSet().unionAndStore(&quot;setTest&quot;,strlist,&quot;unionAndStoreTest2&quot;));
      System.out.println(&quot;unionAndStoreTest2:&quot; + template.opsForSet().members(&quot;unionAndStoreTest2&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
setTest3:[xxx, ccc, aaa]
5
unionAndStoreTest2:[ddd, xxx, bbb, aaa, ccc]</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; difference(K key, K otherKey);<br />
	key无序集合与otherKey无序集合的差集</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(template.opsForSet().difference(&quot;setTest&quot;,&quot;setTest2&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
[bbb, ddd]</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys);<br />
	key无序集合与多个otherKey无序集合的差集</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(&quot;setTest3:&quot; + template.opsForSet().members(&quot;setTest3&quot;));
      List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();
      strlist.add(&quot;setTest2&quot;);
      strlist.add(&quot;setTest3&quot;);
      System.out.println(template.opsForSet().difference(&quot;setTest&quot;,strlist));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
setTest3:[xxx, ccc, aaa]
[bbb, ddd]</code></pre>
	</li>
	<li>
	<p>Long differenceAndStore(K key, K otherKey, K destKey);<br />
	key无序集合与otherkey无序集合的差集存储到destKey无序集合中</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(template.opsForSet().differenceAndStore(&quot;setTest&quot;,&quot;setTest2&quot;,&quot;differenceAndStore1&quot;));
      System.out.println(&quot;differenceAndStore1:&quot; + template.opsForSet().members(&quot;differenceAndStore1&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
2
differenceAndStore1:[bbb, ddd]</code></pre>
	</li>
	<li>
	<p>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);<br />
	key无序集合与多个otherkey无序集合的差集存储到destKey无序集合中</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTest2:&quot; + template.opsForSet().members(&quot;setTest2&quot;));
      System.out.println(&quot;setTest3:&quot; + template.opsForSet().members(&quot;setTest3&quot;));
      List&lt;String&gt; strlist = new ArrayList&lt;String&gt;();
      strlist.add(&quot;setTest2&quot;);
      strlist.add(&quot;setTest3&quot;);
      System.out.println(template.opsForSet().differenceAndStore(&quot;setTest&quot;,strlist,&quot;differenceAndStore2&quot;));
      System.out.println(&quot;differenceAndStore2:&quot; + template.opsForSet().members(&quot;differenceAndStore2&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTest2:[ccc, aaa]
setTest3:[xxx, ccc, aaa]
2
differenceAndStore2:[bbb, ddd]</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; members(K key);<br />
	返回集合中的所有成员</p>

	<pre>
<code>使用：System.out.println(template.opsForSet().members(&quot;setTest&quot;));
结果：[ddd, bbb, aaa, ccc]</code></pre>
	</li>
	<li>
	<p>V randomMember(K key);<br />
	随机获取key无序集合中的一个元素</p>

	<pre>
<code>使用：System.out.println(&quot;setTest:&quot; + template.opsForSet().members(&quot;setTest&quot;));
      System.out.println(&quot;setTestrandomMember:&quot; + template.opsForSet().randomMember(&quot;setTest&quot;));
      System.out.println(&quot;setTestrandomMember:&quot; + template.opsForSet().randomMember(&quot;setTest&quot;));
      System.out.println(&quot;setTestrandomMember:&quot; + template.opsForSet().randomMember(&quot;setTest&quot;));
      System.out.println(&quot;setTestrandomMember:&quot; + template.opsForSet().randomMember(&quot;setTest&quot;));
结果：setTest:[ddd, bbb, aaa, ccc]
setTestrandomMember:aaa
setTestrandomMember:bbb
setTestrandomMember:aaa
setTestrandomMember:ddd</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; distinctRandomMembers(K key, long count);<br />
	获取多个key无序集合中的元素（去重），count表示个数</p>

	<pre>
<code>使用：System.out.println(&quot;randomMembers:&quot; + template.opsForSet().distinctRandomMembers(&quot;setTest&quot;,5));
结果：randomMembers:[aaa, bbb, ddd, ccc]</code></pre>
	</li>
	<li>
	<p>List&lt;V&gt; randomMembers(K key, long count);<br />
	获取多个key无序集合中的元素，count表示个数</p>

	<pre>
<code>使用：System.out.println(&quot;randomMembers:&quot; + template.opsForSet().randomMembers(&quot;setTest&quot;,5));
结果：randomMembers:[ccc, ddd, ddd, ddd, aaa]</code></pre>
	</li>
	<li>
	<p>Cursor&lt;V&gt; scan(K key, ScanOptions options);<br />
	遍历set</p>

	<pre>
<code>使用：    Cursor&lt;Object&gt; curosr = template.opsForSet().scan(&quot;setTest&quot;, ScanOptions.NONE);
      while(curosr.hasNext()){
          System.out.println(curosr.next());
      }
结果：ddd
bbb
aaa
ccc</code></pre>
	</li>
</ul>

<h2>Redis的ZSet数据结构</h2>

<p>Redis 有序集合和无序集合一样也是string类型元素的集合,且不允许重复的成员。<br />
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br />
有序集合的成员是唯一的,但分数(score)却可以重复。<br />
public interface ZSetOperations&lt;K,V&gt;<br />
ZSetOperations提供了一系列方法对有序集合进行操作：</p>

<ul>
	<li>
	<p>Boolean add(K key, V value, double score);<br />
	新增一个有序集合，存在的话为false，不存在的话为true</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().add(&quot;zset1&quot;,&quot;zset-1&quot;,1.0));
结果：true</code></pre>
	</li>
	<li>
	<p>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples);<br />
	新增一个有序集合</p>

	<pre>
<code>使用：ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple1 = new DefaultTypedTuple&lt;Object&gt;(&quot;zset-5&quot;,9.6);
      ZSetOperations.TypedTuple&lt;Object&gt; objectTypedTuple2 = new DefaultTypedTuple&lt;Object&gt;(&quot;zset-6&quot;,9.9);
      Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = new HashSet&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt;();
      tuples.add(objectTypedTuple1);
      tuples.add(objectTypedTuple2);
      System.out.println(template.opsForZSet().add(&quot;zset1&quot;,tuples));
      System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
结果：[zset-1, zset-2, zset-3, zset-4, zset-5, zset-6]</code></pre>
	</li>
	<li>
	<p>Long remove(K key, Object... values);<br />
	从有序集合中移除一个或者多个元素</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
      System.out.println(template.opsForZSet().remove(&quot;zset1&quot;,&quot;zset-6&quot;));
      System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
结果：[zset-1, zset-2, zset-3, zset-4, zset-5, zset-6]
1
[zset-1, zset-2, zset-3, zset-4, zset-5]</code></pre>
	</li>
	<li>
	<p>Double incrementScore(K key, V value, double delta);<br />
	增加元素的score值，并返回增加后的值</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().incrementScore(&quot;zset1&quot;,&quot;zset-1&quot;,1.1));  //原为1.1
结果：2.2</code></pre>
	</li>
	<li>
	<p>Long rank(K key, Object o);<br />
	返回有序集中指定成员的排名，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
      System.out.println(template.opsForZSet().rank(&quot;zset1&quot;,&quot;zset-2&quot;));
结果：[zset-2, zset-1, zset-3, zset-4, zset-5]
0   //表明排名第一</code></pre>
	</li>
	<li>
	<p>Long reverseRank(K key, Object o);<br />
	返回有序集中指定成员的排名，其中有序集成员按分数值递减(从大到小)顺序排列</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
      System.out.println(template.opsForZSet().reverseRank(&quot;zset1&quot;,&quot;zset-2&quot;));
结果：[zset-2, zset-1, zset-3, zset-4, zset-5]
4 //递减之后排到第五位去了</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; range(K key, long start, long end);<br />
	通过索引区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().range(&quot;zset1&quot;,0,-1));
结果：[zset-2, zset-1, zset-3, zset-4, zset-5]</code></pre>
	</li>
	<li>
	<p>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end);<br />
	通过索引区间返回有序集合成指定区间内的成员对象，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;zset1&quot;,0,-1);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-2score:1.2
value:zset-1score:2.2
value:zset-3score:2.3
value:zset-4score:6.6
value:zset-5score:9.6</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; rangeByScore(K key, double min, double max);<br />
	通过分数返回有序集合指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().rangeByScore(&quot;zset1&quot;,0,5));
结果：[zset-2, zset-1, zset-3]</code></pre>
	</li>
	<li>
	<p>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max);<br />
	通过分数返回有序集合指定区间内的成员对象，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeByScoreWithScores(&quot;zset1&quot;,0,5);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-2score:1.2
value:zset-1score:2.2
value:zset-3score:2.3</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count);<br />
	通过分数返回有序集合指定区间内的成员，并在索引范围内，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：    System.out.println(template.opsForZSet().rangeByScore(&quot;zset1&quot;,0,5));
  System.out.println(template.opsForZSet().rangeByScore(&quot;zset1&quot;,0,5,1,2));
结果：[zset-2, zset-1, zset-3]
[zset-1, zset-3]</code></pre>
	</li>
	<li>
	<p>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count);<br />
	通过分数返回有序集合指定区间内的成员对象，并在索引范围内，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeByScoreWithScores(&quot;zset1&quot;,0,5,1,2);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-1score:2.2
value:zset-3score:2.3</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; reverseRange(K key, long start, long end);<br />
	通过索引区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递减(从大到小)顺序排列</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().reverseRange(&quot;zset1&quot;,0,-1));
结果：[zset-5, zset-4, zset-3, zset-1, zset-2]</code></pre>
	</li>
	<li>
	<p>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end);<br />
	通过索引区间返回有序集合成指定区间内的成员对象，其中有序集成员按分数值递减(从大到小)顺序排列</p>

	<pre>
<code>使用：Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().reverseRangeWithScores(&quot;zset1&quot;,0,-1);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-5score:9.6
value:zset-4score:6.6
value:zset-3score:2.3
value:zset-1score:2.2
value:zset-2score:1.2</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max);</p>

	<pre>
<code>使用：与rangeByScore调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列</code></pre>
	</li>
	<li>
	<p>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max);</p>

	<pre>
<code>使用：与rangeByScoreWithScores调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列</code></pre>
	</li>
	<li>
	<p>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max, long offset, long count);</p>

	<pre>
<code>使用：与rangeByScore调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列</code></pre>
	</li>
	<li>
	<p>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max, long offset, long count);</p>

	<pre>
<code>使用：与rangeByScoreWithScores调用方法一样，其中有序集成员按分数值递减(从大到小)顺序排列</code></pre>
	</li>
	<li>
	<p>Long count(K key, double min, double max);<br />
	通过分数返回有序集合指定区间内的成员个数</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().rangeByScore(&quot;zset1&quot;,0,5));
      System.out.println(template.opsForZSet().count(&quot;zset1&quot;,0,5));
结果：[zset-2, zset-1, zset-3]
3</code></pre>
	</li>
	<li>
	<p>Long size(K key);<br />
	获取有序集合的成员数，内部调用的就是zCard方法</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().size(&quot;zset1&quot;));
结果：6</code></pre>
	</li>
	<li>
	<p>Long zCard(K key);<br />
	获取有序集合的成员数</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().zCard(&quot;zset1&quot;));
结果：6</code></pre>
	</li>
	<li>
	<p>Double score(K key, Object o);<br />
	获取指定成员的score值</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().score(&quot;zset1&quot;,&quot;zset-1&quot;));
结果：2.2</code></pre>
	</li>
	<li>
	<p>Long removeRange(K key, long start, long end);<br />
	移除指定索引位置的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().range(&quot;zset2&quot;,0,-1));
      System.out.println(template.opsForZSet().removeRange(&quot;zset2&quot;,1,2));
      System.out.println(template.opsForZSet().range(&quot;zset2&quot;,0,-1));
结果：[zset-1, zset-2, zset-3, zset-4]
2
[zset-1, zset-4]</code></pre>
	</li>
	<li>
	<p>Long removeRangeByScore(K key, double min, double max);<br />
	根据指定的score值得范围来移除成员</p>

	<pre>
<code>使用：//System.out.println(template.opsForZSet().add(&quot;zset2&quot;,&quot;zset-1&quot;,1.1));
      //System.out.println(template.opsForZSet().add(&quot;zset2&quot;,&quot;zset-2&quot;,1.2));
      //System.out.println(template.opsForZSet().add(&quot;zset2&quot;,&quot;zset-3&quot;,2.3));
      //System.out.println(template.opsForZSet().add(&quot;zset2&quot;,&quot;zset-4&quot;,6.6));
System.out.println(template.opsForZSet().range(&quot;zset2&quot;,0,-1));
System.out.println(template.opsForZSet().removeRangeByScore(&quot;zset2&quot;,2,3));
  System.out.println(template.opsForZSet().range(&quot;zset2&quot;,0,-1));
结果：[zset-1, zset-2, zset-3,zset-4]
1
[zset-1, zset-2, zset-4]</code></pre>
	</li>
	<li>
	<p>Long unionAndStore(K key, K otherKey, K destKey);<br />
	计算给定的一个有序集的并集，并存储在新的 destKey中，key相同的话会把score值相加</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-1&quot;,1.0));
      System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-2&quot;,2.0));
      System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-3&quot;,3.0));
      System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-4&quot;,6.0));

      System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-1&quot;,1.0));
      System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-2&quot;,2.0));
      System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-3&quot;,3.0));
      System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-4&quot;,6.0));
      System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-5&quot;,7.0));
      System.out.println(template.opsForZSet().unionAndStore(&quot;zzset1&quot;,&quot;zzset2&quot;,&quot;destZset11&quot;));

      Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset11&quot;,0,-1);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-1score:2.0
value:zset-2score:4.0
value:zset-3score:6.0
value:zset-5score:7.0
value:zset-4score:12.0</code></pre>
	</li>
	<li>
	<p>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);<br />
	计算给定的多个有序集的并集，并存储在新的 destKey中</p>

	<pre>
<code>使用：//System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-1&quot;,1.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-2&quot;,2.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-3&quot;,3.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset1&quot;,&quot;zset-4&quot;,6.0));
      //
      //System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-1&quot;,1.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-2&quot;,2.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-3&quot;,3.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-4&quot;,6.0));
      //System.out.println(template.opsForZSet().add(&quot;zzset2&quot;,&quot;zset-5&quot;,7.0));

      System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-1&quot;,1.0));
      System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-2&quot;,2.0));
      System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-3&quot;,3.0));
      System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-4&quot;,6.0));
      System.out.println(template.opsForZSet().add(&quot;zzset3&quot;,&quot;zset-5&quot;,7.0));

      List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
      stringList.add(&quot;zzset2&quot;);
      stringList.add(&quot;zzset3&quot;);
      System.out.println(template.opsForZSet().unionAndStore(&quot;zzset1&quot;,stringList,&quot;destZset22&quot;));

      Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset22&quot;,0,-1);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-1score:3.0
value:zset-2score:6.0
value:zset-3score:9.0
value:zset-5score:14.0
value:zset-4score:18.0</code></pre>
	</li>
	<li>
	<p>Long intersectAndStore(K key, K otherKey, K destKey);<br />
	计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</p>

	<pre>
<code>使用：System.out.println(template.opsForZSet().intersectAndStore(&quot;zzset1&quot;,&quot;zzset2&quot;,&quot;destZset33&quot;));

      Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset33&quot;,0,-1);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-1score:2.0
value:zset-2score:4.0
value:zset-3score:6.0
value:zset-4score:12.0</code></pre>
	</li>
	<li>
	<p>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);<br />
	计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</p>

	<pre>
<code>使用：List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();
      stringList.add(&quot;zzset2&quot;);
      stringList.add(&quot;zzset3&quot;);
      System.out.println(template.opsForZSet().intersectAndStore(&quot;zzset1&quot;,stringList,&quot;destZset44&quot;));

      Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(&quot;destZset44&quot;,0,-1);
      Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();
      while (iterator.hasNext())
      {
          ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();
          System.out.println(&quot;value:&quot; + typedTuple.getValue() + &quot;score:&quot; + typedTuple.getScore());
      }
结果：value:zset-1score:3.0
value:zset-2score:6.0
value:zset-3score:9.0
value:zset-4score:18.0</code></pre>
	</li>
	<li>
	<p>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options);<br />
	遍历zset</p>

	<pre>
<code>使用：    Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; cursor = template.opsForZSet().scan(&quot;zzset1&quot;, ScanOptions.NONE);
      while (cursor.hasNext()){
          ZSetOperations.TypedTuple&lt;Object&gt; item = cursor.next();
          System.out.println(item.getValue() + &quot;:&quot; + item.getScore());
      }
结果：zset-1:1.0
zset-2:2.0
zset-3:3.0
zset-4:6.0</code></pre>
	</li>
</ul>

<p>注：TimeUnit是java.util.concurrent包下面的一个类，表示给定单元粒度的时间段<br />
常用的颗粒度<br />
TimeUnit.DAYS //天<br />
TimeUnit.HOURS //小时<br />
TimeUnit.MINUTES //分钟<br />
TimeUnit.SECONDS //秒<br />
TimeUnit.MILLISECONDS //毫秒</p>

<p>参考文档：Redis实战[约西亚 L.卡尔森 (Josiah L.Carlson)]<br />
Spring官方文档</p>
