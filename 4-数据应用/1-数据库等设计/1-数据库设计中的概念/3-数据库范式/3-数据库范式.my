<h1>数据库范式</h1>

<p>设计关系<a href="http://baike.baidu.com/view/1088.htm" target="_blank">数据库</a>时，遵从不同的规范<a href="http://baike.baidu.com/view/198817.htm" target="_blank">要求</a>，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>

<p>目前<a href="http://baike.baidu.com/view/68348.htm" target="_blank">关系数据库</a>有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、<a href="http://baike.baidu.com/view/176748.htm" target="_blank">第四范式</a>(4NF）和<a href="http://baike.baidu.com/view/7170192.htm" target="_blank">第五范式</a>（5NF，又称完美范式）。</p>

<p>中文名</p>

<p>数据库标准化</p>

<p>外文名</p>

<p>Database Normalization</p>

<p>定义</p>

<p>减少数据库中数据冗余的过程</p>

<p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</p>

<p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p>

<p>&nbsp;</p>

<p>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。</p>

<h2>各类范式</h2>

<h3>第一范式（1NF）</h3>

<p>&nbsp;&nbsp; &nbsp;所谓第一范式（1NF）是指在关系模型中，对域添加的一个规范要求，<span class="marker">所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项</span>，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。</p>

<p>&nbsp;&nbsp; &nbsp;说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。</p>

<h3>第二范式（2NF）</h3>

<p>&nbsp;&nbsp; &nbsp;在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>

<p>&nbsp;&nbsp; &nbsp;第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。<span class="marker">第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分</span>。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。例如在员工表中的身份证号码即可实现每个一员工的区分，该身份证号码即为<span class="marker">候选键(可以作为主键的单个属性)</span>，<span class="marker">任何一个候选键都可以被选作主键</span>。在找不到候选键时，可额外增加属性以实现区分，如果在员工关系中，没有对其身份证号进行存储，而姓名可能会在数据库运行的某个时间重复，无法区分出实体时，设计辟如ID等不重复的编号以实现区分，被添加的编号或ID选作主键。（该主键的添加是在ER设计时添加，不是建库时随意添加）</p>

<p>&nbsp;&nbsp; &nbsp;第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。</p>

<h3>第三范式（3NF）</h3>

<p>&nbsp;&nbsp; &nbsp;在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上<span class="marker">消除传递依赖</span>）</p>

<p>&nbsp;&nbsp; &nbsp;第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。</p>

<h3>巴斯-科德范式（BCNF）</h3>

<p>&nbsp;&nbsp; &nbsp;Boyce-Codd Normal Form（巴斯-科德范式）</p>

<p>&nbsp;&nbsp; &nbsp;在3NF基础上，任何非主属性不能对主键子集依赖（在3NF基础上<span class="marker">消除对主码子集的依赖</span>）</p>

<p>&nbsp;&nbsp; &nbsp;巴斯-科德范式（BCNF）是第三范式（3NF）的一个子集，即满足巴斯-科德范式（BCNF）必须满足第三范式（3NF）。通常情况下，巴斯-科德范式被认为没有新的设计规范加入，只是对第二范式与第三范式中设计规范要求更强，因而被认为是修正第三范式，也就是说，它事实上是对第三范式的修正，使数据库冗余度更小。这也是BCNF不被称为第四范式的原因。某些书上，根据范式要求的递增性将其称之为第四范式是不规范，也是更让人不容易理解的地方。而真正的第四范式，则是在设计规范中添加了对多值及依赖的要求。</p>

<p>&nbsp;&nbsp; &nbsp;定义：关系模式R&lt;U,F&gt;&isin;1FNF,若X&rarr;Y且Y不是X的子集时X必含有码，则R&lt;U,F&gt;&isin;BCNF。也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;&isin;BCNF。<br />
&nbsp;&nbsp; &nbsp;由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-所有非主属性对每一个码都是完全函数依赖。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-所有主属性对每一个不包含它的码也是完全函数依赖。<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;-没有任何属性完全函数依赖于非码的任何一组属性。<br />
&nbsp;&nbsp; &nbsp;若R&isin;BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R&isin;3NF。[1]<br />
&nbsp;&nbsp; &nbsp;一般关系型数据库设计中，达到BCNF就可以了！</p>

<h3>第四范式（4NF）</h3>

<p>&nbsp; &nbsp;在一个多对多的关系中，独立的实体不能存放在同一个表格中</p>

<p>&nbsp; &nbsp;由于它仅应用于多对多的关系，因此大多数的开发者可以忽略这条规定。不过在某些情况下，它是非常实用的，这个例子就是这样，我们通过将相同的实体分离出来，并且将关系移到它们自己的表格中，从而改进了urls表格。<br />
&nbsp; &nbsp;为了令你更容易明白，我们举个具体的例子，以下将用一个SQL语句选择出所有属于joe的urls：<br />
&nbsp; &nbsp;SELECT name, url FROM users, urls, url_relations WHERE url_relations.relatedUserId = 1 AND users.userId = 1 AND urls.urlId = url_relations.relatedUrlId<br />
&nbsp; &nbsp;如果我们想要遍历每个人的个人信息和url信息，我们可以这样做：<br />
&nbsp; &nbsp;SELECT name, url FROM users, urls, url_relations WHERE users.userId = url_relations.relatedUserId AND urls.urlId = url_relations.relatedUrlId</p>

<h3>第五范式（5NF）</h3>

<p>&nbsp; &nbsp;原来的表格必须可以通过由它分离出去的表格重新构建。 这一级正规化的形式，它并不常见，有点深奥，并且在大部分的情况下都是不必要的。</p>

<p>&nbsp; &nbsp;使用这个规定的好处是，你可以确保不会在分离的表格中引入多余的列，所有你创建的表格结构都与它们的实际需要一样大。应用这条规定是一个好习惯，不过除非你要处理一个非常大型的数据，否则你将不需要用到它。<br />
&nbsp; &nbsp;你可能想知道这些方法是从哪来的，前面三个正规化的规定是1972年，Dr. E.F. Codd在他的论文&ldquo;进一步正规化数据库的关系模型中&rdquo;提出的，其余的规定是经过后来的集合理论和关系数学家理论化的。 评论：正所谓物级必反，将表格分得过细有时并不好，因为这样需要将各表进行各种的关联，这会令查询时变得复杂，而且效率也可能降低，这些正规化的规定可以参考，在实际应用时，要根据项目的大小，必要时可以进行一些测试，以设计出更合理的表格结构。</p>

<h2>范式应用实例</h2>

<p>下面以一个学校的学生系统为例分析说明，这几个范式的应用。</p>

<h3>第一范式（1NF）</h3>

<p>&nbsp;&nbsp; &nbsp;数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。</p>

<p>&nbsp;&nbsp; &nbsp;首先我们确定一下要设计的内容包括那些。学号、学生姓名、年龄、性别、课程名称、课程学分、系别、学科成绩，系办地址、系办电话等信息。为了简单我们暂时只考虑这些字段信息。我们对于这些信息，所关心的问题有如下几个方面。</p>

<p>&nbsp;&nbsp; &nbsp;学生有那些基本信息？</p>

<p>&nbsp;&nbsp; &nbsp;学生选了那些课，成绩是什么？</p>

<p>&nbsp;&nbsp; &nbsp;每个课的学分是多少？</p>

<p>&nbsp;&nbsp; &nbsp;学生属于那个系，系的基本信息是什么？</p>

<h3>第二范式（2NF）</h3>

<p>&nbsp;&nbsp; &nbsp;首先我们考虑，把所有这些信息放到一个表中（学号，学生姓名、年龄、性别、课程、课程学分、系别、学科成绩，系办地址、系办电话）下面存在如下的依赖关系。</p>

<p>&nbsp;&nbsp; &nbsp;(学号, 课程名称) &rarr; (姓名, 年龄, 成绩, 学分)</p>

<p>&nbsp;&nbsp; &nbsp;问题分析</p>

<p>&nbsp;&nbsp; &nbsp;因此不满足第二范式的要求，会产生如下问题：</p>

<p>&nbsp;&nbsp; &nbsp;数据冗余：同一门课程由n个学生选修，&quot;学分&quot;就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</p>

<p>&nbsp;&nbsp; &nbsp;更新异常：</p>

<p>&nbsp;&nbsp; &nbsp;1）若调整了某门课程的学分，数据表中所有行的&quot;学分&quot;值都要更新，否则会出现同一门课程学分不同的情况。</p>

<p>&nbsp;&nbsp; &nbsp;2）假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有&quot;学号&quot;关键字，课程名称和学分也无法记录入数据库。</p>

<p>&nbsp;&nbsp; &nbsp;删除异常 ：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</p>

<p>&nbsp;&nbsp; &nbsp;解决方案</p>

<p>&nbsp;&nbsp; &nbsp;把选课关系表SelectCourse改为如下三个表：</p>

<p>&nbsp;&nbsp; &nbsp;学生：Student（学号，姓名，年龄，性别，系别，系办地址、系办电话）；</p>

<p>&nbsp;&nbsp; &nbsp;课程：Course（课程名称,学分）；</p>

<p>&nbsp;&nbsp; &nbsp;选课关系：SelectCourse（学号，课程名称，成绩）。</p>

<h3>第三范式（3NF）</h3>

<p>&nbsp;&nbsp; &nbsp;接着看上面的学生表Student（学号，姓名，年龄，性别，系别，系办地址、系办电话），关键字为单一关键字&quot;学号&quot;，因为存在如下决定关系：</p>

<p>&nbsp;&nbsp; &nbsp;（学号）&rarr; （姓名，年龄，性别，系别，系办地址、系办电话</p>

<p>&nbsp;&nbsp; &nbsp;但是还存在下面的决定关系：</p>

<p>&nbsp;&nbsp; &nbsp;（学号） &rarr; (系别）&rarr;（系办地点，系办电话）</p>

<p>&nbsp;&nbsp; &nbsp;即存在非关键字段&quot;系办地点&quot;、&quot;系办电话&quot;对关键字段&quot;学号&quot;的传递函数依赖。</p>

<p>&nbsp;&nbsp; &nbsp;它也会存在数据冗余、更新异常、插入异常和删除异常的情况。（数据的更新，删除异常这里就不分析了，可以参照2.1.1进行分析）</p>

<p>&nbsp;&nbsp; &nbsp;根据第三范式把学生关系表分为如下两个表就可以满足第三范式了：</p>

<p>&nbsp;&nbsp; &nbsp;学生：（学号，姓名，年龄，性别，系别）；</p>

<p>&nbsp;&nbsp; &nbsp;系别：（系别，系办地址、系办电话）。</p>

<p>&nbsp;&nbsp; &nbsp;上面的数据库表就是符合I，Ⅱ，Ⅲ范式的，消除了数据冗余、更新异常、插入异常和删除异常。</p>

<p>&nbsp;</p>
