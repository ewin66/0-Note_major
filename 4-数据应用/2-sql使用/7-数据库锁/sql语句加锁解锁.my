<h1>怎样用SQL语句对数据库表进行加锁和解锁?</h1>

<p>据库中的一个非常重要的概念，它主要用于多用户环境下保证数据库完整性和一致性。 我们知道，多个用户能够同时操纵同一个数据库中的数据，会发生数据不一致现象。即如果没有锁定且多个用户同时访问一个数据库，则当他们的事务同时使用相同的数据时可能会发生问题。这些问题包括：丢失更新、脏读、不可重复读和幻觉读：</p>

<p><br />
1．当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。例如，两个编辑人员制作了同一文档的电子复本。每个编辑人员独立地更改其复本，然后保存更改后的复本，这样就覆盖了原始文档。最后保存其更改复本的编辑人员覆盖了第一个编辑人员所做的更改。如果在第一个编辑人员完成之后第二个编辑人员才能进行更改，则可以避免该问题。</p>

<p><br />
2. 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。例如，一个编辑人员正在更改电子文档。在更改过程中，另一个编辑人员复制了该文档（该复本包含到目前为止所做的全部更改）并将其分发给预期的用户。此后，第一个编辑人员认为目前所做的更改是错误的，于是删除了所做的编辑并保存了文档。分发给用户的文档包含不再存在的编辑内容，并且这些编辑内容应认为从未存在过。如果在第一个编辑人员确定最终更改前任何人都不能读取更改的文档，则可以避免该问题。</p>

<p><br />
3．不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。</p>

<p>&nbsp;<br />
4．幻觉读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。</p>

<p><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 所以，处理多用户并发访问的方法是加锁。锁是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。当一个用户锁住数据库中的某个对象时，其他用户就不能再访问该对象。加锁对并发访问的影响体现在锁的粒度上。为了控制锁定的资源，应该首先了解系统的空间管理。在SQL Server 2000系统中，最小的空间管理单位是页，一个页有8K。所有的数据、日志、索引都存放在页上。另外，使用页有一个限制，这就是表中的一行数据必须在同一个页上，不能跨页。页上面的空间管理单位是盘区，一个盘区是8个连续的页。表和索引的最小占用单位是盘区。数据库是由一个或者多个表或者索引组成，即是由多个</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p><strong>SQL语句：</strong></p>

<p>LOCK TABLES tablename WRITE;<br />
LOCK TABLES tablename READ;<br />
INSERT INTO assignment VALUES (1,7513,&#39;0000-00-00&#39;,5),(1,7513,&#39;2003-01-20&#39;,8.5);<br />
UNLOCK TABLES;</p>

<p><strong>对于多个用户同时提交表单，并且同时向数据库中得到表单ID，我是这样解决的：</strong></p>

<p>mysql_query(&quot;lock tables po read&quot;);<br />
mysql_query(&quot;lock tables po write&quot;);</p>

<p>mysql_query(&quot;update po set id=id +1&quot;))；// increase po id</p>

<p>$sql = &quot;SELECT id FROM po&quot;;<br />
$result = mysql_query($sql);<br />
if ($row = mysql_fetch_assoc($result)) {<br />
&nbsp;&nbsp;&nbsp; echo $row[&quot;id&quot;]; // this order will use this id<br />
}</p>

<p>mysql_free_result($result);<br />
mysql_query(&quot;unlock tables&quot;);</p>

<p>。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p>

<p>帮忙看看如何在这段代码前后给数据库写加锁和解锁语句</p>

<p>&#39;（在这里给数据库加锁，如何写加锁语句？）&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ...............&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; i = str（从记录集rst0中得到最大入库单号）&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &#39;若不加锁，在这容易造成并发冲突。因为在申请到最大入库单号之后还没有来得及建立实际记录，其它客户端可能也申请到了同样的入库单号&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ..............&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; rst.open &quot;select * from 入库 where 入库单号= &quot; + i + &quot; and 商品ID=0 &quot;, cn, adOpenStatic, adLockOptimistic&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; If rst.RecordCount = 0 Then 下一个入库单号 = i + 1&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ...............&nbsp;<br />
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &#39;（在这里给数据库解锁，如何写解锁语句？）</p>

<p>解答1：先将需要加锁执行的语句声明成一个事务（如2楼），然后加锁，SQL Server中锁的类型很多，看你需要加哪种类型的锁：&nbsp;<br />
HOLDLOCK&nbsp;将共享锁保留到事务完成，而不是在相应的表、行或数据页不再需要时就立即释放锁。HOLDLOCK 等同于 SERIALIZABLE。&nbsp;<br />
NOLOCK&nbsp;&nbsp;&nbsp; 不要发出共享锁，并且不要提供排它锁。当此选项生效时，可能会读取未提交的事务或一组在读取中间回滚的页面。有可能发生脏读。仅应用于 SELECT 语句。&nbsp;<br />
PAGLOCK&nbsp;&nbsp;&nbsp; 在通常使用单个表锁的地方采用页锁。&nbsp;<br />
READCOMMITTED&nbsp;用与运行在提交读隔离级别的事务相同的锁语义执行扫描。默认情况下，SQL Server 2000 在此隔离级别上操作。&nbsp;<br />
READPAST&nbsp;跳过锁定行。此选项导致事务跳过由其它事务锁定的行（这些行平常会显示在结果集内），而不是阻塞该事务，使其等待其它事务释放在这些行上的锁。 READPAST 锁提示仅适用于运行在提交读隔离级别的事务，并且只在行级锁之后读取。仅适用于 SELECT 语句。&nbsp;<br />
READUNCOMMITTED&nbsp;等同于 NOLOCK。&nbsp;<br />
REPEATABLEREAD&nbsp;用与运行在可重复读隔离级别的事务相同的锁语义执行扫描。 &nbsp;&nbsp;&nbsp;<br />
ROWLOCK&nbsp;使用行级锁，而不使用粒度更粗的页级锁和表级锁。&nbsp;<br />
SERIALIZABLE&nbsp;用与运行在可串行读隔离级别的事务相同的锁语义执行扫描。等同于 HOLDLOCK。&nbsp;<br />
TABLOCK&nbsp;使用表锁代替粒度更细的行级锁或页级锁。在语句结束前，SQL Server 一直持有该锁。但是，如果同时指定 HOLDLOCK，那么在事务结束之前，锁将被一直持有。&nbsp;<br />
TABLOCKX&nbsp;&nbsp;&nbsp; 使用表的排它锁。该锁可以防止其它事务读取或更新表，并在语句或事务结束前一直持有。&nbsp;<br />
UPDLOCK&nbsp;&nbsp;&nbsp; 读取表时使用更新锁，而不使用共享锁，并将锁一直保留到语句或事务的结束。UPDLOCK 的优点是允许您读取数据（不阻塞其它事务）并在以后更新数据，同时确保自从上次读取数据后数据没有被更改。&nbsp;<br />
XLOCK&nbsp;使用排它锁并一直保持到由语句处理的所有数据上的事务结束时。可以使用 PAGLOCK 或 TABLOCK 指定该锁，这种情况下排它锁适用于适当级别的粒度。</p>

<p>解答2&rdquo;要使一表在整个处理过程中不会被并发修改<br />
可用事务<br />
begin tran<br />
select * from 表名 with HOLDLOCK&nbsp;&nbsp;<br />
--处理语句<br />
........<br />
............<br />
<br />
<br />
commit tran<br />
<br />
<br />
加了 with holdlock后,在事务提交之前,别人动不了你的表<br />
。。。。。。。。。。。。。。。。。。。。。。。。。。。。</p>
