<h1>分解关联查询</h1>

<h2>分解关联査询</h2>

<p>很多髙性能的应用都会对关联奄询进行分简单地，可以对毎一个表进行一次单表査询，然后将结果在应用程序中进行关联。例如，下面这个査询：</p>

<p>SELECT * FROM tag<br />
&nbsp;&nbsp; &nbsp;JOIN tag_post ON tag_post.tag_id &nbsp;= tag.id<br />
&nbsp;&nbsp; &nbsp;JOIN post&nbsp; &nbsp; &nbsp; &nbsp; ON tag_post.post_id = post.id<br />
WHERE tag.tag =&#39;mysql&#39;;</p>

<p>可以分解成下面这些査询来代替：</p>

<p>SELECT * FROM tag WHERE tag = &#39;mysql&#39;；<br />
SELECT * FROM tag_post WEREtag_id-l234；<br />
SELECT * FROM post WHERE post.id in(123,456,789)；</p>

<p>到底为什么要这样做？乍一看，这样做并没有什么好处，原本一条査询，这里却变成多条査询，返回的结果又是一模一样的，亊实上，用分解关联査询的方式重构査询有如下的优势：</p>

<p>让缓存的效串更高，许多应用程序可以方便地缓存单表査询对应的结果对象。例如，上面査询中的tag已经被缓存了，那么应用躭可以眺过第一个査询再例如，应用中已经绥存了ID为123、567、789的内容，那么第三个査询的IN()中就可以少几个ID。另外，对MySQL的査询绥存来说&amp;6,如果关联中的某个表发生了变化，那么就无法使用査询线存了，而拆分后，如果某个表很少改变，那么基于该表的査询就可以重复利用査询级存结果了，</p>

<p>将査询分解后，执行单个査询可以减少锁的竞争。</p>

<p>在应用层做关联，吋以更容易对数据库进行拆分，更容姑做到高性能和可扩展，</p>

<p>査询本身效串也可能会有所提升。这个例子中，使用IN(}代替关联査洵，可以让MySQL按照ID顺序进行査询，这可能比随机的关联要更高效。我们后续将详细介绍这点。</p>

<p>可以减少冗余记录的査洵。在应用层做关联査询，意味吞对于某条记录应用只箝要査询一次，而在数据库中做关联査询，則可能箱要重复地访问一部分数据，从这点看，这样的重构还可能会减少网络和内存的消耗。</p>

<p>更进一步，这样做相当于在应用中实现了哈希关联.而不是使用MySQL的嵌套循环关联。某些场合哈希关联的效串要高很多</p>

<h2>为什么现在项目不写关联查询(left join)</h2>

<p>大多数项目，发展的后期，性能瓶颈都出现在了数据库上，然而在数据库上做优化的空间非常小。<br />
相反，在应用上做优化的空间就大多了，比如集群，分布式，缓存等等，可以轻易地把计算压力分解到n台服务器上。<br />
left join的目的无非是把两个模型上的数据合并到一个模型上，这是需要运算的，数据量越大运算量越大，更何况，数据库在left join的设计上，表现并不理想。<br />
假如我们使用leftj oin，意味着省事，程序员把合并数据的过程交给了数据库，自己省去了一堆代码，可是，等以后，数据量大了，数据库忙不过来了，怎么办？怎么把left join数据库的压力分解到多台服务器上？ 也许会有很牛逼的数据库大师，可以想到很好的办法，但是大多数人，都会头疼。<br />
假如我们不用left join呢？数据库只干自己最擅长的:单表存和查。我们多写几行代码，帮数据库打了个杂，我们的程序运算量大了，我们很容易做集群，做分布式，做缓存，而且，单表查询，尤其是根据主键进行的单表查询，也很容易借助缓存，缓存本身又很容易集群。<br />
看到了吧，压力分解变得简单多了，所以，避免left join,多写了点代码，别以为架构师为了让你工作更饱和，没事给你找事做，他让后面服务的承载力看到了希望</p>
